<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural Crafting Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='40' height='48' viewport='0 0 100 100' style='font-size:24px;'><text y='50%'>‚õèÔ∏è</text></svg>") 16 24, auto;
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #1a202c;
        }

        #game-viewport {
            position: relative;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #canvas {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        #player {
            position: absolute;
            width: 8px;
            height: 8px;
            transform: translate(-50%, -50%);
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .pixelated {
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .bubble-effect {
            animation: bubble 0.5s ease-out;
        }

        @keyframes bubble {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">
    
    <div id="game-viewport">
        <canvas id="canvas" class="pixelated"></canvas>
        <div id="player">
            <span id="player-emoji" class="text-lg">üö∂</span>
        </div>
        <div id="loading" class="absolute inset-0 flex items-center justify-center bg-gray-800 bg-opacity-75 z-50 transition-opacity duration-300 hidden">
            <svg class="animate-spin h-8 w-8 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
        </div>
        <!-- In-game HUD -->
        <div class="absolute top-4 left-4 p-3 bg-gray-800 bg-opacity-75 rounded-lg shadow-md z-20">
            <div class="flex flex-col gap-2 text-sm font-semibold">
                <div class="flex justify-between items-center">
                    <span>üíß Thirst:</span>
                    <span id="thirstText">100%</span>
                </div>
                <div class="w-full h-2 bg-gray-900 rounded-full overflow-hidden">
                    <div id="thirstFill" class="h-full bg-blue-500 transition-all duration-200" style="width: 100%;"></div>
                </div>
                <div class="flex justify-between items-center text-sm font-semibold">
                    <span>‚ö° Speed:</span>
                    <span id="speedModifierText">1x</span>
                </div>
                <div class="flex flex-col mt-2">
                    <div class="flex justify-between items-center">
                        <span>üó∫Ô∏è Pos:</span>
                        <span id="posText">0, 0</span>
                    </div>
                    <div class="flex justify-between items-center">
                        <span>üå≤ Biome:</span>
                        <span id="biomeText">...</span>
                    </div>
                     <div class="flex justify-between items-center">
                        <span>üõñ Shelter:</span>
                        <span id="shelterStatus" class="text-red-400">No</span>
                    </div>
                    <div class="flex justify-between items-center">
                        <span>‚å®Ô∏è Keys:</span>
                        <span id="keysText">...</span>
                    </div>
                </div>
            </div>
        </div>
        <div class="absolute top-4 right-4 p-3 bg-gray-800 bg-opacity-75 rounded-lg shadow-md z-20">
            <div class="flex flex-col gap-2 text-sm font-semibold">
                <div class="flex justify-between items-center">
                    <span>ü™µ Wood:</span>
                    <span id="woodCount">0</span>
                </div>
                <div class="flex justify-between items-center text-sm font-semibold">
                    <span>ü™® Stone:</span>
                    <span id="stoneCount">0</span>
                </div>
                <div class="flex justify-between items-center text-sm font-semibold">
                    <span>üíß Water:</span>
                    <span id="waterCount">0</span>
                </div>
            </div>
        </div>
        <div id="fpsOverlay" class="absolute inset-0 bg-gray-900 bg-opacity-80 hidden z-30">
            <div class="flex flex-col items-center justify-center h-full w-full">
                <h2 class="text-xl font-bold text-white mb-2">FPS Performance</h2>
                <div class="flex justify-between items-center mb-4 text-sm font-mono text-center">
                    <div class="mx-4">Current: <span id="currentFps">--</span> FPS</div>
                    <div class="mx-4">Min: <span id="minFps">--</span> FPS</div>
                    <div class="mx-4">Max: <span id="maxFps">--</span> FPS</div>
                </div>
                <div class="relative w-3/4 h-1/2 border border-gray-600 rounded-lg">
                    <canvas id="fpsGraph" class="w-full h-full bg-gray-900"></canvas>
                </div>
            </div>
        </div>
        <div id="messageBox" class="absolute top-24 right-4 flex justify-center z-40">
            <div id="messageText" class="p-3 bg-gray-700 text-white rounded-lg shadow-md hidden text-center w-auto"></div>
        </div>
        
        <!-- Minimap -->
        <div class="absolute bottom-4 left-4 z-40">
            <div class="w-48 h-48 bg-gray-800 border-2 border-gray-600 rounded-lg overflow-hidden relative">
                <canvas id="minimapCanvas" class="w-full h-full pixelated"></canvas>
                <div id="minimapPlayer" class="absolute w-2 h-2 bg-red-500 rounded-full" style="left: 50%; top: 50%; transform: translate(-50%, -50%);"></div>
            </div>
        </div>
    </div>

    <!-- Pause Menu -->
    <div id="pauseMenu" class="fixed inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center z-50 hidden p-4">
        <div class="bg-gray-800 p-6 sm:p-8 rounded-xl shadow-lg w-full max-w-2xl flex flex-col items-center gap-6">
            <h2 class="text-2xl sm:text-3xl font-bold text-white text-center">Game Paused</h2>
            <div class="text-center">
                <p class="text-sm text-gray-400">Press <kbd class="px-2 py-1 text-xs font-semibold bg-gray-700 rounded-md border border-gray-600">Esc</kbd> to resume.</p>
                <p class="text-sm text-gray-400 mt-1">Press <kbd class="px-2 py-1 text-xs font-semibold bg-gray-700 rounded-md border border-gray-600">C</kbd> for crafting.</p>
            </div>
            <div class="controls w-full grid grid-cols-1 sm:grid-cols-2 gap-4">
                <div class="flex flex-col items-center">
                    <label for="seedInput" class="text-sm font-semibold mb-2">Seed</label>
                    <input type="text" id="seedInput" placeholder="Enter a number" value="12345" class="w-full text-center bg-gray-700 rounded-lg py-2 px-3 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div class="flex flex-col items-center">
                    <label for="heightScaleSlider" class="text-sm font-semibold mb-2">Height Scale: <span id="heightScaleValue">50</span></label>
                    <input type="range" id="heightScaleSlider" min="20" max="150" value="50" class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div class="flex flex-col items-center">
                    <label for="moistureScaleSlider" class="text-sm font-semibold mb-2">Moisture Scale: <span id="moistureScaleValue">80</span></label>
                    <input type="range" id="moistureScaleSlider" min="20" max="150" value="80" class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div class="flex flex-col items-center">
                    <label for="pixelScaleSlider" class="text-sm font-semibold mb-2">Pixel Scale: <span id="pixelScaleValue">12</span></label>
                    <input type="range" id="pixelScaleSlider" min="1" max="24" value="12" class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div class="flex flex-col items-center">
                    <label for="octavesSlider" class="text-sm font-semibold mb-2">Octaves: <span id="octavesValue">6</span></label>
                    <input type="range" id="octavesSlider" min="1" max="10" value="6" class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div class="flex flex-col items-center">
                    <label for="persistenceSlider" class="text-sm font-semibold mb-2">Persistence: <span id="persistenceValue">0.5</span></label>
                    <input type="range" id="persistenceSlider" min="0.1" max="1" step="0.05" value="0.5" class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div class="flex flex-col items-center">
                    <label for="playerSpeedSlider" class="text-sm font-semibold mb-2">Player Speed: <span id="playerSpeedValue">2</span></label>
                    <input type="range" id="playerSpeedSlider" min="0.5" max="5" step="0.5" value="2" class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div class="flex flex-col items-center">
                    <label for="sunAngleSlider" class="text-sm font-semibold mb-2">Sun Angle: <span id="sunAngleValue">45</span>¬∞</label>
                    <input type="range" id="sunAngleSlider" min="0" max="360" value="45" class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div class="flex flex-col items-center">
                    <label for="waterLevelSlider" class="text-sm font-semibold mb-2">Water Level: <span id="waterLevelValue">0.45</span></label>
                    <input type="range" id="waterLevelSlider" min="0.0" max="1.0" step="0.05" value="0.45" class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div class="flex flex-col items-center">
                    <label for="forestTreeDensitySlider" class="text-sm font-semibold mb-2">Forest Tree Density: <span id="forestTreeDensityValue">0.35</span></label>
                    <input type="range" id="forestTreeDensitySlider" min="0.0" max="1.0" step="0.05" value="0.35" class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div class="flex flex-col items-center">
                    <label for="grasslandTreeDensitySlider" class="text-sm font-semibold mb-2">Grassland Tree Density: <span id="grasslandTreeDensityValue">0.15</span></label>
                    <input type="range" id="grasslandTreeDensitySlider" min="0.0" max="1.0" step="0.05" value="0.15" class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
            </div>
        </div>
    </div>
    
    <!-- Crafting Menu -->
    <div id="craftingMenu" class="fixed inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center z-50 hidden p-4">
        <div class="bg-gray-800 p-6 sm:p-8 rounded-xl shadow-lg w-full max-w-md flex flex-col items-center gap-6">
            <h2 class="text-2xl sm:text-3xl font-bold text-white text-center">Crafting</h2>
            <p class="text-sm text-gray-400">Press <kbd class="px-2 py-1 text-xs font-semibold bg-gray-700 rounded-md border border-gray-600">C</kbd> to close.</p>
            <div class="w-full bg-gray-700 rounded-lg p-4">
                <div class="flex justify-between items-center">
                    <div>
                        <h3 class="text-lg font-bold">Shelter üõñ</h3>
                        <p class="text-sm text-gray-400">Stops thirst from decreasing.</p>
                        <div class="mt-2 text-sm">
                            <span>Cost: </span>
                            <span id="shelterWoodCost" class="font-mono">10 ü™µ</span>, 
                            <span id="shelterStoneCost" class="font-mono">5 ü™®</span>
                        </div>
                    </div>
                    <button id="craftShelterButton" class="px-4 py-2 bg-blue-600 rounded-lg font-semibold hover:bg-blue-700 disabled:bg-gray-600 disabled:cursor-not-allowed transition-colors">
                        Craft
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // CORE NOISE AND MATH FUNCTIONS
        function seededRandom(seed) {
            let state = Math.sin(seed) * 10000;
            return function() {
                state = (state * 9301 + 49297) % 233280;
                return state / 233280;
            };
        }

        class PerlinNoise {
            constructor(seed) {
                const random = seededRandom(seed);
                this.p = new Array(512);
                const permutation = new Array(256);
                for (let i = 0; i < 256; i++) {
                    permutation[i] = i;
                }
                for (let i = 0; i < 255; i++) {
                    const j = Math.floor(random() * (256 - i)) + i;
                    [permutation[i], permutation[j]] = [permutation[j], permutation[i]];
                }
                for (let i = 0; i < 256; i++) {
                    this.p[i] = this.p[i + 256] = permutation[i];
                }
            }
            noise(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = this.fade(x);
                const v = this.fade(y);
                const A = this.p[X] + Y;
                const AA = this.p[A];
                const AB = this.p[A + 1];
                const B = this.p[X + 1] + Y;
                const BA = this.p[B];
                const BB = this.p[B + 1];
                const result = this.lerp(v, this.lerp(u, this.grad(this.p[AA], x, y), this.grad(this.p[BA], x - 1, y)),
                                         this.lerp(u, this.grad(this.p[AB], x, y - 1), this.grad(this.p[BB], x - 1, y - 1)));
                return (result + 1.0) / 2.0;
            }
            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }
            lerp(t, a, b) {
                return a + t * (b - a);
            }
            grad(hash, x, y) {
                const h = hash & 3;
                const u = h < 2 ? x : y;
                const v = h < 2 ? y : x;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }
        }
        
        // BIOME AND COLOR LOGIC
        const BIOME_COLORS = {
            'deepWater': [20, 91, 134],
            'shallowWater': [38, 166, 245],
            'frozenDeepWater': [20, 123, 174],
            'frozenShallowWater': [37, 174, 255],
            'beach': [255, 216, 122],
            'snowyBeach': [250, 240, 191],
            'desert': [250, 148, 24],
            'desertHills': [210, 95, 17],
            'badlands': [217, 69, 21],
            'badlandsPlateau': [202, 140, 101],
            'badlandsHills': [120, 25, 25],
            'taiga': [10, 102, 89],
            'taigaHills': [22, 57, 51],
            'taigaMountains': [51, 142, 129],
            'snowyTaiga': [49, 85, 74],
            'snowyTaigaHills': [36, 63, 54],
            'snowyTaigaMountains': [89, 125, 114],
            'savanna': [189, 178, 95],
            'savannaPlateau': [167, 157, 100],
            'jungle': [83, 123, 9],
            'jungleHills': [44, 66, 4],
            'swamp': [48, 53, 40],
            'swampHills': [31, 36, 24],
            'plain': [141, 179, 96],
            'forest': [5, 102, 33],
            'forestHills': [0, 66, 44],
            'forestMountains': [0, 48, 31],
            'mountain': [96, 96, 96],
            'snowyTundra': [255, 255, 255],
            'snowyMountains': [160, 160, 160],
            'iceSpikes': [180, 220, 220],
            'river': [37, 174, 255]
        };

        function getBiomeAtWorldCoords(worldX, worldY, perlinHeight, perlinMoisture, perlinTemperature, perlinRiver, sliders) {
            const { heightScale, moistureScale, octaves, persistence, waterLevel } = sliders;
            
            const heightValue = getHeightValueAtWorldCoords(worldX, worldY, perlinHeight, heightScale, octaves, persistence);
            
            let totalMoisture = 0;
            let totalTemperature = 0;
            let amplitude = 1;
            let frequency = 1;
            let maxAmplitude = 0;
            
            for (let i = 0; i < octaves; i++) {
                totalMoisture += perlinMoisture.noise(worldX / moistureScale * frequency, worldY / moistureScale * frequency) * amplitude;
                totalTemperature += perlinTemperature.noise(worldX / 150 * frequency, worldY / 150 * frequency) * amplitude;
                maxAmplitude += amplitude;
                amplitude *= persistence;
                frequency *= 2;
            }
            const moistureValue = totalMoisture / maxAmplitude;
            const temperatureValue = totalTemperature / maxAmplitude;
            
            const riverValue = 1 - Math.abs(perlinRiver.noise(worldX / 100, worldY / 100));

            const normalizedHeight = heightValue * 255;
            const normalizedMoisture = moistureValue * 255;
            const normalizedTemperature = temperatureValue * 255;
            
            if (normalizedHeight < 125 && riverValue > 0.8) {
                return 'river';
            }

            if (normalizedHeight > 150) return 'deepWater';
            if (normalizedHeight > 125) {
                if (normalizedTemperature <= 25) return 'frozenShallowWater';
                return 'shallowWater';
            }

            if (normalizedHeight > 115 && normalizedHeight <= 125) {
                if (normalizedTemperature <= 25) return 'snowyBeach';
                return 'beach';
            }

            if (normalizedTemperature <= 25 && normalizedMoisture > 75) return 'iceSpikes';
            if (normalizedTemperature <= 25 && normalizedMoisture <= 50) return 'snowyTundra';
            if ((normalizedTemperature > 25 && normalizedTemperature <= 50 && normalizedMoisture > 25 && normalizedMoisture <= 75) || (normalizedTemperature <= 25 && normalizedMoisture > 50 && normalizedMoisture <= 75)) {
                if (normalizedTemperature < 25) {
                     if (normalizedHeight <= 50) return 'snowyTaigaMountains';
                     if (normalizedHeight <= 70) return 'snowyTaigaHills';
                     return 'snowyTaiga';
                } else {
                     if (normalizedHeight <= 50) return 'taigaMountains';
                     if (normalizedHeight <= 70) return 'taigaHills';
                     return 'taiga';
                }
            }
            if (normalizedTemperature > 66 && normalizedMoisture <= 25) {
                 if (normalizedHeight <= 50) return 'desertHills';
                 return 'desert';
            }
            if (normalizedTemperature > 25 && normalizedTemperature <= 66 && normalizedMoisture <= 25) {
                 if (normalizedHeight <= 50) return 'badlandsHills';
                 return 'badlands';
            }
            if ((normalizedTemperature > 66 && normalizedMoisture > 75) || (normalizedMoisture > 50 && normalizedTemperature > 50 && normalizedTemperature <= 66)) {
                 if (normalizedHeight <= 50) return 'jungleHills';
                 return 'jungle';
            }
            if (normalizedTemperature > 66 && normalizedMoisture <= 75 && normalizedMoisture > 50) {
                 if (normalizedHeight <= 30) return 'forestMountains';
                 if (normalizedHeight <= 50) return 'forestHills';
                 return 'forest';
            }
            if (normalizedTemperature > 75 && normalizedMoisture <= 50 && normalizedMoisture > 25) {
                 if (normalizedHeight <= 30) return 'savannaPlateau';
                 return 'savanna';
            }
            if (normalizedTemperature > 50 && normalizedTemperature <= 75 && normalizedMoisture > 25 && normalizedMoisture <= 50) {
                 if (normalizedHeight <= 50) return 'mountain';
                 if (normalizedHeight > 115 && normalizedHeight <= 125) return 'beach';
                 return 'plain';
            }

            return 'swamp';
        }

        function getHeightValueAtWorldCoords(worldX, worldY, perlinHeight, heightScale, octaves, persistence) {
            let totalHeight = 0;
            let amplitude = 1;
            let frequency = 1;
            let maxAmplitude = 0;
            for (let i = 0; i < octaves; i++) {
                totalHeight += perlinHeight.noise(worldX / heightScale * frequency, worldY / heightScale * frequency) * amplitude;
                maxAmplitude += amplitude;
                amplitude *= persistence;
                frequency *= 2;
            }
            return totalHeight / maxAmplitude;
        }

        function getMovementSpeedModifier(biome) {
            switch (biome) {
                case 'deepWater':
                case 'frozenDeepWater':
                case 'river':
                case 'jungle':
                case 'jungleHills':
                case 'swamp':
                case 'swampHills':
                    return 0.5;
                case 'ocean':
                case 'frozenShallowWater':
                case 'taiga':
                case 'taigaHills':
                case 'snowyTaiga':
                case 'snowyTaigaHills':
                    return 0.7;
                case 'beach':
                case 'snowyBeach':
                case 'savanna':
                case 'savannaPlateau':
                    return 0.9;
                case 'snowyTundra':
                case 'iceSpikes':
                case 'snowyMountains':
                case 'taigaMountains':
                case 'snowyTaigaMountains':
                case 'mountain':
                case 'forestMountains':
                    return 0.4;
                default:
                    return 1.0;
            }
        }
        
        function getPixelLightness(x, y, heightValue, perlinHeight, sliders) {
            const { sunAngle, heightScale, octaves, persistence } = sliders;
            const sunAngleRad = sunAngle * (Math.PI / 180);
            const lightVector = [Math.cos(sunAngleRad), Math.sin(sunAngleRad)];
            
            const normalVector = [
                (getHeightValueAtWorldCoords(x + 1, y, perlinHeight, heightScale, octaves, persistence) - heightValue) * 100,
                (getHeightValueAtWorldCoords(x, y + 1, perlinHeight, heightScale, octaves, persistence) - heightValue) * 100,
            ];
            const normalMagnitude = Math.sqrt(normalVector[0] * normalVector[0] + normalVector[1] * normalVector[1]);
            if (normalMagnitude > 0) {
                normalVector[0] /= normalMagnitude;
                normalVector[1] /= normalMagnitude;
            }

            const dotProduct = normalVector[0] * lightVector[0] + normalVector[1] * lightVector[1];
            return 1.0 + dotProduct * 0.4;
        }

        function getTreeThreshold(biome, sliders) {
             const { forestTreeDensity, grasslandTreeDensity } = sliders;
             switch (biome) {
                 case 'forest':
                 case 'forestHills':
                 case 'rainforest':
                 case 'jungle':
                 case 'jungleHills':
                 case 'taiga':
                 case 'taigaHills':
                 case 'snowyTaiga':
                 case 'snowyTaigaHills':
                     return forestTreeDensity;
                 case 'grassland':
                 case 'savanna':
                 case 'savannaPlateau':
                 case 'plain':
                     return grasslandTreeDensity;
                 default:
                     return 0;
             }
        }

        // WORLD GENERATION & DRAWING
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        const MINIMAP_SIZE = 100;
        minimapCanvas.width = MINIMAP_SIZE;
        minimapCanvas.height = MINIMAP_SIZE;

        const CHUNK_SIZE = 32; // tiles per chunk
        const MAX_CACHE_SIZE = 250; // max number of chunks in memory
        const chunkCache = new Map();
        let lastMinimapPlayerPos = { x: null, y: null };


        function getSliderValues() {
             return {
                heightScale: parseFloat(heightScaleSlider.value),
                moistureScale: parseFloat(moistureScaleSlider.value),
                pixelScale: parseFloat(pixelScaleSlider.value),
                octaves: parseInt(octavesSlider.value),
                persistence: parseFloat(persistenceSlider.value),
                playerSpeed: parseFloat(playerSpeedSlider.value),
                sunAngle: parseFloat(sunAngleSlider.value),
                waterLevel: parseFloat(waterLevelSlider.value),
                forestTreeDensity: parseFloat(forestTreeDensitySlider.value),
                grasslandTreeDensity: parseFloat(grasslandTreeDensitySlider.value)
            };
        }

        function manageCache() {
            if (chunkCache.size <= MAX_CACHE_SIZE) return;

            const playerChunkX = Math.floor(player.x / CHUNK_SIZE);
            const playerChunkY = Math.floor(player.y / CHUNK_SIZE);

            let farthestKey = null;
            let maxDistSq = -1;

            for (const key of chunkCache.keys()) {
                const [cx, cy] = key.split(',').map(Number);
                const distSq = (cx - playerChunkX) ** 2 + (cy - playerChunkY) ** 2;
                if (distSq > maxDistSq) {
                    maxDistSq = distSq;
                    farthestKey = key;
                }
            }

            if (farthestKey) {
                chunkCache.delete(farthestKey);
            }
        }


        function generatePerlinMaps() {
            const seed = parseInt(seedInput.value) || 0;
            perlinHeight = new PerlinNoise(seed);
            perlinMoisture = new PerlinNoise(seed + 1);
            perlinObject = new PerlinNoise(seed + 2);
            perlinTemperature = new PerlinNoise(seed + 3);
            perlinRiver = new PerlinNoise(seed + 4);
        }

        function generateChunkData(chunkX, chunkY, sliders) {
            const chunkCanvas = document.createElement('canvas');
            chunkCanvas.width = CHUNK_SIZE;
            chunkCanvas.height = CHUNK_SIZE;
            const chunkCtx = chunkCanvas.getContext('2d');
            const chunkImageData = chunkCtx.createImageData(CHUNK_SIZE, CHUNK_SIZE);
            const data = chunkImageData.data;
            const objects = [];

            for (let y = 0; y < CHUNK_SIZE; y++) {
                for (let x = 0; x < CHUNK_SIZE; x++) {
                    const worldX = chunkX * CHUNK_SIZE + x;
                    const worldY = chunkY * CHUNK_SIZE + y;
                    
                    const biome = getBiomeAtWorldCoords(worldX, worldY, perlinHeight, perlinMoisture, perlinTemperature, perlinRiver, sliders);
                    const baseColor = BIOME_COLORS[biome] || [0,0,0];
                    const heightValue = getHeightValueAtWorldCoords(worldX, worldY, perlinHeight, sliders.heightScale, sliders.octaves, sliders.persistence);
                    const lightness = getPixelLightness(worldX, worldY, heightValue, perlinHeight, sliders);
                    
                    const r = Math.min(255, Math.max(0, baseColor[0] * lightness));
                    const g = Math.min(255, Math.max(0, baseColor[1] * lightness));
                    const b = Math.min(255, Math.max(0, baseColor[2] * lightness));

                    const idx = (y * CHUNK_SIZE + x) * 4;
                    data[idx] = r;
                    data[idx + 1] = g;
                    data[idx + 2] = b;
                    data[idx + 3] = 255;
                    
                    const objectValue = perlinObject.noise(worldX, worldY);
                    const treeThreshold = getTreeThreshold(biome, sliders);
                    if (objectValue > (1.0 - treeThreshold) && !biome.includes('Water') && biome !== 'river') {
                        objects.push({ x: worldX, y: worldY, emoji: 'üå≥', color: 'green' });
                    }
                }
            }
            chunkCtx.putImageData(chunkImageData, 0, 0);

            const key = `${chunkX},${chunkY}`;
            chunkCache.set(key, { canvas: chunkCanvas, objects: objects });
            manageCache();
        }

        function drawWorld() {
            if (isGenerating || !perlinHeight) return;

            const pixelScale = parseInt(pixelScaleSlider.value);
            const viewportWidth = viewport.clientWidth;
            const viewportHeight = viewport.clientHeight;
            
            canvas.width = viewportWidth;
            canvas.height = viewportHeight;
            ctx.clearRect(0, 0, viewportWidth, viewportHeight);
            ctx.imageSmoothingEnabled = false;

            const viewTilesX = viewportWidth / pixelScale;
            const viewTilesY = viewportHeight / pixelScale;
            const startTileX = player.x - viewTilesX / 2;
            const endTileX = player.x + viewTilesX / 2;
            const startTileY = player.y - viewTilesY / 2;
            const endTileY = player.y + viewTilesY / 2;

            const startChunkX = Math.floor(startTileX / CHUNK_SIZE);
            const endChunkX = Math.ceil(endTileX / CHUNK_SIZE);
            const startChunkY = Math.floor(startTileY / CHUNK_SIZE);
            const endChunkY = Math.ceil(endTileY / CHUNK_SIZE);

            const sliders = getSliderValues();

            for (let cy = startChunkY; cy < endChunkY; cy++) {
                for (let cx = startChunkX; cx < endChunkX; cx++) {
                    const key = `${cx},${cy}`;
                    if (!chunkCache.has(key)) {
                        generateChunkData(cx, cy, sliders);
                    }
                    const chunk = chunkCache.get(key);
                    if(!chunk) continue;

                    const screenX = (cx * CHUNK_SIZE - startTileX) * pixelScale;
                    const screenY = (cy * CHUNK_SIZE - startTileY) * pixelScale;
                    
                    ctx.drawImage(chunk.canvas, screenX, screenY, CHUNK_SIZE * pixelScale, CHUNK_SIZE * pixelScale);
                    
                    ctx.font = `${pixelScale}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    for (const obj of chunk.objects) {
                         const objScreenX = (obj.x - startTileX) * pixelScale;
                         const objScreenY = (obj.y - startTileY) * pixelScale;
                         ctx.fillStyle = obj.color;
                         ctx.fillText(obj.emoji, objScreenX + pixelScale / 2, objScreenY + pixelScale / 2);
                    }
                }
            }
            
            playerDiv.style.left = `${viewportWidth / 2}px`;
            playerDiv.style.top = `${viewportHeight / 2}px`;
        }
        
        function drawMinimap() {
            const roundedPlayerX = Math.round(player.x);
            const roundedPlayerY = Math.round(player.y);

            if (lastMinimapPlayerPos.x === roundedPlayerX && lastMinimapPlayerPos.y === roundedPlayerY) {
                return; // No need to redraw if player hasn't moved to a new tile
            }
            lastMinimapPlayerPos.x = roundedPlayerX;
            lastMinimapPlayerPos.y = roundedPlayerY;

            minimapCtx.clearRect(0, 0, MINIMAP_SIZE, MINIMAP_SIZE);
            minimapCtx.imageSmoothingEnabled = false;

            const minimapScale = 2;

            const startX = roundedPlayerX - Math.floor((MINIMAP_SIZE / minimapScale) / 2);
            const startY = roundedPlayerY - Math.floor((MINIMAP_SIZE / minimapScale) / 2);

            const sliders = {
                heightScale: parseFloat(heightScaleSlider.value),
                moistureScale: parseFloat(moistureScaleSlider.value),
                octaves: parseInt(octavesSlider.value),
                persistence: parseFloat(persistenceSlider.value),
                waterLevel: parseFloat(waterLevelSlider.value)
            };

            for (let y = 0; y < MINIMAP_SIZE; y++) {
                for (let x = 0; x < MINIMAP_SIZE; x++) {
                    const worldX = startX + x / minimapScale;
                    const worldY = startY + y / minimapScale;
                    const biome = getBiomeAtWorldCoords(worldX, worldY, perlinHeight, perlinMoisture, perlinTemperature, perlinRiver, sliders);
                    const color = BIOME_COLORS[biome] || [0,0,0];
                    minimapCtx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                    minimapCtx.fillRect(x, y, 1, 1);
                }
            }
        }


        // GAME STATE, HUD, AND LOOP
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const viewport = document.getElementById('game-viewport');
        const loadingSpinner = document.getElementById('loading');
        
        const seedInput = document.getElementById('seedInput');
        const heightScaleSlider = document.getElementById('heightScaleSlider');
        const moistureScaleSlider = document.getElementById('moistureScaleSlider');
        const pixelScaleSlider = document.getElementById('pixelScaleSlider');
        const octavesSlider = document.getElementById('octavesSlider');
        const persistenceSlider = document.getElementById('persistenceSlider');
        const playerSpeedSlider = document.getElementById('playerSpeedSlider');
        const sunAngleSlider = document.getElementById('sunAngleSlider');
        const waterLevelSlider = document.getElementById('waterLevelSlider');
        const pauseMenu = document.getElementById('pauseMenu');
        const craftingMenu = document.getElementById('craftingMenu');
        
        const heightScaleValueSpan = document.getElementById('heightScaleValue');
        const moistureScaleValueSpan = document.getElementById('moistureScaleValue');
        const pixelScaleValueSpan = document.getElementById('pixelScaleValue');
        const octavesValueSpan = document.getElementById('octavesValue');
        const persistenceValueSpan = document.getElementById('persistenceValue');
        const playerSpeedValueSpan = document.getElementById('playerSpeedValue');
        const sunAngleValueSpan = document.getElementById('sunAngleValue');
        const waterLevelValueSpan = document.getElementById('waterLevelValue');
        const forestTreeDensitySlider = document.getElementById('forestTreeDensitySlider');
        const grasslandTreeDensitySlider = document.getElementById('grasslandTreeDensitySlider');
        const forestTreeDensityValueSpan = document.getElementById('forestTreeDensityValue');
        const grasslandTreeDensityValueSpan = document.getElementById('grasslandTreeDensityValue');

        const thirstFill = document.getElementById('thirstFill');
        const thirstText = document.getElementById('thirstText');
        const woodCountSpan = document.getElementById('woodCount');
        const stoneCountSpan = document.getElementById('stoneCount');
        const waterCountSpan = document.getElementById('waterCount');
        const speedModifierText = document.getElementById('speedModifierText');
        const posText = document.getElementById('posText');
        const biomeText = document.getElementById('biomeText');
        const shelterStatus = document.getElementById('shelterStatus');
        const keysText = document.getElementById('keysText');

        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');

        const messages = [];
        const playerDiv = document.getElementById('player');
        const playerEmojiSpan = document.getElementById('player-emoji');
        
        const currentFpsText = document.getElementById('currentFps');
        const minFpsText = document.getElementById('minFps');
        const maxFpsText = document.getElementById('maxFps');
        const fpsGraphCanvas = document.getElementById('fpsGraph');
        const fpsGraphCtx = fpsGraphCanvas.getContext('2d');
        const fpsOverlay = document.getElementById('fpsOverlay');

        const craftShelterButton = document.getElementById('craftShelterButton');
        const shelterWoodCostSpan = document.getElementById('shelterWoodCost');
        const shelterStoneCostSpan = document.getElementById('shelterStoneCost');

        const SHELTER_COST_WOOD = 10;
        const SHELTER_COST_STONE = 5;

        let perlinHeight, perlinMoisture, perlinObject, perlinTemperature, perlinRiver;
        let isGenerating = false;
        let isGamePaused = false;
        let keys = {};

        let player = {
            x: 0,
            y: 0,
            thirst: 100,
            hasShelter: false,
            resources: {
                wood: 0,
                stone: 0,
                water: 0
            }
        };
        let thirstRate = 0.5; // Increased thirst rate for more challenge

        let lastFrameTime = 0;
        let fpsUpdateInterval = 100; // in milliseconds
        let lastFpsUpdateTime = 0;
        const fpsHistory = [];
        const maxFpsHistory = 60;
        let minFps = Infinity;
        let maxFps = 0;

        function showLoading() {
            loadingSpinner.classList.remove('hidden');
            isGenerating = true;
        }

        function hideLoading() {
            loadingSpinner.classList.add('hidden');
            isGenerating = false;
        }

        function showMessage(msg) {
            messages.push(msg);
            if (messages.length === 1) {
                displayNextMessage();
            }
        }
        
        function displayNextMessage() {
            if (messages.length === 0) return;

            const msg = messages[0];
            messageText.textContent = msg;
            messageText.classList.remove('hidden');
            messageText.classList.add('bubble-effect');
            
            setTimeout(() => {
                messageText.classList.remove('bubble-effect');
                setTimeout(() => {
                    messageText.classList.add('hidden');
                    messages.shift();
                    displayNextMessage();
                }, 2000); 
            }, 500);
        }

        function updateHUD(currentBiome) {
            thirstFill.style.width = `${player.thirst}%`;
            thirstText.textContent = `${Math.floor(player.thirst)}%`;
            woodCountSpan.textContent = player.resources.wood;
            stoneCountSpan.textContent = player.resources.stone;
            waterCountSpan.textContent = player.resources.water;
            
            speedModifierText.textContent = `${getMovementSpeedModifier(currentBiome)}x`;
            posText.textContent = `${Math.round(player.x)}, ${Math.round(player.y)}`;
            biomeText.textContent = currentBiome;

            if (player.hasShelter) {
                shelterStatus.textContent = 'Yes';
                shelterStatus.classList.remove('text-red-400');
                shelterStatus.classList.add('text-green-400');
            } else {
                shelterStatus.textContent = 'No';
                shelterStatus.classList.add('text-red-400');
                shelterStatus.classList.remove('text-green-400');
            }
            
            let pressedKeys = Object.keys(keys).filter(k => keys[k]).map(k => k.toUpperCase());
            keysText.textContent = pressedKeys.join(', ') || '...';
        }

        function updateCraftingMenu() {
            if (player.hasShelter) {
                craftShelterButton.disabled = true;
                craftShelterButton.textContent = 'Built';
            } else {
                const canCraft = player.resources.wood >= SHELTER_COST_WOOD && player.resources.stone >= SHELTER_COST_STONE;
                craftShelterButton.disabled = !canCraft;
                craftShelterButton.textContent = 'Craft';
            }

            shelterWoodCostSpan.textContent = `${SHELTER_COST_WOOD} ü™µ`;
            shelterStoneCostSpan.textContent = `${SHELTER_COST_STONE} ü™®`;
            
            shelterWoodCostSpan.classList.toggle('text-green-400', player.resources.wood >= SHELTER_COST_WOOD);
            shelterWoodCostSpan.classList.toggle('text-red-400', player.resources.wood < SHELTER_COST_WOOD);

            shelterStoneCostSpan.classList.toggle('text-green-400', player.resources.stone >= SHELTER_COST_STONE);
            shelterStoneCostSpan.classList.toggle('text-red-400', player.resources.stone < SHELTER_COST_STONE);
        }

        function drawFPSGraph() {
            const width = fpsGraphCanvas.width;
            const height = fpsGraphCanvas.height;
            fpsGraphCtx.clearRect(0, 0, width, height);

            if (fpsHistory.length === 0) return;

            const maxFPS = Math.max(100, ...fpsHistory);
            const minFPS = Math.min(0, ...fpsHistory);
            const range = maxFPS - minFPS;
            const stepX = width / (maxFpsHistory - 1);
            
            fpsGraphCtx.beginPath();
            fpsGraphCtx.strokeStyle = '#34d399';
            fpsGraphCtx.lineWidth = 1;

            for (let i = 0; i < fpsHistory.length; i++) {
                const x = i * stepX;
                const y = height - ((fpsHistory[i] - minFPS) / range) * height;
                if (i === 0) {
                    fpsGraphCtx.moveTo(x, y);
                } else {
                    fpsGraphCtx.lineTo(x, y);
                }
            }
            fpsGraphCtx.stroke();
        }

        // GAME LOOP AND INPUT HANDLING
        function gameLoop(timestamp) {
            requestAnimationFrame(gameLoop);
            if (isGamePaused) return;

            const deltaTime = (timestamp - lastFrameTime) / 1000 || 0;
            lastFrameTime = timestamp;

            // --- FPS Counter ---
            if (timestamp - lastFpsUpdateTime > fpsUpdateInterval) {
                const fps = 1 / deltaTime;
                fpsHistory.push(fps);
                if (fpsHistory.length > maxFpsHistory) fpsHistory.shift();
                
                minFps = Infinity;
                maxFps = 0;
                fpsHistory.forEach(f => {
                    if (f < minFps) minFps = f;
                    if (f > maxFps) maxFps = f;
                });

                currentFpsText.textContent = Math.round(fps);
                minFpsText.textContent = Math.round(minFps);
                maxFpsText.textContent = Math.round(maxFps);

                drawFPSGraph();
                lastFpsUpdateTime = timestamp;
            }

            // --- Game Logic ---
            if (!player.hasShelter) {
                player.thirst -= thirstRate * deltaTime;
            }
            
            if (player.thirst <= 0) {
                player.thirst = 0;
                showMessage("Game Over! You died of thirst. Refresh to restart.");
                isGamePaused = true;
            }
            
            const playerSpeed = parseFloat(playerSpeedSlider.value);
            
            let moveX = 0;
            let moveY = 0;
            if (keys['w'] || keys['arrowup']) { moveY -= 1; }
            if (keys['s'] || keys['arrowdown']) { moveY += 1; }
            if (keys['a'] || keys['arrowleft']) { moveX -= 1; }
            if (keys['d'] || keys['arrowright']) { moveX += 1; }
            
            if (moveX !== 0 || moveY !== 0) {
                const magnitude = Math.sqrt(moveX * moveX + moveY * moveY);
                moveX /= magnitude;
                moveY /= magnitude;
            }
            
            const currentBiome = getBiomeAtWorldCoords(Math.round(player.x), Math.round(player.y), perlinHeight, perlinMoisture, perlinTemperature, perlinRiver, {
                heightScale: parseFloat(heightScaleSlider.value),
                moistureScale: parseFloat(moistureScaleSlider.value),
                octaves: parseInt(octavesSlider.value),
                persistence: parseFloat(persistenceSlider.value),
                waterLevel: parseFloat(waterLevelSlider.value)
            });
            const speedModifier = getMovementSpeedModifier(currentBiome);
            
            player.x += moveX * playerSpeed * deltaTime * 10 * speedModifier;
            player.y += moveY * playerSpeed * deltaTime * 10 * speedModifier;

            if (currentBiome.includes('Water') || currentBiome === 'river') {
                playerEmojiSpan.textContent = 'üèä';
            } else {
                playerEmojiSpan.textContent = 'üö∂';
            }

            if (moveX > 0) playerEmojiSpan.style.transform = 'scaleX(-1)';
            else if (moveX < 0) playerEmojiSpan.style.transform = 'scaleX(1)';
            
            // --- Drawing ---
            drawWorld();
            drawMinimap();
            updateHUD(currentBiome);
        }
        
        // EVENT HANDLERS
        function handleGenerate() {
            showLoading();
            setTimeout(() => { // Allow UI to update before blocking
                chunkCache.clear();
                generatePerlinMaps();
                drawWorld();
                drawMinimap();
                hideLoading();
                minFps = Infinity;
                maxFps = 0;
                fpsHistory.length = 0;
            }, 10);
        }
        
        function handleLoadAndResize() {
            canvas.width = viewport.clientWidth;
            canvas.height = viewport.clientHeight;
            fpsGraphCanvas.width = fpsGraphCanvas.clientWidth;
            fpsGraphCanvas.height = fpsGraphCanvas.clientHeight;
            
            if (!isGenerating && perlinHeight) {
                drawWorld();
                drawMinimap();
            }
        }

        window.addEventListener('resize', handleLoadAndResize);
        
        ['input', 'change'].forEach(evt => {
            seedInput.addEventListener(evt, handleGenerate);
            heightScaleSlider.addEventListener(evt, () => {
                heightScaleValueSpan.textContent = heightScaleSlider.value;
                handleGenerate();
            });
            moistureScaleSlider.addEventListener(evt, () => {
                moistureScaleValueSpan.textContent = moistureScaleSlider.value;
                handleGenerate();
            });
            octavesSlider.addEventListener(evt, () => {
                octavesValueSpan.textContent = octavesSlider.value;
                handleGenerate();
            });
            persistenceSlider.addEventListener(evt, () => {
                persistenceValueSpan.textContent = persistenceSlider.value;
                handleGenerate();
            });
            waterLevelSlider.addEventListener(evt, () => {
                waterLevelValueSpan.textContent = waterLevelSlider.value;
                handleGenerate();
            });
        });

        pixelScaleSlider.addEventListener('input', () => {
            pixelScaleValueSpan.textContent = pixelScaleSlider.value;
            if (!isGenerating) drawWorld();
        });
        playerSpeedSlider.addEventListener('input', () => {
            playerSpeedValueSpan.textContent = playerSpeedSlider.value;
        });
        sunAngleSlider.addEventListener('input', () => {
            sunAngleValueSpan.textContent = sunAngleSlider.value;
            if (!isGenerating) {
                chunkCache.clear();
                drawWorld();
            }
        });
        forestTreeDensitySlider.addEventListener('input', () => {
            forestTreeDensityValueSpan.textContent = forestTreeDensitySlider.value;
            if (!isGenerating) {
                chunkCache.clear();
                drawWorld();
            }
        });
        grasslandTreeDensitySlider.addEventListener('input', () => {
            grasslandTreeDensityValueSpan.textContent = grasslandTreeDensitySlider.value;
            if (!isGenerating) {
                chunkCache.clear();
                drawWorld();
            }
        });

        
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            let newPixelScale = parseInt(pixelScaleSlider.value) - Math.sign(e.deltaY);
            if (newPixelScale < 1) newPixelScale = 1;
            if (newPixelScale > 24) newPixelScale = 24;
            pixelScaleSlider.value = newPixelScale;
            pixelScaleValueSpan.textContent = newPixelScale;
            if (!isGenerating) drawWorld();
        });

        function togglePause(forceState) {
            isGamePaused = forceState !== undefined ? forceState : !isGamePaused;
            const anyMenuOpen = !pauseMenu.classList.contains('hidden') || !craftingMenu.classList.contains('hidden');
            isGamePaused = anyMenuOpen;
            document.body.style.cursor = isGamePaused ? 'default' : `url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='40' height='48' viewport='0 0 100 100' style='font-size:24px;'><text y='50%'>‚õèÔ∏è</text></svg>") 16 24, auto`;
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === "Escape") {
                craftingMenu.classList.add('hidden');
                pauseMenu.classList.toggle('hidden');
                togglePause();
            } else if (e.key === 'c' || e.key === 'C') {
                pauseMenu.classList.add('hidden');
                craftingMenu.classList.toggle('hidden');
                if (!craftingMenu.classList.contains('hidden')) {
                    updateCraftingMenu();
                }
                togglePause();
            } else if (e.key === '`' || e.key === '~') {
                fpsOverlay.classList.toggle('hidden');
            }
            keys[e.key.toLowerCase()] = true;
        });
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        canvas.addEventListener('click', (e) => {
            if (isGenerating || isGamePaused || player.thirst <= 0 || !perlinHeight) return;

            const pixelScale = parseInt(pixelScaleSlider.value);
            const rect = canvas.getBoundingClientRect();
            const viewX = Math.floor(e.clientX - rect.left);
            const viewY = Math.floor(e.clientY - rect.top);
            const viewTilesX = viewport.clientWidth / pixelScale;
            const viewTilesY = viewport.clientHeight / pixelScale;
            const startTileX = player.x - viewTilesX / 2;
            const startTileY = player.y - viewTilesY / 2;
            const worldX = Math.floor(startTileX + viewX / pixelScale);
            const worldY = Math.floor(startTileY + viewY / pixelScale);
            
            const biome = getBiomeAtWorldCoords(worldX, worldY, perlinHeight, perlinMoisture, perlinTemperature, perlinRiver, {
                heightScale: parseFloat(heightScaleSlider.value),
                moistureScale: parseFloat(moistureScaleSlider.value),
                octaves: parseInt(octavesSlider.value),
                persistence: parseFloat(persistenceSlider.value),
                waterLevel: parseFloat(waterLevelSlider.value)
            });
            
            const objectValue = perlinObject.noise(worldX, worldY);
            const sliders = { forestTreeDensity: parseFloat(forestTreeDensitySlider.value), grasslandTreeDensity: parseFloat(grasslandTreeDensitySlider.value) };
            const treeThreshold = getTreeThreshold(biome, sliders);

            if (objectValue > (1.0 - treeThreshold) && !biome.includes('Water') && biome !== 'river') {
                player.resources.wood += 1;
                showMessage("Gathered wood! ü™µ");
            } else if (biome.includes('Water') || biome === 'river') {
                 player.resources.water += 1;
                 player.thirst = Math.min(100, player.thirst + 10);
                 showMessage("Collected water & drank! üíß");
            } else if (biome.includes('mountain') || biome.includes('spikes') || biome === 'desertHills' || biome === 'badlandsHills') {
                player.resources.stone += 1;
                showMessage("Gathered stone! ü™®");
            } else {
                showMessage("Nothing to gather here.");
            }
            updateHUD(biome);
        });

        craftShelterButton.addEventListener('click', () => {
            if (player.hasShelter || player.resources.wood < SHELTER_COST_WOOD || player.resources.stone < SHELTER_COST_STONE) return;
            
            player.resources.wood -= SHELTER_COST_WOOD;
            player.resources.stone -= SHELTER_COST_STONE;
            player.hasShelter = true;
            
            showMessage('Shelter built! üõñ You no longer get thirsty.');
            
            craftingMenu.classList.add('hidden');
            togglePause(false);
        });

        window.onload = () => {
            generatePerlinMaps();
            handleLoadAndResize();
            gameLoop(0); 
        };

    </script>
</body>
</html>

