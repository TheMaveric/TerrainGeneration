<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Procedural World Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            cursor: crosshair;
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #1a202c;
        }

        #viewport {
            position: relative;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #canvas {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        #player {
            position: absolute;
            width: 8px;
            height: 8px;
            transform: translate(-50%, -50%);
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: transform 0.1s linear;
        }

        .pixelated {
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .bubble-effect {
            animation: bubble 0.5s ease-out;
        }

        @keyframes bubble {
            0% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.2);
                opacity: 0.8;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        #mobileControls {
            pointer-events: none;
            /* Let clicks pass through the container */
        }

        #joystick {
            pointer-events: auto;
            /* But not the controls themselves */
        }

        #timeSliderContainer {
            cursor: pointer;
        }

        #timeSliderContainer svg * {
            pointer-events: none;
            /* Allow events to be captured by the container */
        }

        /* For Webkit-based browsers (Chrome, Safari) */
        .controls::-webkit-scrollbar {
            width: 8px;
        }

        .controls::-webkit-scrollbar-track {
            background: #2d3748;
            /* bg-gray-700 */
        }

        .controls::-webkit-scrollbar-thumb {
            background: #4a5568;
            /* bg-gray-600 */
            border-radius: 4px;
        }

        /* Collapsible Panels */
        .collapsible-hud.collapsed {
            width: 48px;
            padding-top: 1rem;
            padding-bottom: 1rem;
        }

        .collapsible-hud.collapsed .controls,
        .collapsible-hud.collapsed .controls-footer {
            display: none;
        }

        .collapsible-hud.collapsed .title-bar {
            flex-direction: column-reverse;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0;
        }

        .collapsible-hud.collapsed h3 {
            writing-mode: vertical-rl;
            transform: rotate(180deg);
            margin: 0;
            padding: 0;
            line-height: 1;
        }

        .collapsible-hud.collapsed .toggle-icon {
            transform: rotate(180deg);
        }
    </style>
</head>

<body class="bg-gray-900 text-gray-200">

    <div id="viewport">
        <canvas id="canvas" class="pixelated"></canvas>
        <div id="player">
            <span id="player-emoji" class="text-lg">üö∂</span>
        </div>
        <div id="loading"
            class="absolute inset-0 flex items-center justify-center bg-gray-800 bg-opacity-75 z-50 transition-opacity duration-300 hidden">
            <svg class="animate-spin h-8 w-8 text-white" xmlns="http://www.w3.org/2000/svg" fill="none"
                viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor"
                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                </path>
            </svg>
        </div>
        <div class="absolute top-4 left-4 p-3 bg-gray-800 bg-opacity-75 rounded-lg shadow-md z-20 max-w-xs">
            <div class="flex flex-col gap-2 text-sm font-semibold">
                <div class="flex justify-between items-center text-sm font-semibold">
                    <span>‚ö° Speed:</span>
                    <span id="speedModifierText">1x</span>
                </div>
                <div class="flex flex-col mt-2">
                    <div class="flex justify-between items-center">
                        <span>üó∫Ô∏è Pos:</span>
                        <span id="posText">0, 0</span>
                    </div>
                    <div class="flex justify-between items-center">
                        <span>üå≤ Biome:</span>
                        <span id="biomeText">...</span>
                    </div>
                    <div class="flex justify-between items-center mt-1">
                        <span>‚òÄÔ∏è Time:</span>
                        <span id="timeText">...</span>
                    </div>
                    <div
                        class="flex justify-between items-center text-xs text-gray-400 pt-1 border-t border-gray-700 mt-1">
                        <span>Visible Trees:</span>
                        <span id="treeCountText">0</span>
                    </div>
                    <div class="flex justify-between items-center text-xs text-gray-400">
                        <span>Visible Fish:</span>
                        <span id="fishCountText">0</span>
                    </div>
                    <div class="flex justify-between items-center mt-1">
                        <span>‚å®Ô∏è Keys:</span>
                        <span id="keysText">...</span>
                    </div>
                    <div class="flex justify-between items-center mt-1">
                        <span>üéí Bag:</span>
                        <span id="invText" class="font-mono text-gray-300">‚Äî</span>
                    </div>

                    <div
                        class="flex justify-between items-center text-xs text-gray-400 pt-1 border-t border-gray-700 mt-1">
                        <span>FPS:</span>
                        <span id="currentFps" class="font-mono">--</span>
                    </div>
                    <div class="flex justify-between items-center text-xs text-gray-400">
                        <span>Min/Max:</span>
                        <span class="font-mono"><span id="minFps">--</span>/<span id="maxFps">--</span></span>
                    </div>
                    <div
                        class="flex justify-between items-center text-xs text-gray-400 pt-1 border-t border-gray-700 mt-1">
                        <span>'H' - Contours:</span>
                        <span id="contourStatus" class="font-semibold text-red-400">Off</span>
                    </div>
                </div>
            </div>
        </div>
        <div class="absolute top-4 right-4 p-3 bg-gray-800 bg-opacity-75 rounded-lg shadow-md z-20 max-w-xs">
            <h3 class="text-lg font-bold text-center mb-2 text-white">Fish
                Log</h3>
            <div id="fishLog" class="flex flex-col gap-1 mt-2 border-t border-gray-700 pt-2">
            </div>
        </div>
        <div id="messageBox" class="absolute top-24 right-4 flex justify-center z-40">
            <div id="messageText" class="p-3 bg-gray-700 text-white rounded-lg shadow-md hidden text-center w-auto">
            </div>
        </div>

        <div class="absolute bottom-4 left-4 z-40">
            <div class="w-48 h-48 bg-gray-800 border-2 border-gray-600 rounded-lg overflow-hidden relative">
                <canvas id="minimapCanvas" class="w-full h-full pixelated"></canvas>
                <div id="minimapPlayer" class="absolute w-2 h-2 bg-red-500 rounded-full"
                    style="left: 50%; top: 50%; transform: translate(-50%, -50%);"></div>
            </div>
        </div>

        <div id="timeSliderContainer" class="absolute bottom-4 right-4 z-40 w-32 h-32">
            <svg viewBox="0 0 100 100">
                <circle cx="50" cy="50" r="40" class="stroke-gray-700" stroke-width="8" fill="rgba(31, 41, 55, 0.7)">
                </circle>
                <path id="timeSliderProgress" class="stroke-yellow-400" stroke-width="8" fill="none"
                    stroke-linecap="round"></path>
                <text x="50" y="15" text-anchor="middle" font-size="14">üïõ</text> <text x="88" y="55"
                    text-anchor="middle" font-size="14">‚òÄÔ∏è</text> <text x="50" y="95" text-anchor="middle"
                    font-size="14">üïï</text> <text x="12" y="55" text-anchor="middle" font-size="14">üåô</text>
                <circle id="timeSliderHandle" cx="50" cy="10" r="6" class="fill-white"></circle>
            </svg>
        </div>

        <div id="settingsHud"
            class="absolute top-1/2 right-4 -translate-y-1/2 bg-gray-800 bg-opacity-90 p-4 rounded-lg shadow-lg z-40 w-64 max-h-[80vh] overflow-y-auto transition-all duration-300 collapsed collapsible-hud">
            <div class="flex items-center justify-between">
                <label for="lightingToggle" class="text-sm font-semibold text-gray-300">Lighting</label>
                <input id="lightingToggle" type="checkbox" class="w-5 h-5 accent-blue-500" checked />
            </div>

            <div class="flex justify-between items-center mb-4 title-bar">
                <h3 class="text-lg font-bold text-white transition-all duration-300">World
                    Settings</h3>
                <button id="toggleSettings" class="text-white p-1 rounded-full hover:bg-gray-700">
                    <svg class="w-6 h-6 transition-transform duration-300 toggle-icon" fill="none" stroke="currentColor"
                        viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7">
                        </path>
                    </svg>
                </button>
            </div>
            <div class="controls w-full grid grid-cols-1 gap-4 pr-2">
                <div class="flex flex-col items-center">
                    <label for="seedInput" class="text-sm font-semibold mb-2 text-gray-300">Seed</label>
                    <input type="text" id="seedInput" placeholder="Enter a number"
                        class="w-full text-center bg-gray-700 rounded-lg py-2 px-3 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500 text-white">
                </div>
                <div class="flex flex-col items-center">
                    <label for="heightScaleSlider" class="text-sm font-semibold mb-2 text-gray-300">Height
                        Scale: <span id="heightScaleValue">50</span></label>
                    <input type="range" id="heightScaleSlider" min="20" max="150" value="50"
                        class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
                </div>
                <div class="flex flex-col items-center">
                    <label for="moistureScaleSlider" class="text-sm font-semibold mb-2 text-gray-300">Moisture
                        Scale: <span id="moistureScaleValue">80</span></label>
                    <input type="range" id="moistureScaleSlider" min="20" max="150" value="80"
                        class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
                </div>
                <div class="flex flex-col items-center">
                    <label for="climateContrastSlider" class="text-sm font-semibold mb-2 text-gray-300">Climate
                        Contrast: <span id="climateContrastValue">1.5</span></label>
                    <input type="range" id="climateContrastSlider" min="1.0" max="3.0" step="0.1" value="1.5"
                        class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
                </div>
                <div class="flex flex-col items-center">
                    <label for="pixelScaleSlider" class="text-sm font-semibold mb-2 text-gray-300">Pixel
                        Scale: <span id="pixelScaleValue">12</span></label>
                    <input type="range" id="pixelScaleSlider" min="1" max="24" value="12"
                        class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
                </div>
                <div class="flex flex-col items-center">
                    <label for="persistenceSlider" class="text-sm font-semibold mb-2 text-gray-300">Persistence:
                        <span id="persistenceValue">0.5</span></label>
                    <input type="range" id="persistenceSlider" min="0.1" max="1" step="0.05" value="0.5"
                        class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
                </div>
                <div class="flex flex-col items-center">
                    <label for="playerSpeedSlider" class="text-sm font-semibold mb-2 text-gray-300">Player
                        Speed: <span id="playerSpeedValue">2</span></label>
                    <input type="range" id="playerSpeedSlider" min="0.5" max="5" step="0.5" value="2"
                        class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
                </div>
                <div class="flex flex-col items-center">
                    <label for="waterLevelSlider" class="text-sm font-semibold mb-2 text-gray-300">Water
                        Level: <span id="waterLevelValue">0.450</span></label>
                    <input type="range" id="waterLevelSlider" min="0.000" max="1.000" step="0.001" value="0.450"
                        class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">

                </div>
                <div class="flex flex-col items-center">
                    <label for="treeDensitySlider" class="text-sm font-semibold mb-2 text-gray-300">Tree
                        Density: <span id="treeDensityValue">1.0</span>x</label>
                    <input type="range" id="treeDensitySlider" min="0.2" max="2.0" step="0.1" value="1.0"
                        class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
                </div>
                <div class="flex flex-col items-center">
                    <label for="fishDensitySlider" class="text-sm font-semibold mb-2 text-gray-300">Fish
                        Density: <span id="fishDensityValue">2.2</span>x
                    </label>

                    <input type="range" id="fishDensitySlider" min="0.0" max="3.0" step="0.1" value="2.2"
                        class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">

                </div>
                <div class="flex flex-col items-center">
                    <label for="mapScaleSlider" class="text-sm font-semibold mb-2 text-gray-300">Map
                        Scale: <span id="mapScaleValue">0.10</span></label>
                    <input type="range" id="mapScaleSlider" min="0.1" max="2.0" step="0.05" value="0.1"
                        class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
                </div>
            </div>
            <p class="text-xs text-center text-gray-400 mt-4 controls-footer">Changes
                are applied live.</p>
        </div>

        <div id="legendHud"
            class="absolute bottom-56 left-4 bg-gray-800 bg-opacity-90 p-4 rounded-lg shadow-lg z-30 w-64 max-h-[40vh] overflow-y-auto transition-all duration-300 collapsed collapsible-hud">
            <div class="flex justify-between items-center mb-4 title-bar">
                <h3 class="text-lg font-bold text-white transition-all duration-300">Biome
                    Legend</h3>
                <button id="toggleLegend" class="text-white p-1 rounded-full hover:bg-gray-700">
                    <svg class="w-6 h-6 transition-transform duration-300 toggle-icon" fill="none" stroke="currentColor"
                        viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7">
                        </path>
                    </svg>
                </button>
            </div>
            <div id="legendEntries" class="controls w-full flex flex-col gap-2 pr-2 text-sm">
                <!-- Entries will be generated by JS -->
            </div>
        </div>

        <div id="mobileControls" class="fixed bottom-0 left-0 right-0 p-8 flex justify-between items-end z-40 hidden">
            <div id="joystick" class="w-32 h-32 bg-gray-500 bg-opacity-30 rounded-full relative">
                <div id="joystickHandle"
                    class="w-16 h-16 bg-gray-400 bg-opacity-50 rounded-full absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2">
                </div>
            </div>
        </div>
    </div>

    <script>
        // =================================================================================
        // CORE NOISE AND MATH FUNCTIONS
        // =================================================================================
        const TREE_TYPES = {
            'oak': { emoji: 'üå≥', biomes: ['forest', 'forestHills', 'plain'], minHeight: 1, maxHeight: 4 },
            'pine': { emoji: 'üå≤', biomes: ['taiga', 'taigaHills', 'taigaMountains', 'snowyTaiga', 'snowyTaigaHills', 'snowyTaigaMountains', 'mountain'], minHeight: 2, maxHeight: 6 },
            'jungle': { emoji: 'üå¥', biomes: ['jungle', 'jungleHills', 'beach'], minHeight: 3, maxHeight: 7 },
            'acacia': { emoji: 'üå≥', biomes: ['savanna', 'savannaPlateau'], minHeight: 2, maxHeight: 5 }, // Using oak emoji as a stand-in
            'swamp': { emoji: 'üå≥', biomes: ['swamp', 'swampHills'], minHeight: 1, maxHeight: 3 } // Using oak emoji as a stand-in
        };

        const FISH_TYPES = {
            // Common
            'cod': { emoji: 'üêü', biomes: ['deepWater', 'shallowWater'], rarity: 0.5 },
            'salmon': { emoji: 'üê†', biomes: ['river', 'lowlandRiver', 'mountainRiver', 'deltaRiver', 'shallowWater'], rarity: 0.4 },
            // Temperate
            'trout': { emoji: 'üêü', biomes: ['river', 'mountainRiver'], rarity: 0.3 },
            'mackerel': { emoji: 'üé£', biomes: ['shallowWater'], rarity: 0.2 },
            // Tropical
            'clownfish': { emoji: 'üê†', biomes: ['shallowWater', 'jungle'], rarity: 0.2 },
            'pufferfish': { emoji: 'üê°', biomes: ['jungle', 'swamp', 'shallowWater'], rarity: 0.15 },
            'piranha': { emoji: 'üêü', biomes: ['river', 'marshRiver', 'swamp'], rarity: 0.1 },
            // Cold
            'arctic char': { emoji: 'üêü', biomes: ['frozenDeepWater', 'frozenShallowWater', 'frozenRiver'], rarity: 0.4 },
            'icefish': { emoji: 'üßä', biomes: ['frozenDeepWater', 'frozenRiver'], rarity: 0.2 },
            // Swamp/Murky
            'catfish': { emoji: 'üé£', biomes: ['swamp', 'river', 'marshRiver', 'lowlandRiver', 'deltaRiver'], rarity: 0.3 },
            // Deep Ocean
            'tuna': { emoji: 'üêü', biomes: ['deepWater'], rarity: 0.2 },
            'swordfish': { emoji: 'üó°Ô∏è', biomes: ['deepWater'], rarity: 0.1 },
            'anglerfish': { emoji: 'üí°', biomes: ['deepWater'], rarity: 0.05 },
        };

        function seededRandom(seed) {
            let state = Math.sin(seed) * 10000;
            return function () {
                state = (state * 9301 + 49297) % 233280;
                return state / 233280;
            };
        }

        class PerlinNoise {
            constructor(seed) {
                const random = seededRandom(seed);
                this.p = new Array(512);
                const permutation = new Array(256);
                for (let i = 0; i < 256; i++) { permutation[i] = i; }
                for (let i = 0; i < 255; i++) {
                    const j = Math.floor(random() * (256 - i)) + i;
                    [permutation[i], permutation[j]] = [permutation[j], permutation[i]];
                }
                for (let i = 0; i < 256; i++) { this.p[i] = this.p[i + 256] = permutation[i]; }
            }
            noise(x, y) {
                const X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
                x -= Math.floor(x); y -= Math.floor(y);
                const u = this.fade(x), v = this.fade(y);
                const A = this.p[X] + Y, AA = this.p[A], AB = this.p[A + 1];
                const B = this.p[X + 1] + Y, BA = this.p[B], BB = this.p[B + 1];
                const res = this.lerp(v, this.lerp(u, this.grad(this.p[AA], x, y), this.grad(this.p[BA], x - 1, y)),
                    this.lerp(u, this.grad(this.p[AB], x, y - 1), this.grad(this.p[BB], x - 1, y - 1)));
                return (res + 1.0) / 2.0;
            }
            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(t, a, b) { return a + t * (b - a); }
            grad(hash, x, y) {
                const h = hash & 3;
                const u = h < 2 ? x : y, v = h < 2 ? y : x;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }
        }

        // =================================================================================
        // POISSON DISK SAMPLING FOR OBJECT PLACEMENT
        // =================================================================================
        const PoissonDisk = (() => {
            const GRID_CELL_SIZE = 4;
            const INV_CELL_SIZE = 1 / GRID_CELL_SIZE;
            const candidateCache = new Map();

            function getCandidate(cx, cy, perlin, sliders, seed, getRadiusFn) {
                const key = `${cx},${cy},${seed},${getRadiusFn.name},${sliders.treeDensityMultiplier},${sliders.fishDensityMultiplier}`;
                if (candidateCache.has(key)) return candidateCache.get(key);

                const cellRandom = seededRandom(cx * 9301 + cy * 49297 + seed);
                const pointX = (cx + cellRandom()) * GRID_CELL_SIZE;
                const pointY = (cy + cellRandom()) * GRID_CELL_SIZE;
                const biome = getBiomeAtWorldCoords(Math.round(pointX), Math.round(pointY), perlin, sliders);
                const radius = getRadiusFn(biome, sliders);

                const candidate = { x: pointX, y: pointY, r: radius, biome: biome };
                candidateCache.set(key, candidate);
                return candidate;
            }

            function generatePointsForChunk(chunkX, chunkY, perlin, sliders, seed, getRadiusFn, isValidBiomeFn, createObjectFn) {
                const points = [];
                const startX = chunkX * CHUNK_SIZE, startY = chunkY * CHUNK_SIZE;
                const endX = startX + CHUNK_SIZE, endY = startY + CHUNK_SIZE;

                const startCellX = Math.floor(startX * INV_CELL_SIZE), endCellX = Math.ceil(endX * INV_CELL_SIZE);
                const startCellY = Math.floor(startY * INV_CELL_SIZE), endCellY = Math.ceil(endY * INV_CELL_SIZE);

                for (let cy = startCellY; cy < endCellY; cy++) {
                    for (let cx = startCellX; cx < endCellX; cx++) {
                        const candidate = getCandidate(cx, cy, perlin, sliders, seed, getRadiusFn);

                        if (candidate.r === 0 || !isValidBiomeFn(candidate.biome) || candidate.x < startX || candidate.x >= endX || candidate.y < startY || candidate.y >= endY) continue;

                        let isValid = true;
                        const checkCellRadius = Math.ceil(candidate.r * INV_CELL_SIZE);

                        for (let j = -checkCellRadius; j <= checkCellRadius; j++) {
                            for (let i = -checkCellRadius; i <= checkCellRadius; i++) {
                                if (i === 0 && j === 0) continue;
                                const neighbor = getCandidate(cx + i, cy + j, perlin, sliders, seed, getRadiusFn);
                                if (neighbor.r === 0 || !isValidBiomeFn(neighbor.biome)) continue;

                                const distSq = (candidate.x - neighbor.x) ** 2 + (candidate.y - neighbor.y) ** 2;
                                if (distSq < neighbor.r * neighbor.r) {
                                    if (candidate.r < neighbor.r || (candidate.r === neighbor.r && (candidate.x > neighbor.x || (candidate.x === neighbor.x && candidate.y > neighbor.y)))) {
                                        isValid = false; break;
                                    }
                                }
                            }
                            if (!isValid) break;
                        }

                        if (isValid) {
                            points.push(createObjectFn(candidate));
                        }
                    }
                }
                return points;
            }

            function clearCache() { candidateCache.clear(); }

            return { generatePointsForChunk, clearCache };
        })();


        // =================================================================================
        // BIOME AND WORLD GENERATION
        // =================================================================================
        const BIOME_COLORS = {
            'deepWater': [20, 91, 134], 'shallowWater': [38, 166, 245], 'frozenDeepWater': [20, 123, 174],
            'frozenShallowWater': [37, 174, 255], 'beach': [255, 216, 122], 'snowyBeach': [250, 240, 191],
            'desert': [250, 148, 24], 'desertHills': [210, 95, 17], 'badlands': [217, 69, 21],
            'badlandsPlateau': [202, 140, 101], 'badlandsHills': [120, 25, 25], 'taiga': [10, 102, 89],
            'taigaHills': [22, 57, 51], 'taigaMountains': [51, 142, 129], 'snowyTaiga': [49, 85, 74],
            'snowyTaigaHills': [36, 63, 54], 'snowyTaigaMountains': [89, 125, 114], 'savanna': [189, 178, 95],
            'savannaPlateau': [167, 157, 100], 'jungle': [83, 123, 9], 'jungleHills': [44, 66, 4],
            'swamp': [48, 53, 40], 'swampHills': [31, 36, 24], 'plain': [141, 179, 96],
            'forest': [5, 102, 33], 'forestHills': [0, 66, 44], 'forestMountains': [0, 48, 31],
            'mountain': [96, 96, 96], 'snowyTundra': [255, 255, 255], 'snowyMountains': [160, 160, 160],
            'iceSpikes': [180, 220, 220], 'river': [37, 174, 255], 'frozenRiver': [180, 220, 255], 'marshRiver': [34, 120, 90],       // greenish, swampy
            'mountainRiver': [30, 140, 210],   // cooler blue
            'lowlandRiver': [37, 174, 255],    // keep bright
            'deltaRiver': [60, 170, 200],      // murky blue
        };
        // === Fast biome lookup tables =====================================
        const BIOME_KEYS = Object.keys(BIOME_COLORS);
        const BIOME_TO_INDEX = new Map(BIOME_KEYS.map((k, i) => [k, i]));
        const BIOME_NAME = BIOME_KEYS; // index -> name
        const BIOME_COLOR_ARRAY = BIOME_KEYS.map(k => BIOME_COLORS[k]);
        const BIOME_IS_WATERLIKE = BIOME_KEYS.map(k =>
            k.includes('Water') || /river/i.test(k) || k === 'beach' || k === 'snowyBeach'
        );
        // Foresty biomes where fireflies can appear (and we‚Äôll bias them near water)
        const FIREFLY_BIOMES = [
            'forest', 'forestHills', 'taiga', 'taigaHills', 'taigaMountains',
            'jungle', 'jungleHills', 'swamp', 'swampHills'
        ];
        const FIREFLY_BIOME_IDX = new Set(FIREFLY_BIOMES.map(n => BIOME_TO_INDEX.get(n)));
        // Distinct looks for NPC roles
        const NPC_STYLES = {
            villager: { emoji: 'üßë', ring: '#74a3b9', badge: null, scale: 1.00, glow: false, sparkle: null },
            farmer: { emoji: 'üßë‚Äçüåæ', ring: '#7dcf7b', badge: 'üåæ', scale: 1.05, glow: false, sparkle: null },
            builder: { emoji: 'üßë‚Äçüîß', ring: '#a3a3a3', badge: 'üî®', scale: 1.05, glow: false, sparkle: null },
            trader: { emoji: 'üßë‚Äçüíº', ring: '#ffd54a', badge: 'üß∫', scale: 1.22, glow: true, sparkle: 'ü™ô' }
        };



        function remapNoise(value, exponent) {
            return Math.pow(value, exponent);
        }

        function getOctaveNoise(x, y, perlin, scale, persistence, initialAmplitude = 1, mapScale = 1) {
            let total = 0, amplitude = initialAmplitude, frequency = 1, maxAmplitude = 0;
            for (let i = 0; i < 16; i++) { // Using 16 octaves to match Java code
                total += perlin.noise((x * mapScale) / scale * frequency, (y * mapScale) / scale * frequency) * amplitude;
                maxAmplitude += amplitude;
                amplitude *= persistence;
                frequency *= 2;
            }
            return total / maxAmplitude;
        }

        function getHeightValueAtWorldCoords(worldX, worldY, perlinHeight, heightScale, persistence, mapScale) {
            return getOctaveNoise(worldX, worldY, perlinHeight, heightScale, persistence, 10, mapScale);
        }

        function getBiomeFromValues(heightValue, moistureValue, temperatureValue, riverValue, sliders) {
            const { waterLevel } = sliders;
            const landHeight = (heightValue - waterLevel) / (1 - waterLevel);
            const h = heightValue < waterLevel ? (1 - (waterLevel - heightValue) / waterLevel) * 128 : 128 + landHeight * 127;
            const m = moistureValue * 255, t = temperatureValue * 255;

            // REPLACE your current river check with this block:
            if (h >= 132) {
                let riverThreshold = 0.965;          // hybrid: continuous but still branchy
                const nearSea = h < 140;
                const isMarshy = (m > 75 && t > 50);
                const isArid = (t > 66 && m <= 25) || (t > 25 && t <= 66 && m <= 25);

                // moderate deltas/marshes, not overpowering
                if (nearSea) riverThreshold -= 0.015;
                if (isMarshy) riverThreshold -= 0.007;
                if (isArid) riverThreshold += 0.017;

                if (riverValue > riverThreshold) {
                    if (t <= 25) return 'frozenRiver';
                    if (nearSea) return 'deltaRiver';
                    if (isMarshy) return 'marshRiver';
                    if (h > 200) return 'mountainRiver';
                    if (h < 150) return 'lowlandRiver';
                    return 'river';
                }
            }

            if (h < 110) return t <= 25 ? 'frozenDeepWater' : 'deepWater';
            if (h < 128) return t <= 25 ? 'frozenShallowWater' : 'shallowWater';
            if (h < 132) return t <= 25 ? 'snowyBeach' : 'beach';
            if (t <= 25 && m > 75) return 'iceSpikes';
            if (t <= 25 && m <= 50) return 'snowyTundra';
            if ((t > 25 && t <= 50 && m > 25 && m <= 75) || (t <= 25 && m > 50 && m <= 75)) {
                if (t < 25) {
                    if (h > 200) return 'snowyTaigaMountains';
                    if (h > 180) return 'snowyTaigaHills';
                    return 'snowyTaiga';
                } else {
                    if (h > 200) return 'taigaMountains';
                    if (h > 180) return 'taigaHills';
                    return 'taiga';
                }
            }
            if (t > 66 && m <= 25) return h > 180 ? 'desertHills' : 'desert';
            if (t > 25 && t <= 66 && m <= 25) return h > 180 ? 'badlandsHills' : 'badlands';
            if ((t > 66 && m > 75) || (m > 50 && t > 50 && t <= 66)) return h > 180 ? 'jungleHills' : 'jungle';
            if (t > 66 && m <= 75 && m > 50) {
                if (h > 220) return 'forestMountains';
                if (h > 180) return 'forestHills';
                return 'forest';
            }
            if (t > 75 && m <= 50 && m > 25) return h > 180 ? 'savannaPlateau' : 'savanna';
            if (t > 50 && t <= 75 && m > 25 && m <= 50) return h > 200 ? 'mountain' : 'plain';
            return 'swamp';
        }

        function getBiomeAtWorldCoords(worldX, worldY, perlin, sliders) {
            const heightValue = getHeightValueAtWorldCoords(worldX, worldY, perlin.height, sliders.heightScale, sliders.persistence, sliders.mapScale);
            let moistureValue = getOctaveNoise(worldX, worldY, perlin.moisture, sliders.moistureScale, sliders.persistence, 10, sliders.mapScale);
            let temperatureValue = getOctaveNoise(worldX, worldY, perlin.temperature, 150, sliders.persistence, 10, sliders.mapScale);

            moistureValue = remapNoise(moistureValue, sliders.climateContrast);
            temperatureValue = remapNoise(temperatureValue, sliders.climateContrast);

            // --- HYBRID RIVERS: long trunks + detailed branches + mild deltas ---
            const RIVER_TRUNK_SCALE = 95;   // 70‚Äì120 ‚Üí longer/smoother trunks when higher
            const RIVER_DETAIL_SCALE = 34;   // 26‚Äì45 ‚Üí more/less branch detail
            const RIVER_MAP_SCALE = 1.0;  // decouple from sliders.mapScale

            // Gentle domain warp so paths meander
            const WARP1_SCALE = 240, WARP2_SCALE = 520, WARP_AMPL = 12;
            const wu = getOctaveNoise(worldX, worldY, perlin.object, WARP1_SCALE, 0.5, 10, 1.0);
            const wv = getOctaveNoise(worldX, worldY, perlin.temperature, WARP2_SCALE, 0.5, 10, 1.0);
            const wx = worldX + (wu - 0.5) * WARP_AMPL;
            const wy = worldY + (wv - 0.5) * WARP_AMPL;

            // Long ‚Äútrunk‚Äù field (ridged)
            const trunkRaw = getOctaveNoise(wx, wy, perlin.river, RIVER_TRUNK_SCALE, sliders.persistence, 10, RIVER_MAP_SCALE);
            const trunkRidged = 1 - Math.abs(trunkRaw * 2 - 1);

            // Higher-frequency detail (ridged) to spawn tributaries/branches
            const detailRaw = getOctaveNoise(wx, wy, perlin.river, RIVER_DETAIL_SCALE, 0.55, 10, RIVER_MAP_SCALE);
            const detailRidged = 1 - Math.abs(detailRaw * 2 - 1);

            // A de-correlated helper for branches so they don‚Äôt mirror trunks
            const tribRaw = getOctaveNoise(wx, wy, perlin.object, 42, 0.5, 10, 1.0);
            const tribRidged = 1 - Math.abs(tribRaw * 2 - 1);

            // Blend: keep continuous trunks, add fine branches (moisture helps branches)
            const branchWeight = 0.55; // 0 ‚Üí trunks only, 1 ‚Üí lots of branches
            const branchField = (detailRidged * 0.6 + tribRidged * 0.4) * (0.55 + 0.45 * moistureValue);
            let riverSignal = Math.max(trunkRidged, trunkRidged * 0.5 + branchField * branchWeight);

            // Lightweight continuity bridge so near-misses connect (sample 4-neighbors on trunk)
            const n1 = getOctaveNoise(wx + 1, wy, perlin.river, RIVER_TRUNK_SCALE, sliders.persistence, 10, RIVER_MAP_SCALE);
            const n2 = getOctaveNoise(wx - 1, wy, perlin.river, RIVER_TRUNK_SCALE, sliders.persistence, 10, RIVER_MAP_SCALE);
            const n3 = getOctaveNoise(wx, wy + 1, perlin.river, RIVER_TRUNK_SCALE, sliders.persistence, 10, RIVER_MAP_SCALE);
            const n4 = getOctaveNoise(wx, wy - 1, perlin.river, RIVER_TRUNK_SCALE, sliders.persistence, 10, RIVER_MAP_SCALE);
            const neighTrunk = Math.max(
                1 - Math.abs(n1 * 2 - 1),
                1 - Math.abs(n2 * 2 - 1),
                1 - Math.abs(n3 * 2 - 1),
                1 - Math.abs(n4 * 2 - 1)
            );
            riverSignal = Math.max(riverSignal, neighTrunk * 0.985);

            // Gentle valley & moisture bias (keeps trunks crossing the map, but favors low/wet)
            const landV = Math.max(0, Math.min(1, (heightValue - sliders.waterLevel) / (1 - sliders.waterLevel)));
            const valleyBoost = 0.80 + 0.30 * (1 - landV);                 // prefer lower land
            const moistureBoost = 0.88 + 0.28 * remapNoise(moistureValue, 1.1); // prefer wetter climates

            // Compute absolute 'h' like in getBiomeFromValues to spot near-sea for deltas
            const landHeight = (heightValue - sliders.waterLevel) / (1 - sliders.waterLevel);
            const h = (heightValue < sliders.waterLevel)
                ? (1 - (sliders.waterLevel - heightValue) / sliders.waterLevel) * 128
                : 128 + landHeight * 127;
            const nearSea = (h >= 132 && h < 140);

            // Mild widening near sea ‚Üí deltas without overwhelming trunks
            const deltaWiden = nearSea ? 1.05 : 1.0;

            // Final river field (clamped)
            const riverValue = Math.max(0, Math.min(1, riverSignal * valleyBoost * moistureBoost * deltaWiden));


            return getBiomeFromValues(heightValue, moistureValue, temperatureValue, riverValue, sliders);
        }

        function getAbsoluteHeight(worldX, worldY, perlin, sliders, cache) {
            const key = `${worldX},${worldY}`;
            if (cache && cache.has(key)) return cache.get(key);

            const { waterLevel } = sliders;
            const heightValue = getHeightValueAtWorldCoords(worldX, worldY, perlin.height, sliders.heightScale, sliders.persistence, sliders.mapScale);
            const landHeight = (heightValue - waterLevel) / (1 - waterLevel);
            const h = heightValue < waterLevel ? (1 - (waterLevel - heightValue) / waterLevel) * 128 : 128 + landHeight * 127;

            if (cache) cache.set(key, h);
            return h;
        }

        function getMovementSpeedModifier(biome) {
            switch (biome) {
                case 'deepWater': case 'frozenDeepWater': return 0.4;
                case 'shallowWater': case 'frozenShallowWater': return 0.6;
                case 'jungle': case 'jungleHills': case 'swamp': case 'swampHills': return 0.7;
                case 'snowyMountains': case 'taigaMountains': case 'snowyTaigaMountains': case 'mountain': case 'forestMountains': return 0.5;
                // rivers now set per-pixel in draw using a dynamic override; keep a safe default:
                case 'frozenRiver': return 0.3;
                case 'marshRiver': return 0.35;
                case 'mountainRiver': return 0.45;
                case 'lowlandRiver': return 0.4;
                case 'deltaRiver': return 0.4;
                default: return 1.0;
            }
        }


        function getPixelLightness(x, y, heightValue, perlinHeight, sliders, sunVector) {
            const { heightScale, persistence, mapScale } = sliders;
            const h_x1 = getHeightValueAtWorldCoords(x + 1, y, perlinHeight, heightScale, persistence, mapScale);
            const h_y1 = getHeightValueAtWorldCoords(x, y + 1, perlinHeight, heightScale, persistence, mapScale);
            const normalX = ((heightValue - h_x1) * 20) / mapScale;
            const normalY = ((heightValue - h_y1) * 20) / mapScale;
            const dotProduct = normalX * sunVector[0] + normalY * sunVector[1];
            const lighting = 1.0 + dotProduct * 0.5;
            return Math.max(0.6, Math.min(1.4, lighting));
        }

        function getTreePlacementRadius(biome, sliders) {
            const multiplier = sliders.treeDensityMultiplier || 1;
            let baseRadius = 0;
            switch (biome) {
                case 'forest': case 'jungle': case 'taiga': baseRadius = 4; break;
                case 'forestHills': case 'jungleHills': case 'taigaHills': baseRadius = 5; break;
                case 'swamp': baseRadius = 7; break;
                case 'plain': baseRadius = 9; break;
                case 'savanna': baseRadius = 12; break;
                default: return 0; // No trees in other biomes
            }
            return Math.max(1, baseRadius / multiplier);
        }

        function getFishPlacementRadius(biome, sliders) {
            const multiplier = sliders.fishDensityMultiplier || 1;
            if (multiplier === 0) return 0;
            if (biome.includes('Water') || /river/i.test(biome)) {
                let base = Math.max(2, 10 / multiplier);
                if (/deltaRiver|marshRiver/i.test(biome)) base = Math.max(2, 8 / multiplier); // a bit denser
                return base;
            }
            return 0;
        }

        function getTimeOfDayInfo() {
            const nightTint = [0.45, 0.5, 0.75], sunriseTint = [1.0, 0.75, 0.6], dayTint = [1.0, 1.0, 1.0];
            let tint;
            if (timeOfDay < 0.25) tint = lerpColor(nightTint, sunriseTint, timeOfDay / 0.25);
            else if (timeOfDay < 0.5) tint = lerpColor(sunriseTint, dayTint, (timeOfDay - 0.25) / 0.25);
            else if (timeOfDay < 0.75) tint = lerpColor(dayTint, sunriseTint, (timeOfDay - 0.5) / 0.25);
            else tint = lerpColor(sunriseTint, nightTint, (timeOfDay - 0.75) / 0.25);
            const lightLevel = 0.2 + (Math.max(0, Math.sin(timeOfDay * Math.PI * 2)) * 0.8);
            return { lightLevel, tint };
        }
        function lerpColor(c1, c2, t) { return [c1[0] + (c2[0] - c1[0]) * t, c1[1] + (c2[1] - c1[1]) * t, c1[2] + (c2[2] - c1[2]) * t]; }
        function formatTime(time) {
            const hours = Math.floor(time * 24), minutes = Math.floor(((time * 24) - hours) * 60);
            const ampm = hours >= 12 ? 'PM' : 'AM';
            const displayHours = hours % 12 === 0 ? 12 : hours % 12;
            return `${displayHours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')} ${ampm}`;
        }
        // --- Water helpers & river flow sampling (global) ---
        function isWaterLikeBiomeName(b) {
            return b && (b.includes('Water') || /river/i.test(b));
        }

        // Pick a tiny local flow vector from riverHints for world coords (wx, wy)
        function getRiverFlowAt(wx, wy, chunk) {
            if (!chunk || !chunk.riverHints || !chunk.riverHints.length) return { x: 0, y: 0 };
            const cx = Math.floor(wx / CHUNK_SIZE), cy = Math.floor(wy / CHUNK_SIZE);
            const lx = Math.round(wx - cx * CHUNK_SIZE);
            const ly = Math.round(wy - cy * CHUNK_SIZE);
            let best = null, bestD = 2;
            for (const h of chunk.riverHints) {
                const d = Math.abs(h.x - lx) + Math.abs(h.y - ly);
                if (d < bestD) { bestD = d; best = h; if (d === 0) break; }
            }
            return best && best.flow ? best.flow : { x: 0, y: 0 };
        }

        // =================================================================================
        // CHUNKS AND DRAWING
        // =================================================================================
        let perlin, isGenerating = false, isGamePaused = false, isDebugViewActive = false, isContourOverlayActive = false;
        let showSpawnOverlay = false; // NEW: toggled with P
        let isLightingEnabled = true;
        // --- Weather & Season (globals) ---
        const Weather = { type: '‚òÄÔ∏è', until: 0 }; // ‚òÄÔ∏è (clear) | üåßÔ∏è (rain) | ‚ùÑÔ∏è (snow)
        let season = 0.25; // 0..1 (winter‚Üíspring‚Üísummer‚Üíautumn bias)

        // --- Wind (global, slow-changing direction + gusts + spatial coherence) ---
        let windTime = 0;

        const Wind = {
            baseAngle: 0,      // radians; slowly meanders
            speed: 0.25,       // current wind strength (0..~2)
            targetSpeed: 0.25, // eased toward by updateWind()
        };

        function updateWind(dt) {
            if (!perlin) return; // safety in case called very early
            windTime += Math.max(0.001, dt);

            // slowly rotate wind direction using low-frequency noise
            const turnNoise = (perlin.temperature.noise(windTime * 0.02, 0) - 0.5) * 0.25;
            Wind.baseAngle += turnNoise * dt;

            // weather baseline
            const weatherBase =
                Weather.type === 'üåßÔ∏è' ? 0.9 :
                    Weather.type === '‚ùÑÔ∏è' ? 0.6 : 0.5;

            // long wave variability (breeze rises/falls)
            const slow = perlin.moisture.noise(windTime * 0.05, 7.3); // 0..1
            // gusts (spiky)
            const gustRaw = perlin.object.noise(windTime * 0.6, 13.7); // 0..1
            const gust = Math.max(0, gustRaw - 0.65) * 2.2;

            Wind.targetSpeed = weatherBase * (0.5 + 0.7 * slow) + gust;

            // ease current speed toward target
            const ease = 0.8;
            Wind.speed += (Wind.targetSpeed - Wind.speed) * Math.min(1, ease * dt);
        }

        // Spatially coherent local wind at world coords (wx, wy)
        function windAt(wx, wy) {
            const t = windTime;
            const local = perlin.object.noise(wx / 120 + t * 0.03, wy / 120 + t * 0.03); // 0..1
            const angle = Wind.baseAngle + (local - 0.5) * 0.8; // ¬±0.4 rad variation
            const pocket = 0.8 + 0.4 * perlin.river.noise(wx / 260 + t * 0.07, wy / 260 - t * 0.05);
            const strength = Wind.speed * pocket;
            return { dirX: Math.cos(angle), dirY: Math.sin(angle), strength };
        }

        // --- Settlements (villages) & trading ---
        const VILLAGE_RARITY = 0.012; // ~1.2% of suitable chunks attempt a village
        const VILLAGE_MIN_LAND_RATIO = 0.82;
        const VILLAGE_ALLOWED_BIOMES = new Set([
            'plain', 'savanna', 'forest', 'forestHills', 'taiga', 'taigaHills', 'jungle', 'jungleHills', 'swamp', 'swampHills', 'desert', 'desertHills'
        ]);

        const ROLES = {
            farmer: { emoji: 'üßë‚Äçüåæ', offer: { give: { 'ü™µ': 2 }, get: { 'üçû': 1 } } },
            vendor: { emoji: 'üß∫', offer: { give: { 'üêü': 2 }, get: { 'üß∫': 1 } } }, // simple ‚Äúbasket‚Äù reward
            smith: { emoji: 'üî®', offer: { give: { 'ü™µ': 4 }, get: { 'ü™ì': 1 } } },
        };

        // nearest NPC with a valid trade each frame
        let nearbyTradeNpc = null;

        // --- World life & hazards (new globals) ---
        let fireflies = [];                    // ephemeral night particles
        let waterFxQuality = 1;                // you already have this below, keep highest one (remove duplicate if present)
        let frameTick = 0;                     // "
        // === Fireflies config ===
        const FIREFLY_NIGHT_LIGHT_LEVEL = 0.45;  // from getTimeOfDayInfo().lightLevel
        const FIREFLY_MAX_PER_CHUNK = 6;         // cap per visible chunk


        // Fireflies settings
        const FIREFLY_MAX = 36;
        const FIREFLY_VIEW_MARGIN = 6;         // tiles beyond viewport
        const FIREFLY_SPAWN_TRIES = 12;

        function updateNpc(npc, dt, chunk, lightLevel) {
            // simple day plan: work ‚Üí market ‚Üí home; night = home
            const t = timeOfDay;                // 0..1
            const isNight = lightLevel < 0.30;

            // target (tx, ty)
            let tx = npc.homeX, ty = npc.homeY;
            if (!isNight) {
                if (t > 0.45 && t < 0.55) {       // short ‚Äúmarket hour‚Äù
                    tx = npc.cx; ty = npc.cy;
                } else {
                    tx = npc.workX; ty = npc.workY; // normal work time
                    if (Weather.type === 'üåßÔ∏è' && npc.role === 'farmer') { // farmers hide from rain
                        tx = npc.cx; ty = npc.cy;
                    }
                }
            }

            // head toward target with tiny wander
            npc.phase = (npc.phase || 0) + dt * 1.2;
            const jitterX = Math.cos(npc.phase * 2.3) * 0.05;
            const jitterY = Math.sin(npc.phase * 1.7) * 0.05;

            let vx = (tx - npc.x) + jitterX;
            let vy = (ty - npc.y) + jitterY;
            const m = Math.hypot(vx, vy) || 1e-6; vx /= m; vy /= m;

            const speed = (npc.speed || 1.0) * (Weather.type === '‚ùÑÔ∏è' ? 0.85 : 1.0);
            let nx = npc.x + vx * speed * dt;
            let ny = npc.y + vy * speed * dt;

            // keep out of water
            if (!isWaterLikeAt(Math.round(nx), Math.round(ny))) {
                npc.x = nx; npc.y = ny;
            }
        }



        // Hazard helpers
        function isFrozenBiomeName(b) {
            return b && (b === 'frozenRiver' || b === 'frozenShallowWater' || b === 'frozenDeepWater');
        }
        function getHazardAt(wx, wy) {
            const cx = Math.floor(wx / CHUNK_SIZE), cy = Math.floor(wy / CHUNK_SIZE);
            const ch = chunkCache.get(`${cx},${cy}`);
            if (!ch) return null;
            const lx = wx - cx * CHUNK_SIZE, ly = wy - cy * CHUNK_SIZE;
            if (lx < 0 || ly < 0 || lx >= CHUNK_SIZE || ly >= CHUNK_SIZE) return null;
            const i = ly * CHUNK_SIZE + lx;
            if (ch.hazardLava && ch.hazardLava[i]) return 'lava';
            if (ch.hazardQuicksand && ch.hazardQuicksand[i]) return 'quicksand';
            return null;
        }

        // Floating objects radius (reuse fish water coverage but sparser)
        function getFloatingPlacementRadius(biome, sliders) {
            if (biome.includes('Water') || /river/i.test(biome)) return Math.max(3, 14 / Math.max(0.2, sliders.fishDensityMultiplier));
            return 0;
        }

        let keys = {}, timeOfDay = 0.25, lastFrameTime = 0, lastFpsUpdateTime = 0;
        const fpsHistory = [], messages = [], particles = [];
        let minFps = Infinity, maxFps = 0;

        let player = {
            x: 0, y: 0,
            fishLog: {},
            inv: {} // emoji -> count
        };

        let DOMElements, canvas, viewport, playerDiv, playerEmojiSpan, seedInput, ctx, sliders;
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        minimapCanvas.width = minimapCanvas.height = 100;

        const CHUNK_SIZE = 32, MAX_CACHE_SIZE = 250, MAX_CHUNKS_PER_FRAME = 3;
        const chunkCache = new Map();
        const rawNoiseCache = new Map();
        let lastMinimapPlayerPos = { x: null, y: null };

        function getSliderValues() {
            return {
                heightScale: parseFloat(sliders.heightScale.slider.value),
                moistureScale: parseFloat(sliders.moistureScale.slider.value),
                climateContrast: parseFloat(sliders.climateContrast.slider.value),
                pixelScale: parseFloat(sliders.pixelScale.slider.value),
                persistence: parseFloat(sliders.persistence.slider.value),
                playerSpeed: parseFloat(sliders.playerSpeed.slider.value),
                waterLevel: parseFloat(sliders.waterLevel.slider.value),
                treeDensityMultiplier: parseFloat(sliders.treeDensity.slider.value),
                fishDensityMultiplier: parseFloat(sliders.fishDensity.slider.value),
                mapScale: parseFloat(sliders.mapScale.slider.value),
            };
        }

        function manageCache() {
            if (chunkCache.size <= MAX_CACHE_SIZE) return;
            const playerChunkX = Math.floor(player.x / CHUNK_SIZE), playerChunkY = Math.floor(player.y / CHUNK_SIZE);
            let farthestKey = null, maxDistSq = -1;
            for (const key of chunkCache.keys()) {
                const [cx, cy] = key.split(',').map(Number);
                const distSq = (cx - playerChunkX) ** 2 + (cy - playerChunkY) ** 2;
                if (distSq > maxDistSq) { maxDistSq = distSq; farthestKey = key; }
            }
            if (farthestKey) { chunkCache.delete(farthestKey); }
        }

        function invAdd(emoji, n = 1) { player.inv[emoji] = (player.inv[emoji] || 0) + n; }
        function invHasAll(req) { for (const [e, q] of Object.entries(req)) if ((player.inv[e] || 0) < q) return false; return true; }
        function invConsume(req) { for (const [e, q] of Object.entries(req)) player.inv[e] = (player.inv[e] || 0) - q; }
        function invGrant(give) { for (const [e, q] of Object.entries(give)) invAdd(e, q); }
        function formatOffer(o) {
            const lhs = Object.entries(o.give).map(([e, q]) => `${q}${e}`).join(' + ');
            const rhs = Object.entries(o.get).map(([e, q]) => `${q}${e}`).join(' + ');
            return `${lhs} ‚Üí ${rhs}`;
        }


        function generatePerlinMaps() {
            const seed = parseInt(seedInput.value) || 0;
            perlin = {
                height: new PerlinNoise(seed), moisture: new PerlinNoise(seed + 1),
                object: new PerlinNoise(seed + 2), temperature: new PerlinNoise(seed + 3),
                river: new PerlinNoise(seed + 4)
            };
        }

        // --- Helpers for biome-aware rivers ----------------------------------------
        function rgbMix([r1, g1, b1], [r2, g2, b2], a) {
            return [Math.round(r1 * (1 - a) + r2 * a), Math.round(g1 * (1 - a) + g2 * a), Math.round(b1 * (1 - a) + b2 * a)];
        }

        // Sample 8-neighborhood to find dominant *land* biome around (local grid coords)
        function getDominantNeighborLandBiome(biomeGrid, x, y) {
            const w = CHUNK_SIZE, h = CHUNK_SIZE;
            const counts = {};
            const isLand = b => b && !(b.includes('Water') || /river/i.test(b)) && b !== 'beach' && b !== 'snowyBeach';
            for (let j = -1; j <= 1; j++) {
                for (let i = -1; i <= 1; i++) {
                    if (i === 0 && j === 0) continue;
                    const xx = x + i, yy = y + j;
                    if (xx < 0 || yy < 0 || xx >= w || yy >= h) continue;
                    const b = biomeGrid[yy * w + xx];
                    if (isLand(b)) counts[b] = (counts[b] || 0) + 1;
                }
            }
            // return most frequent land biome (or null)
            let best = null, c = -1;
            for (const k in counts) if (counts[k] > c) { c = counts[k]; best = k; }
            return best;
        }

        // Map surrounding land biome -> river style (color tint, extra width, speed tweak)
        function getRiverStyle(surroundBiome, nearSea) {
            // default classic blue
            let tint = [37, 174, 255], // base shallow-water blue
                extraWidth = 0,      // extra halo pixels
                alpha = 0.16,        // halo opacity
                speedMul = 0.4,      // baseline matches your lowlandRiver default
                fishBoost = 0;       // small density bias

            if (nearSea) { // delta behavior
                tint = [60, 170, 200];   // murkier
                extraWidth += 1; alpha = 0.22; fishBoost += 0.2; // denser fish in deltas
            }

            if (!surroundBiome) return { tint, extraWidth, alpha, speedMul, fishBoost };

            if (/mountain|snowy|ice/i.test(surroundBiome)) {
                tint = [30, 140, 210];        // cooler / glacial hint
                speedMul = 0.45;            // slightly faster
                alpha = Math.max(alpha, 0.18);
            } else if (/forest|plain|taiga/i.test(surroundBiome)) {
                tint = [37, 174, 255];        // classic
                speedMul = 0.4;
            } else if (/jungle|swamp/i.test(surroundBiome)) {
                tint = [85, 70, 40];        // tea/blackwater
                extraWidth += 1;            // marshy fringing
                alpha = 0.22;
                speedMul = 0.35;            // slower
                fishBoost += 0.15;          // catfish/piranha thrive
            } else if (/desert|badlands/i.test(surroundBiome)) {
                tint = [185, 150, 70];      // silty/yellow-brown
                extraWidth += 1; alpha = 0.2;
                speedMul = 0.4;
            } else if (/savanna/i.test(surroundBiome)) {
                tint = rgbMix([37, 174, 255], [185, 150, 70], 0.25); // slightly siltier than forest
                speedMul = 0.4;
            }
            return { tint, extraWidth, alpha, speedMul, fishBoost };
        }

        // --- River current: derive flow from height gradient ------------------------
        function getHeightGrad(wx, wy, perlin, sliders) {
            // finite difference on your continuous height field
            const hC = getHeightValueAtWorldCoords(wx, wy, perlin.height, sliders.heightScale, sliders.persistence, sliders.mapScale);
            const hX = getHeightValueAtWorldCoords(wx + 1, wy, perlin.height, sliders.heightScale, sliders.persistence, sliders.mapScale);
            const hY = getHeightValueAtWorldCoords(wx, wy + 1, perlin.height, sliders.heightScale, sliders.persistence, sliders.mapScale);
            // gradient points "uphill"; flow is opposite
            return { fx: hC - hX, fy: hC - hY }; // flow ~ downhill vector
        }

        // normalize with safe guard
        function normVec(x, y) {
            const m = Math.hypot(x, y) || 1e-6;
            return { x: x / m, y: y / m };
        }

        function getChunk(cx, cy) {
            return chunkCache.get(`${cx},${cy}`);
        }

        function getBiomeIndexFromCache(wx, wy) {
            const cx = Math.floor(wx / CHUNK_SIZE), cy = Math.floor(wy / CHUNK_SIZE);
            const chunk = getChunk(cx, cy);
            if (!chunk || !chunk.biomeIdx) return -1;
            const lx = wx - cx * CHUNK_SIZE, ly = wy - cy * CHUNK_SIZE;
            if (lx < 0 || ly < 0 || lx >= CHUNK_SIZE || ly >= CHUNK_SIZE) return -1;
            return chunk.biomeIdx[ly * CHUNK_SIZE + lx];
        }

        function isWaterLikeAt(wx, wy) {
            const idx = getBiomeIndexFromCache(wx, wy);
            if (idx >= 0) return !!BIOME_IS_WATERLIKE[idx];
            // fallback (rare)
            return isWaterLikeBiomeName(getBiomeAtWorldCoords(wx, wy, perlin, getSliderValues()));
        }

        function pickLandCenterInChunk(biomeIdx, waterMask) {
            // try the true center, then a few jitters until we hit land
            const tries = 20;
            for (let t = 0; t < tries; t++) {
                const cx = Math.floor(CHUNK_SIZE / 2 + (Math.random() - 0.5) * 8);
                const cy = Math.floor(CHUNK_SIZE / 2 + (Math.random() - 0.5) * 8);
                const i = cy * CHUNK_SIZE + cx;
                if (!waterMask[i]) return { lx: cx, ly: cy };
            }
            return { lx: Math.floor(CHUNK_SIZE / 2), ly: Math.floor(CHUNK_SIZE / 2) };
        }

        function buildVillageInChunk(chunkX, chunkY, biomeIdx, waterMask, seed) {
            // land ratio & dominant biome gate
            let landCount = 0, landBiomeCounts = {};
            for (let i = 0; i < biomeIdx.length; i++) if (!waterMask[i]) {
                landCount++;
                const name = BIOME_NAME[biomeIdx[i]];
                landBiomeCounts[name] = (landBiomeCounts[name] || 0) + 1;
            }
            const landRatio = landCount / (CHUNK_SIZE * CHUNK_SIZE);
            if (landRatio < VILLAGE_MIN_LAND_RATIO) return null;

            let dom = null, best = -1;
            for (const [name, c] of Object.entries(landBiomeCounts)) if (c > best) { best = c; dom = name; }
            if (!VILLAGE_ALLOWED_BIOMES.has(dom)) return null;

            // rarity / seed
            const r = seededRandom(chunkX * 1259 + chunkY * 3371 + seed + 77)();
            if (r > VILLAGE_RARITY) return null;

            // center
            const { lx, ly } = pickLandCenterInChunk(biomeIdx, waterMask);
            const wx0 = chunkX * CHUNK_SIZE, wy0 = chunkY * CHUNK_SIZE;
            const centerWx = wx0 + lx, centerWy = wy0 + ly;

            // theme (just pick house emoji by climate)
            const isDesert = /desert|badlands/i.test(dom);
            const isJungle = /jungle|swamp/i.test(dom);
            const HOUSE = isDesert ? 'üõñ' : (isJungle ? 'üèöÔ∏è' : 'üè†');

            // layout
            const objects = [];
            const houses = [];
            const rand = seededRandom(chunkX * 8881 + chunkY * 113 + seed + 911);
            const nHouses = 4 + Math.floor(rand() * 4); // 4..7
            const ringR = 6 + Math.floor(rand() * 4);   // ring radius

            const placeIfLand = (wx, wy, emoji, type, extra = {}) => {
                const cx = Math.floor(wx) - wx0, cy = Math.floor(wy) - wy0;
                if (cx < 0 || cy < 0 || cx >= CHUNK_SIZE || cy >= CHUNK_SIZE) return false;
                const i = cy * CHUNK_SIZE + cx;
                if (waterMask[i]) return false;
                objects.push({ x: Math.round(wx), y: Math.round(wy), type, emoji, ...extra });
                return true;
            };

            // central plaza (market/workshop live here)
            placeIfLand(centerWx, centerWy, 'üïØÔ∏è', 'decor', { label: 'plaza' });

            // houses around ring
            for (let i = 0; i < nHouses; i++) {
                const a = (i / nHouses) * Math.PI * 2 + rand() * 0.3;
                const dx = Math.cos(a) * ringR + (rand() - 0.5) * 1.5;
                const dy = Math.sin(a) * ringR + (rand() - 0.5) * 1.5;
                const hx = centerWx + dx, hy = centerWy + dy;
                if (placeIfLand(hx, hy, HOUSE, 'building')) houses.push({ x: Math.round(hx), y: Math.round(hy) });
            }

            // fields (üåæ) in bands on one side
            const fieldDir = (rand() < 0.5) ? { x: 1, y: 0 } : { x: 0, y: 1 };
            for (let k = -2; k <= 2; k++) {
                for (let s = -5; s <= 5; s++) {
                    const fx = centerWx + fieldDir.x * (s + 7) + (fieldDir.y ? k : 0);
                    const fy = centerWy + fieldDir.y * (s + 7) + (fieldDir.x ? k : 0);
                    placeIfLand(fx, fy, 'üåæ', 'decor');
                }
            }

            // market stall + workshop near plaza
            const market = { x: centerWx + 2, y: centerWy + (rand() < 0.5 ? 1 : -1) };
            const forge = { x: centerWx - 2, y: centerWy + (rand() < 0.5 ? -1 : 1) };
            placeIfLand(market.x, market.y, 'üß∫', 'building', { label: 'stall' });
            placeIfLand(forge.x, forge.y, 'üî®', 'building', { label: 'forge' });

            // NPCs (farmer, vendor, smith). Pick random homes.
            const npcs = [];
            const takeHome = () => houses[(Math.floor(rand() * houses.length)) | 0];
            const mkNPC = (role, work) => {
                const home = takeHome() || { x: centerWx, y: centerWy };
                const d = ROLES[role];
                npcs.push({
                    type: 'npc',
                    role,
                    emoji: d.emoji,
                    offer: d.offer,
                    x: home.x, y: home.y,
                    homeX: home.x, homeY: home.y,
                    workX: work.x, workY: work.y,
                    cx: centerWx, cy: centerWy,           // village center
                    phase: rand() * Math.PI * 2,
                    speed: 0.9 + rand() * 0.4
                });
            };
            mkNPC('farmer', fieldDir.x ? { x: centerWx + 10, y: centerWy } : { x: centerWx, y: centerWy + 10 });
            mkNPC('vendor', market);
            mkNPC('smith', forge);

            return { centerWx, centerWy, objects, npcs };
        }

        function generateChunkData(chunkX, chunkY, sliders, sunVector, seed) {
            const key = `${chunkX},${chunkY}`;
            // Store per-pixel biome; used by banks/branches/foam
            const biomeIdx = new Uint16Array(CHUNK_SIZE * CHUNK_SIZE);
            const biomeGrid = new Array(CHUNK_SIZE * CHUNK_SIZE);
            // Fast helpers
            const isRiverLike = (b) => b && /river/i.test(b);
            const isWaterLike = (b) => b && (b.includes('Water') || isRiverLike(b) || b === 'beach' || b === 'snowyBeach');

            const chunkCanvas = document.createElement('canvas');
            chunkCanvas.width = chunkCanvas.height = CHUNK_SIZE;
            const chunkCtx = chunkCanvas.getContext('2d'), chunkImageData = chunkCtx.createImageData(CHUNK_SIZE, CHUNK_SIZE);
            const data = chunkImageData.data, objects = [];

            for (let y = 0; y < CHUNK_SIZE; y++) {
                for (let x = 0; x < CHUNK_SIZE; x++) {
                    const worldX = chunkX * CHUNK_SIZE + x, worldY = chunkY * CHUNK_SIZE + y;

                    const biome = getBiomeAtWorldCoords(worldX, worldY, perlin, sliders);
                    const bIndex = BIOME_TO_INDEX.get(biome);
                    const i1d = y * CHUNK_SIZE + x;
                    biomeIdx[i1d] = bIndex;
                    biomeGrid[i1d] = biome; // <-- add
                    const heightValue = getHeightValueAtWorldCoords(worldX, worldY, perlin.height, sliders.heightScale, sliders.persistence, sliders.mapScale);
                    const baseColor = BIOME_COLOR_ARRAY[bIndex] || [0, 0, 0];
                    const lightness = isLightingEnabled
                        ? getPixelLightness(worldX, worldY, heightValue, perlin.height, sliders, sunVector)
                        : 1.0;


                    const [r, g, b] = baseColor.map(c => Math.min(255, Math.max(0, c * lightness)));
                    const idx = (y * CHUNK_SIZE + x) * 4;
                    [data[idx], data[idx + 1], data[idx + 2], data[idx + 3]] = [r, g, b, 255];
                }
            }
            // --- Precompute water mask + shoreline for cheap per-frame drawing ---
            const waterMask = new Uint8Array(CHUNK_SIZE * CHUNK_SIZE);
            const shoreline = [];
            for (let y = 0; y < CHUNK_SIZE; y++) {
                for (let x = 0; x < CHUNK_SIZE; x++) {
                    const i = y * CHUNK_SIZE + x;
                    waterMask[i] = BIOME_IS_WATERLIKE[biomeIdx[i]] ? 1 : 0;
                }
            }
            // find shoreline cells (water cells adjacent to non-water)
            for (let y = 0; y < CHUNK_SIZE; y++) {
                for (let x = 0; x < CHUNK_SIZE; x++) {
                    const i = y * CHUNK_SIZE + x;
                    if (!waterMask[i]) continue;

                    const getWaterAt = (lx, ly) => {
                        if (lx >= 0 && lx < CHUNK_SIZE && ly >= 0 && ly < CHUNK_SIZE) {
                            return waterMask[ly * CHUNK_SIZE + lx];
                        }
                        const wx = chunkX * CHUNK_SIZE + lx;
                        const wy = chunkY * CHUNK_SIZE + ly;
                        const ncx = Math.floor(wx / CHUNK_SIZE), ncy = Math.floor(wy / CHUNK_SIZE);
                        const neighbor = getChunk(ncx, ncy);
                        if (neighbor && neighbor.waterMask) {
                            const nlx = wx - ncx * CHUNK_SIZE, nly = wy - ncy * CHUNK_SIZE;
                            return neighbor.waterMask[nly * CHUNK_SIZE + nlx] || 0;
                        }
                        // rare fallback
                        return isWaterLikeBiomeName(getBiomeAtWorldCoords(wx, wy, perlin, sliders)) ? 1 : 0;
                    };

                    const left = getWaterAt(x - 1, y);
                    const right = getWaterAt(x + 1, y);
                    const up = getWaterAt(x, y - 1);
                    const down = getWaterAt(x, y + 1);
                    if (!(left && right && up && down)) shoreline.push(i);
                }
            }

            // --- Firefly nests (shoreline cells touching friendly land biomes) ---
            const fireflyNests = [];
            // seeded RNG so nests are deterministic per chunk+seed
            const nestRand = seededRandom(chunkX * 73856093 ^ chunkY * 19349663 ^ seed);

            function isLandFriendly(ii) {
                const name = BIOME_NAME[biomeIdx[ii]];
                // prefer treed/vegetated land near water
                return name && (/forest|swamp|jungle/i.test(name) || name === 'plain');
            }

            for (let s = 0; s < shoreline.length; s++) {
                const i = shoreline[s];
                const x = i % CHUNK_SIZE, y = (i / CHUNK_SIZE) | 0;

                // check 4-neighbors for a suitable land tile
                const nb = [
                    [x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]
                ];
                let good = false;
                for (const [xx, yy] of nb) {
                    if (xx < 0 || yy < 0 || xx >= CHUNK_SIZE || yy >= CHUNK_SIZE) continue;
                    const ii = yy * CHUNK_SIZE + xx;
                    if (!waterMask[ii] && isLandFriendly(ii)) { good = true; break; }
                }
                if (good && nestRand() < 0.18) {
                    // store local coords (tile space inside this chunk)
                    fireflyNests.push({ x, y });
                }
            }

            // --- Biome-aware river rendering & bank effects ---
            const riverHints = [];
            const heightCacheLocal = new Map();

            for (let y = 0; y < CHUNK_SIZE; y++) {
                for (let x = 0; x < CHUNK_SIZE; x++) {
                    const i = y * CHUNK_SIZE + x;
                    const b = biomeGrid[i];
                    if (!isRiverLike(b)) continue;

                    const worldX = chunkX * CHUNK_SIZE + x;
                    const worldY = chunkY * CHUNK_SIZE + y;

                    const domLand = getDominantNeighborLandBiome(biomeGrid, x, y);
                    const style = getRiverStyle(domLand, (() => {
                        const h = getAbsoluteHeight(worldX, worldY, perlin, sliders, heightCacheLocal);
                        return h < 140 && h >= 132;
                    })());

                    // mix color directly in the buffer (no get/put per pixel)
                    const idx = (i << 2);
                    const pr = data[idx], pg = data[idx + 1], pb = data[idx + 2];
                    const [nr, ng, nb] = rgbMix([pr, pg, pb], style.tint, 0.55);
                    data[idx] = nr; data[idx + 1] = ng; data[idx + 2] = nb;

                    // cheap 4-neighborhood halo (optional)
                    if (style.extraWidth > 0) {
                        const halo = (xx, yy) => {
                            if (xx < 0 || yy < 0 || xx >= CHUNK_SIZE || yy >= CHUNK_SIZE) return;
                            const ii = (yy * CHUNK_SIZE + xx) << 2;
                            // alpha blend against existing buffer
                            data[ii] = Math.round(data[ii] * (1 - style.alpha) + style.tint[0] * style.alpha);
                            data[ii + 1] = Math.round(data[ii + 1] * (1 - style.alpha) + style.tint[1] * style.alpha);
                            data[ii + 2] = Math.round(data[ii + 2] * (1 - style.alpha) + style.tint[2] * style.alpha);
                        };
                        halo(x - 1, y); halo(x + 1, y); halo(x, y - 1); halo(x, y + 1);
                    }

                    // flow hint
                    const g = getHeightGrad(worldX, worldY, perlin, sliders);
                    const n = (() => { const m = Math.hypot(g.fx, g.fy) || 1e-6; return { x: g.fx / m, y: g.fy / m }; })();
                    const gradMag = Math.min(1, Math.hypot(g.fx, g.fy) * 4.0);
                    const currentStrength = style.speedMul * (0.6 + 0.6 * gradMag);

                    riverHints.push({
                        x, y,
                        speedMul: style.speedMul,
                        fishBoost: style.fishBoost,
                        flow: { x: n.x * currentStrength, y: n.y * currentStrength }
                    });
                }
            }

            chunkCtx.putImageData(chunkImageData, 0, 0);

            const trees = PoissonDisk.generatePointsForChunk(chunkX, chunkY, perlin, sliders, seed,
                getTreePlacementRadius,
                (biome) => getTreePlacementRadius(biome, sliders) > 0,
                (c) => {
                    const possibleTrees = Object.values(TREE_TYPES).filter(t => t.biomes.includes(c.biome));
                    if (possibleTrees.length === 0) return null;

                    const typeRand = seededRandom(c.x * c.y + seed + 1)();
                    const treeIndex = Math.floor(typeRand * possibleTrees.length);
                    const treeType = possibleTrees[treeIndex];
                    if (!treeType) return null;

                    const heightRand = seededRandom(c.x * 123 + c.y * 456 + seed + 4)();
                    const height = treeType.minHeight + Math.floor(heightRand * (treeType.maxHeight - treeType.minHeight + 1));

                    const offsetXRand = seededRandom(c.x * 987 + c.y * 654 + seed + 2)();
                    const offsetYRand = seededRandom(c.x * 321 + c.y * 123 + seed + 3)();

                    const offsetX = (offsetXRand - 0.5) * 0.8;
                    const offsetY = (offsetYRand - 0.5) * 0.8;

                    return {
                        x: Math.round(c.x),
                        y: Math.round(c.y),
                        type: 'tree',
                        emoji: treeType.emoji,
                        height,
                        offsetX,
                        offsetY,
                        swayPhase: seededRandom(c.x * 777 + c.y * 333 + seed + 9)() * Math.PI * 2,
                        // NEW: spring state (bending with inertia)
                        bend: 0,       // current tip offset in pixels
                        bendVel: 0     // velocity of the bend (px/s)
                    };

                }
            );

            const fish = PoissonDisk.generatePointsForChunk(chunkX, chunkY, perlin, sliders, seed,
                getFishPlacementRadius,
                (biome) => biome.includes('Water') || /river/i.test(biome),
                (c) => {
                    const possibleFish = Object.entries(FISH_TYPES).filter(([_, f]) => f.biomes.includes(c.biome));
                    if (possibleFish.length === 0) return null;

                    // Weighted pick by rarity (no early return!)
                    const rand = seededRandom(c.x * c.y + seed)();
                    const totalRarity = possibleFish.reduce((sum, [, f]) => sum + f.rarity, 0);
                    let choice = rand * totalRarity;
                    let selected = possibleFish[possibleFish.length - 1];
                    for (const entry of possibleFish) {
                        const [, f] = entry;
                        if (choice < f.rarity) { selected = entry; break; }
                        choice -= f.rarity;
                    }
                    const [name, fishData] = selected;

                    // Motion/state present for ALL fish
                    let baseSpeed = (/river/i.test(c.biome) ? 1.8 : 1.1);
                    if (/frozen/i.test(c.biome)) baseSpeed *= 0.8;
                    if (/deltaRiver|marshRiver/i.test(c.biome)) baseSpeed *= 1.1;

                    const dirRand = seededRandom(c.x * 41 + c.y * 73 + seed + 5)();
                    const theta = dirRand * Math.PI * 2;

                    return {
                        x: Math.round(c.x),
                        y: Math.round(c.y),
                        type: 'fish',
                        name,
                        emoji: fishData.emoji,

                        vx: Math.cos(theta) * 0.5,
                        vy: Math.sin(theta) * 0.5,
                        speed: baseSpeed,
                        phase: seededRandom(c.x * 17 + c.y * 29 + seed + 6)() * Math.PI * 2,
                        homeX: Math.round(c.x),
                        homeY: Math.round(c.y),
                    };
                }
            );

            // Floating debris / lilies (üçÉ, ü™µ, ü™∑)
            const floaters = PoissonDisk.generatePointsForChunk(
                chunkX, chunkY, perlin, sliders, seed + 101,
                getFloatingPlacementRadius,
                (biome) => (biome.includes('Water') || /river/i.test(biome)),
                (c) => {
                    // choose type by biome
                    const onRiver = /river/i.test(c.biome);
                    const onShallow = /shallowWater|deltaRiver|marshRiver/i.test(c.biome);
                    let kind = 'leaf', emoji = 'üçÉ', drag = 1.0;

                    const r = seededRandom(13 * c.x + 37 * c.y + seed + 7)();
                    if (onShallow && r < 0.25) { kind = 'lily'; emoji = 'ü™∑'; drag = 0.35; }
                    else if (r < 0.45) { kind = 'log'; emoji = 'ü™µ'; drag = 0.7; }
                    // else leaf (üçÉ)

                    const theta = seededRandom(19 * c.x + 23 * c.y + seed + 8)() * Math.PI * 2;
                    return {
                        x: Math.round(c.x), y: Math.round(c.y),
                        type: 'float',
                        kind, emoji,
                        vx: Math.cos(theta) * 0.1, vy: Math.sin(theta) * 0.1,
                        drag,                       // 0..1 less = drifts mostly with flow
                        phase: seededRandom(c.x * 5 + c.y * 3 + seed)() * Math.PI * 2
                    };
                }
            );
            objects.push(...floaters.filter(f => f));
            objects.push(...trees.filter(t => t !== null), ...fish.filter(f => f !== null));
            // --- Procedural village (rare, per-chunk) ---
            let village = buildVillageInChunk(chunkX, chunkY, biomeIdx, waterMask, seed);
            if (village) {
                // buildings/fields are just scene objects
                for (const o of village.objects) objects.push(o);
                // NPCs are objects too; keep them inside this chunk (their routines respect bounds)
                for (const n of village.npcs) objects.push(n);
            }

            chunkCache.set(key, {
                canvas: chunkCanvas,
                objects,
                riverHints,
                waterMask,
                shoreline,
                biomeIdx,
                fireflyNests,
                fireflies: [],
                village // may be null
            });

            manageCache();
        }

        const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

        function renderNpc(obj, objScreenX, objScreenY, pixelScale, ctx) {
            // Resolve role/style
            const role = obj.role || (obj.offer ? 'trader' : 'villager');
            const st = NPC_STYLES[role] || NPC_STYLES.villager;

            const cx = objScreenX + pixelScale / 2;
            const cy = objScreenY + pixelScale / 2;

            // 1) Drop shadow (subtle for all)
            ctx.save();
            ctx.globalAlpha = 0.35;
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.ellipse(cx, cy + pixelScale * 0.32, pixelScale * 0.35, pixelScale * 0.18, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // 2) Back ring (color-coded; traders glow)
            ctx.save();
            if (st.glow) {
                const r = pixelScale * 0.75;
                const g = ctx.createRadialGradient(cx, cy, r * 0.25, cx, cy, r);
                g.addColorStop(0.00, 'rgba(255, 221, 120, 0.85)');
                g.addColorStop(0.50, 'rgba(255, 213, 74, 0.35)');
                g.addColorStop(1.00, 'rgba(255, 213, 74, 0.00)');
                ctx.fillStyle = g;
                ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.fill();
            } else {
                ctx.globalAlpha = 0.35;
                ctx.strokeStyle = st.ring;
                ctx.lineWidth = Math.max(1, pixelScale * 0.12);
                ctx.beginPath(); ctx.arc(cx, cy, pixelScale * 0.55, 0, Math.PI * 2); ctx.stroke();
            }
            ctx.restore();

            // 3) Main emoji (bigger for trader)
            ctx.save();
            ctx.font = `${Math.max(12, pixelScale * st.scale)}px sans-serif`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(st.emoji, cx, cy);
            ctx.restore();

            // 4) Role badge (top-right)
            if (st.badge) {
                const bx = cx + pixelScale * 0.45;
                const by = cy - pixelScale * 0.45;
                // badge background
                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.55)';
                ctx.beginPath(); ctx.arc(bx, by, pixelScale * 0.28, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
                // badge emoji
                ctx.save();
                ctx.font = `${Math.max(10, pixelScale * 0.6)}px sans-serif`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(st.badge, bx, by);
                ctx.restore();
            }

            // 5) Trader sparkle (rare, brief)
            if (st.sparkle) {
                const phase = (frameTick + ((obj.sparkSeed ??= (Math.random() * 1000) | 0))) % 90;
                if (phase < 10) {
                    const sx = cx + (Math.random() - 0.5) * pixelScale * 0.9;
                    const sy = cy - pixelScale * 0.9 + Math.random() * pixelScale * 0.3;
                    ctx.save();
                    ctx.globalAlpha = 0.85;
                    ctx.font = `${Math.max(10, pixelScale * 0.55)}px sans-serif`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(st.sparkle, sx, sy);
                    ctx.restore();
                }
            }
        }


        function drawWorld(deltaTime = 0) {
            if (isGenerating || !perlin) return { visibleTrees: 0, visibleFish: 0 };
            if (isDebugViewActive) { return drawDebugSpawnsView(); }

            nearbyTradeNpc = null;

            const sliders = getSliderValues();
            const { pixelScale } = sliders;
            const vw = viewport.clientWidth, vh = viewport.clientHeight;

            canvas.width = vw; canvas.height = vh;
            ctx.clearRect(0, 0, vw, vh);
            ctx.imageSmoothingEnabled = false;

            const viewTilesX = vw / pixelScale, viewTilesY = vh / pixelScale;
            const startTileX = player.x - viewTilesX / 2, endTileX = player.x + viewTilesX / 2;
            const startTileY = player.y - viewTilesY / 2, endTileY = player.y + viewTilesY / 2;
            const startChunkX = Math.floor(startTileX / CHUNK_SIZE), endChunkX = Math.ceil(endTileX / CHUNK_SIZE);
            const startChunkY = Math.floor(startTileY / CHUNK_SIZE), endChunkY = Math.ceil(endTileY / CHUNK_SIZE);

            let visibleTrees = 0, visibleFish = 0;
            const countsByIndex = new Uint32Array(BIOME_NAME.length);

            const angle = (timeOfDay - 0.25) * 2 * Math.PI;
            const sunVector = [-Math.cos(angle), -Math.sin(angle)];
            const seed = parseInt(seedInput.value) || 0;
            const timeInfo = getTimeOfDayInfo();
            const fishDayFactor = Math.max(0.4, timeInfo.lightLevel);

            // update + draw
            for (let i = fireflies.length - 1; i >= 0; i--) {
                const f = fireflies[i];
                f.phase += 0.15; // flicker
                f.x += f.vx; f.y += f.vy; f.life -= 0.016;
                if (f.life <= 0) { fireflies.splice(i, 1); continue; }
                const sx = (f.x - startTileX) * pixelScale, sy = (f.y - startTileY) * pixelScale;
                if (sx < -10 || sx > vw + 10 || sy < -10 || sy > vh + 10) { fireflies.splice(i, 1); continue; }

                const flicker = 0.6 + 0.4 * Math.sin(f.phase);
                ctx.globalAlpha = 0.5 * flicker;
                ctx.font = `${Math.max(10, pixelScale * 0.9)}px sans-serif`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText('‚ú®', sx, sy);
                ctx.globalAlpha = 1.0;
            }


            // FIRST PASS: draw chunks (generate with a per-frame budget) + update fish AI
            let builtThisFrame = 0;
            const drawList = [];

            for (let cy = startChunkY; cy < endChunkY; cy++) {
                for (let cx = startChunkX; cx < endChunkX; cx++) {
                    const key = `${cx},${cy}`;
                    let chunk = chunkCache.get(key);
                    if (!chunk) {
                        if (builtThisFrame < MAX_CHUNKS_PER_FRAME) {
                            generateChunkData(cx, cy, sliders, sunVector, seed);
                            builtThisFrame++;
                            chunk = chunkCache.get(key);
                        } else {
                            // skip drawing this chunk this frame
                            continue;
                        }
                    }
                    if (!chunk) continue;

                    const screenX = Math.round((cx * CHUNK_SIZE - startTileX) * pixelScale);
                    const screenY = Math.round((cy * CHUNK_SIZE - startTileY) * pixelScale);
                    ctx.drawImage(chunk.canvas, screenX, screenY, CHUNK_SIZE * pixelScale, CHUNK_SIZE * pixelScale);

                    // Fish AI update (cheap operations only; reuse dayFactor)
                    if (deltaTime > 0 && chunk.objects && chunk.objects.length) {
                        for (let i = 0; i < chunk.objects.length; i++) {
                            const obj = chunk.objects[i];
                            if (obj.type !== 'fish') continue;
                            const speed = (obj.speed || 1.2) * fishDayFactor;
                            obj.phase = (obj.phase || 0) + deltaTime * 2.0;

                            const wiggleX = Math.cos(obj.phase) * 0.15;
                            const wiggleY = Math.sin(obj.phase) * 0.15;

                            const toHomeX = (obj.homeX - obj.x), toHomeY = (obj.homeY - obj.y);
                            const distHome = Math.hypot(toHomeX, toHomeY) + 1e-6;
                            const homePull = Math.min(0.8, distHome * 0.02);
                            const nHomeX = toHomeX / distHome, nHomeY = toHomeY / distHome;

                            const dPX = (player.x - obj.x), dPY = (player.y - obj.y);
                            const dToPlayer = Math.hypot(dPX, dPY) + 1e-6;
                            let fleeX = 0, fleeY = 0;
                            if (dToPlayer < 10) {
                                fleeX = -(dPX / dToPlayer) * 0.8;
                                fleeY = -(dPY / dToPlayer) * 0.8;
                            }

                            const flow = getRiverFlowAt(obj.x, obj.y, chunk);
                            const flowX = flow.x * 2.2, flowY = flow.y * 2.2;

                            let vx = (obj.vx || 0) + wiggleX + nHomeX * homePull + fleeX + flowX * deltaTime;
                            let vy = (obj.vy || 0) + wiggleY + nHomeY * homePull + fleeY + flowY * deltaTime;
                            const vm = Math.hypot(vx, vy) || 1e-6; vx /= vm; vy /= vm;

                            const step = speed * deltaTime;
                            let nx = obj.x + vx * step, ny = obj.y + vy * step;

                            // water-boundary check via cached water masks
                            if (!isWaterLikeAt(Math.round(nx), Math.round(ny))) {
                                vx = -vx * 0.4 + nHomeX * 0.8; vy = -vy * 0.4 + nHomeY * 0.8;
                                const m2 = Math.hypot(vx, vy) || 1e-6; vx /= m2; vy /= m2;
                                nx = obj.x + vx * step * 0.6; ny = obj.y + vy * step * 0.6;
                            }

                            obj.x = nx; obj.y = ny; obj.vx = vx; obj.vy = vy;
                        }
                    }
                    // Floating debris/lilies update  // <-- ADD THIS RIGHT AFTER FISH UPDATE
                    if (deltaTime > 0 && chunk.objects && chunk.objects.length) {
                        for (let i = 0; i < chunk.objects.length; i++) {
                            const obj = chunk.objects[i];
                            if (obj.type !== 'float') continue;

                            const flow = getRiverFlowAt(obj.x, obj.y, chunk);
                            const wiggleX = Math.cos((obj.phase = (obj.phase || 0) + deltaTime)) * 0.05;
                            const wiggleY = Math.sin(obj.phase * 1.3) * 0.05;

                            const speed = 1.0; // base tile/s
                            let vx = wiggleX * (1 - obj.drag) + (flow.x || 0) * (1.3 + (obj.kind === 'log' ? 0.2 : 0)) + (obj.vx || 0) * 0.1;
                            let vy = wiggleY * (1 - obj.drag) + (flow.y || 0) * (1.3 + (obj.kind === 'log' ? 0.2 : 0)) + (obj.vy || 0) * 0.1;

                            const step = speed * deltaTime;
                            let nx = obj.x + vx * step, ny = obj.y + vy * step;

                            // keep in water
                            if (!isWaterLikeAt(Math.round(nx), Math.round(ny))) {
                                vx = -vx * 0.25; vy = -vy * 0.25;
                                nx = obj.x + vx * step * 0.5; ny = obj.y + vy * step * 0.5;
                            }
                            obj.vx = vx; obj.vy = vy; obj.x = nx; obj.y = ny;
                        }
                    }

                    // NPC update (simple routine)
                    if (deltaTime > 0 && chunk.objects && chunk.objects.length) {
                        const lightLevel = timeInfo.lightLevel;
                        for (let i = 0; i < chunk.objects.length; i++) {
                            const obj = chunk.objects[i];
                            if (obj.type === 'npc') updateNpc(obj, deltaTime, chunk, lightLevel);
                        }
                    }


                    drawList.push({ chunk, screenX, screenY, cx, cy });
                }
            }

            // Biome counts (legend) using cached chunk biomes (no perlin)
            for (const { cx, cy } of drawList) {
                const localStartX = Math.max(0, Math.floor(startTileX - cx * CHUNK_SIZE));
                const localEndX = Math.min(CHUNK_SIZE, Math.ceil(endTileX - cx * CHUNK_SIZE));
                const localStartY = Math.max(0, Math.floor(startTileY - cy * CHUNK_SIZE));
                const localEndY = Math.min(CHUNK_SIZE, Math.ceil(endTileY - cy * CHUNK_SIZE));

                const chunk = getChunk(cx, cy); if (!chunk || !chunk.biomeIdx) continue;
                // stride sampling scales with zoom: fewer reads when zoomed out
                const stride = Math.max(1, Math.floor(12 / Math.max(1, pixelScale)));
                for (let y = localStartY; y < localEndY; y += stride) {
                    const rowOff = y * CHUNK_SIZE;
                    for (let x = localStartX; x < localEndX; x += stride) {
                        countsByIndex[chunk.biomeIdx[rowOff + x]]++;
                    }
                }
            }

            // Optional contours (left unchanged, but runs AFTER counts so we can early return)
            if (isContourOverlayActive) {
                const contourInterval = 20, majorContourInterval = 100;
                const contourColor = 'rgba(0, 0, 0, 0.4)', majorContourColor = 'rgba(0, 0, 0, 0.7)', labelColor = 'rgba(255, 255, 255, 0.9)';
                const heightCache = new Map(); const labelInterval = Math.max(10, Math.round(120 / pixelScale));
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.shadowColor = 'black'; ctx.shadowBlur = 2;
                for (let y = Math.floor(startTileY); y < endTileY; y++) {
                    for (let x = Math.floor(startTileX); x < endTileX; x++) {
                        const h1 = getAbsoluteHeight(x, y, perlin, sliders, heightCache);
                        const h2 = getAbsoluteHeight(x + 1, y, perlin, sliders, heightCache);
                        let minH = Math.min(h1, h2), maxH = Math.max(h1, h2);
                        let level = Math.ceil(minH / contourInterval) * contourInterval;
                        while (level < maxH) {
                            const isMajor = level % majorContourInterval === 0;
                            ctx.strokeStyle = isMajor ? majorContourColor : contourColor;
                            ctx.lineWidth = isMajor ? 2 : 1.5;
                            const sx = (x + 1 - startTileX) * pixelScale, sy = (y - startTileY) * pixelScale;
                            ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(sx, sy + pixelScale); ctx.stroke();
                            if (y % labelInterval === 0) {
                                ctx.font = `bold ${isMajor ? Math.max(9, pixelScale / 1.4) : Math.max(7, pixelScale / 1.6)}px sans-serif`;
                                ctx.fillStyle = labelColor; ctx.fillText(level, sx + 3, sy + pixelScale / 2);
                            }
                            level += contourInterval;
                        }

                        const h3 = getAbsoluteHeight(x, y + 1, perlin, sliders, heightCache);
                        minH = Math.min(h1, h3); maxH = Math.max(h1, h3);
                        level = Math.ceil(minH / contourInterval) * contourInterval;
                        while (level < maxH) {
                            const isMajor = level % majorContourInterval === 0;
                            ctx.strokeStyle = isMajor ? majorContourColor : contourColor;
                            ctx.lineWidth = isMajor ? 2 : 1.5;
                            const sx = (x - startTileX) * pixelScale, sy = (y + 1 - startTileY) * pixelScale;
                            ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(sx + pixelScale, sy); ctx.stroke();
                            if (x % labelInterval === 0) {
                                ctx.font = `bold ${isMajor ? Math.max(9, pixelScale / 1.4) : Math.max(7, pixelScale / 1.6)}px sans-serif`;
                                ctx.fillStyle = labelColor; ctx.fillText(level, sx + pixelScale / 2, sy + 3);
                            }
                            level += contourInterval;
                        }
                    }
                }
                ctx.shadowBlur = 0;
            }

            // Day/Night overlay & bodies (wrap with lighting)
            if (isLightingEnabled) {
                const centerX = canvas.width / 2, horizonY = canvas.height / 2 + 50;
                const skyPathRadius = Math.min(canvas.width, canvas.height) * 0.7;
                const sunX = centerX - Math.cos(angle) * skyPathRadius, sunY = horizonY - Math.sin(angle) * skyPathRadius;
                const moonX = centerX + Math.cos(angle) * skyPathRadius, moonY = horizonY + Math.sin(angle) * skyPathRadius;

                if (sunY < horizonY + 20) { ctx.fillStyle = 'rgba(255, 255, 150, 0.9)'; ctx.beginPath(); ctx.arc(sunX, sunY, 30, 0, 2 * Math.PI); ctx.fill(); }
                if (moonY < horizonY + 20) { ctx.fillStyle = 'rgba(230, 230, 240, 0.8)'; ctx.beginPath(); ctx.arc(moonX, moonY, 25, 0, 2 * Math.PI); ctx.fill(); }

                const overlayAlpha = (1 - timeInfo.lightLevel) * 0.75, tint = timeInfo.tint;
                ctx.fillStyle = `rgba(${tint[0] * 30}, ${tint[1] * 40}, ${tint[2] * 80}, ${overlayAlpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // SECOND PASS: water FX (auto-throttled) + objects
            for (const { chunk, screenX, screenY } of drawList) {
                if (waterFxQuality >= 1 && chunk.riverHints && pixelScale >= 8) {
                    ctx.globalAlpha = 0.16;
                    ctx.fillStyle = '#ffffff';
                    const now = performance.now();
                    const step = Math.max(2, Math.floor(4 / Math.max(1, pixelScale / 10))); // fewer streaks when zoomed out
                    for (let k = 0; k < chunk.riverHints.length; k += step) {
                        const h = chunk.riverHints[k];
                        const sx = Math.round((h.x + ((now / 700) % 1) * (h.flow?.x ? Math.sign(h.flow.x) : 0)) * pixelScale) + screenX;
                        const sy = Math.round((h.y + ((now / 700) % 1) * (h.flow?.y ? Math.sign(h.flow.y) : 0)) * pixelScale) + screenY;
                        ctx.fillRect(sx, sy, 1, 1);
                    }
                    ctx.globalAlpha = 1.0;
                }

                if (waterFxQuality >= 1 && chunk.waterMask) {
                    ctx.globalAlpha = 0.07;
                    ctx.fillStyle = '#ffffff';
                    const stride = Math.max(3, Math.floor(8 / Math.max(1, pixelScale / 8)));
                    const w = CHUNK_SIZE, h = CHUNK_SIZE;
                    const phase = (frameTick >> 1) & 7;
                    for (let y = 0; y < h; y += stride) {
                        for (let x = (y & 1); x < w; x += stride) {
                            const i = y * w + x;
                            if (!chunk.waterMask[i]) continue;
                            if (((x + y + phase) & 7) === 0) {
                                const sx = Math.round(x * pixelScale) + screenX;
                                const sy = Math.round(y * pixelScale) + screenY;
                                ctx.fillRect(sx, sy, 1, 1);
                            }
                        }
                    }
                    ctx.globalAlpha = 1.0;
                }

                if (waterFxQuality >= 2 && chunk.shoreline && chunk.shoreline.length) {
                    const t = performance.now() * 0.001;
                    const a = 0.10 + 0.06 * (0.5 + 0.5 * Math.sin(t));
                    ctx.globalAlpha = a;
                    ctx.fillStyle = '#ffffff';
                    const step = (pixelScale >= 10) ? 3 : 4;
                    for (let s = 0; s < chunk.shoreline.length; s += step) {
                        const i = chunk.shoreline[s];
                        const x = (i % CHUNK_SIZE), y = (i / CHUNK_SIZE) | 0;
                        const sx = Math.round(x * pixelScale) + screenX;
                        const sy = Math.round(y * pixelScale) + screenY;
                        ctx.fillRect(sx, sy, 1, 1);
                    }
                    ctx.globalAlpha = 1.0;
                }
            }

            for (const { chunk } of drawList) {
                for (const obj of (chunk.objects || [])) {
                    const objScreenX = (obj.x - startTileX) * pixelScale;
                    const objScreenY = (obj.y - startTileY) * pixelScale;
                    if (objScreenX < -pixelScale || objScreenX > vw || objScreenY < -pixelScale || objScreenY > vh) continue;

                    if (obj.type === 'tree') {
                        visibleTrees++;

                        if (!obj._fontCache || obj._fontCache.scale !== pixelScale) {
                            const px = Math.max(8, Math.round(pixelScale * 1.2 * (obj.height * 0.5)));
                            obj._fontCache = { scale: pixelScale, px };
                        }

                        ctx.font = `${obj._fontCache.px}px sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';

                        const tileLeft = Math.floor(objScreenX);
                        const tileTop = Math.floor(objScreenY);
                        const tileBottom = tileTop + pixelScale;

                        const basePad = Math.max(1, Math.floor(pixelScale * 0.08));
                        const jxMax = (pixelScale / 2) - basePad;
                        const jx = clamp((obj.offsetX || 0) * pixelScale, -jxMax, jxMax);

                        // --- wind sway (top moves more than bottom) ---
                        const windMul = (Weather.type === 'üåßÔ∏è') ? 1.0 : 0.55;
                        const phase = frameTick * 0.05 + (obj.swayPhase || 0);

                        // how far the TIP should shift (in px)
                        const tipShiftMax = Math.min(pixelScale * 0.35, 4) * windMul * (0.8 + 0.1 * (obj.height || 1));
                        const tipShift = Math.sin(phase) * tipShiftMax;

                        // shear factor: shift-per-pixel of height
                        const shearX = tipShift / obj._fontCache.px;

                        // anchor the bottom of the tree, then shear so the top bends
                        const baseX = tileLeft + Math.floor(pixelScale / 2 + jx);
                        const baseY = tileBottom - basePad;

                        ctx.save();
                        ctx.translate(baseX, baseY);

                        // optional tiny rotation adds a bit of organic feel (pivot at base)
                        ctx.rotate(tipShift * 0.01);

                        // shear horizontally: [ 1 0 ; shearX 1 ]
                        ctx.transform(1, 0, shearX, 1, 0, 0);

                        ctx.fillText(obj.emoji, 0, 0);
                        ctx.restore();
                    }
                    else if (obj.type === 'fish') {
                        visibleFish++;
                        ctx.globalAlpha = 0.6 + Math.sin(frameTick / 12 + obj.x) * 0.3;
                        ctx.font = `${pixelScale * 0.8}px sans-serif`;
                        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        ctx.fillText(obj.emoji, objScreenX + pixelScale / 2, objScreenY + pixelScale / 2);
                        ctx.globalAlpha = 1.0;
                    }
                    else if (obj.type === 'float') {
                        visibleFish++; // counts into "visible water-things"
                        ctx.globalAlpha = 0.85;
                        ctx.font = `${Math.max(10, pixelScale * 0.8)}px sans-serif`;
                        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        ctx.fillText(obj.emoji, objScreenX + pixelScale / 2, objScreenY + pixelScale / 2);
                        ctx.globalAlpha = 1.0;
                    }
                    else if (obj.type === 'npc') {
                        // ‚ù∂ Render with strong visual identity by role
                        renderNpc(obj, objScreenX, objScreenY, pixelScale, ctx);

                        // ‚ù∑ Keep trade targeting logic (unchanged)
                        const d = Math.hypot(obj.x - player.x, obj.y - player.y);
                        const canTrade = (typeof invHasAll === 'function')
                            ? invHasAll((obj.offer && obj.offer.give) || {})
                            : true; // fallback if you don‚Äôt have inventory yet

                        // Treat anyone with an offer (or role === 'trader') as a trader for prompts
                        const isTrader = (obj.role === 'trader') || !!obj.offer;

                        if (isTrader && d < 1.6 && canTrade) {wdd
                            if (!nearbyTradeNpc || d < nearbyTradeNpc._d) {
                                nearbyTradeNpc = {
                                    npc: obj,
                                    sx: objScreenX + pixelScale / 2,
                                    sy: objScreenY - pixelScale * 0.2,
                                    _d: d
                                };
                            }
                        }
                    }

                    if (showSpawnOverlay) {
                        ctx.save();
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = (obj.type === 'fish') ? '#00FFFF' : '#00FF66';
                        ctx.strokeRect(
                            Math.floor(objScreenX) + 1,
                            Math.floor(objScreenY) + 1,
                            Math.max(2, pixelScale - 2),
                            Math.max(2, pixelScale - 2)
                        );
                        ctx.restore();
                    }
                }
            }

            // Particles
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update();
                const pScreenX = (p.x - startTileX) * pixelScale, pScreenY = (p.y - startTileY) * pixelScale;
                ctx.fillRect(pScreenX, pScreenY, p.size, p.size);
                if (p.life <= 0) particles.splice(i, 1);
            }

            // Weather
            if (Weather.type === 'üåßÔ∏è') {
                ctx.fillStyle = 'rgba(60,80,120,0.08)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 0.6; ctx.fillStyle = 'rgba(200, 200, 255, 0.9)';
                const n = Math.max(60, Math.min(140, Math.floor(canvas.width * canvas.height / 20000)));
                for (let i = 0; i < n; i++) {
                    const rx = (i * 97 + frameTick * 2) % canvas.width;
                    const ry = (i * 53 + frameTick * 3) % canvas.height;
                    ctx.fillRect(rx, ry, 1, 8);
                }
                ctx.globalAlpha = 1.0;
            } else if (Weather.type === '‚ùÑÔ∏è') {
                ctx.fillStyle = 'rgba(230,230,255,0.06)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 0.9; ctx.fillStyle = 'rgba(255,255,255,0.95)';
                const n = Math.max(40, Math.min(110, Math.floor(canvas.width * canvas.height / 30000)));
                for (let i = 0; i < n; i++) {
                    const rx = (i * 137 + Math.sin(frameTick / 30 + i) * 30 + canvas.width) % canvas.width;
                    const ry = (i * 71 + frameTick * 2) % canvas.height;
                    ctx.fillRect(rx, ry, 2, 2);
                }
                ctx.globalAlpha = 1.0;
            }

            // --- Fireflies: update + render (glowing, pulsing, night-only) ---
            if (timeInfo.lightLevel < FIREFLY_NIGHT_LIGHT_LEVEL) {
                for (const { chunk, screenX, screenY, cx, cy } of drawList) {
                    // === Spawn near already-loaded trees ===
                    const anchors = chunk.objects ? chunk.objects.filter(o => o.type === 'tree') : [];
                    if (anchors.length === 0) continue;

                    if (!chunk.fireflies) chunk.fireflies = [];

                    // Target count scales with tree density but is capped per chunk
                    const target = Math.min(
                        FIREFLY_MAX_PER_CHUNK,
                        Math.max(1, Math.floor(anchors.length * 0.4))
                    );

                    while (chunk.fireflies.length < target) {
                        const t = anchors[(Math.random() * anchors.length) | 0]; // pick a tree
                        const jitter = () => (Math.random() - 0.5) * 2.0;        // ~¬±1 tile radius
                        chunk.fireflies.push({
                            x: t.x + jitter(),
                            y: t.y + jitter(),
                            homeX: t.x + jitter(),
                            homeY: t.y + jitter(),
                            phase: Math.random() * Math.PI * 2
                        });
                    }


                    // update & render (use additive blending so they "lighten" the scene)
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';

                    for (const f of chunk.fireflies) {
                        // gentle hovering + stay near home
                        f.phase += deltaTime * (1.2 + (Weather.type === 'üåßÔ∏è' ? 0.6 : 0));
                        f.x += (Math.random() - 0.5) * 0.06;
                        f.y += (Math.random() - 0.5) * 0.06;
                        const toHomeX = f.homeX - f.x, toHomeY = f.homeY - f.y;
                        f.x += toHomeX * 0.015;
                        f.y += toHomeY * 0.015;

                        // screen coords
                        const sx = (f.x - startTileX) * pixelScale + screenX;
                        const sy = (f.y - startTileY) * pixelScale + screenY;

                        // pulse + tiny flicker (0.15 .. ~0.6)
                        const pulse = 0.5 + 0.5 * Math.sin(f.phase * 2.3);
                        const flicker = 0.85 + 0.15 * Math.sin(f.phase * 17.0 + f.x);
                        const alpha = 0.15 + 0.45 * pulse * flicker;

                        // skip if off-screen
                        if (sx < -10 || sy < -10 || sx > vw + 10 || sy > vh + 10) continue;

                        // soft glow
                        const radius = Math.max(1.5, pixelScale * 0.6);
                        const g = ctx.createRadialGradient(sx, sy, 0, sx, sy, radius);
                        // warm core ‚Üí greenish edge like real fireflies
                        g.addColorStop(0.0, `rgba(255,255,170,${alpha})`);
                        g.addColorStop(0.6, `rgba(190,255,140,${alpha * 0.6})`);
                        g.addColorStop(1.0, `rgba(190,255,140,0)`);
                        ctx.fillStyle = g;
                        ctx.beginPath(); ctx.arc(sx, sy, radius, 0, Math.PI * 2); ctx.fill();

                        // tiny bright core
                        ctx.globalAlpha = Math.min(0.9, alpha * 1.2);
                        ctx.fillStyle = 'rgba(255,255,210,1)';
                        ctx.fillRect(Math.round(sx), Math.round(sy), 1, 1);
                        ctx.globalAlpha = 1.0;
                    }

                    ctx.restore();
                }
            } else {
                // day: clear them so night respawns feel fresh
                for (const { chunk } of drawList) {
                    if (chunk.fireflies && chunk.fireflies.length) chunk.fireflies.length = 0;
                }
            }

            // trade prompt (draw once)
            if (nearbyTradeNpc) {
                const offerText = (typeof formatOffer === 'function' && nearbyTradeNpc.npc.offer)
                    ? formatOffer(nearbyTradeNpc.npc.offer)
                    : 'Trade';

                const txt = `E: ${offerText}`;
                ctx.save();
                ctx.font = `${Math.max(10, pixelScale * 0.7)}px sans-serif`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';

                // shadow box
                const w = ctx.measureText(txt).width + 12;
                const x = nearbyTradeNpc.sx, y = nearbyTradeNpc.sy;
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.fillRect(x - w / 2, y - 18, w, 16);

                // text
                ctx.fillStyle = '#fff';
                ctx.fillText(txt, x, y - 4);
                ctx.restore();
            }


            // Keep player centered
            playerDiv.style.left = `${vw / 2}px`;
            playerDiv.style.top = `${vh / 2}px`;

            // Convert biome counts to {name:count}
            const visibleBiomeCounts = {};
            for (let i = 0; i < countsByIndex.length; i++) {
                const c = countsByIndex[i];
                if (c) visibleBiomeCounts[BIOME_NAME[i]] = c;
            }

            return { visibleTrees, visibleFish, visibleBiomeCounts };
        }


        // Replace your drawDebugNoiseView() with this:
        function drawDebugSpawnsView() {
            const sliders = getSliderValues();
            const { pixelScale } = sliders;
            const vw = viewport.clientWidth, vh = viewport.clientHeight;

            canvas.width = vw; canvas.height = vh;
            ctx.clearRect(0, 0, vw, vh);
            ctx.imageSmoothingEnabled = false;

            const viewTilesX = vw / pixelScale, viewTilesY = vh / pixelScale;
            const startTileX = player.x - viewTilesX / 2, endTileX = player.x + viewTilesX / 2;
            const startTileY = player.y - viewTilesY / 2, endTileY = player.y + viewTilesY / 2;

            // faint biome background (so markers have context)
            for (let wy = Math.floor(startTileY); wy < Math.ceil(endTileY); wy++) {
                for (let wx = Math.floor(startTileX); wx < Math.ceil(endTileX); wx++) {
                    const biome = getBiomeAtWorldCoords(wx, wy, perlin, sliders);
                    const [r, g, b] = BIOME_COLORS[biome] || [0, 0, 0];
                    ctx.fillStyle = `rgba(${r},${g},${b},0.35)`;
                    ctx.fillRect((wx - startTileX) * pixelScale, (wy - startTileY) * pixelScale, pixelScale, pixelScale);
                }
            }

            // ensure chunks exist, then overlay spawn markers
            const startChunkX = Math.floor(startTileX / CHUNK_SIZE), endChunkX = Math.ceil(endTileX / CHUNK_SIZE);
            const startChunkY = Math.floor(startTileY / CHUNK_SIZE), endChunkY = Math.ceil(endTileY / CHUNK_SIZE);

            let visibleTrees = 0, visibleFish = 0;
            const visibleBiomeCounts = {};

            const seed = parseInt(seedInput.value) || 0;
            const angle = (timeOfDay - 0.25) * 2 * Math.PI;
            const sunVector = [-Math.cos(angle), -Math.sin(angle)];

            for (let cy = startChunkY; cy < endChunkY; cy++) {
                for (let cx = startChunkX; cx < endChunkX; cx++) {
                    const key = `${cx},${cy}`;
                    if (!chunkCache.has(key)) generateChunkData(cx, cy, sliders, sunVector, seed);
                    const chunk = chunkCache.get(key);
                    if (!chunk) continue;

                    for (const obj of chunk.objects) {
                        const sx = (obj.x - startTileX) * pixelScale + pixelScale / 2;
                        const sy = (obj.y - startTileY) * pixelScale + pixelScale / 2;

                        if (obj.type === 'tree') {
                            visibleTrees++;
                            ctx.strokeStyle = 'rgba(34,197,94,0.9)'; // green
                            ctx.lineWidth = Math.max(1, pixelScale / 8);
                            ctx.beginPath();
                            ctx.arc(sx, sy, Math.max(2, pixelScale * 0.4), 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.font = `${pixelScale * 0.9}px sans-serif`;
                            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                            ctx.fillStyle = 'rgba(34,197,94,0.9)';
                            ctx.fillText('üå≥', sx, sy - pixelScale * 0.1);
                        } else if (obj.type === 'fish') {
                            visibleFish++;
                            ctx.strokeStyle = 'rgba(59,130,246,0.95)'; // blue
                            ctx.lineWidth = Math.max(1, pixelScale / 8);
                            ctx.strokeRect(sx - pixelScale * 0.5, sy - pixelScale * 0.5, pixelScale, pixelScale);
                            ctx.font = `${pixelScale * 0.8}px sans-serif`;
                            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                            ctx.fillStyle = 'rgba(59,130,246,0.95)';
                            ctx.fillText('üêü', sx, sy);
                        }
                    }
                }
            }

            // gather biome counts like the normal view (so legend still makes sense)
            for (let wy = Math.floor(startTileY); wy < Math.ceil(endTileY); wy++) {
                for (let wx = Math.floor(startTileX); wx < Math.ceil(endTileX); wx++) {
                    const biome = getBiomeAtWorldCoords(wx, wy, perlin, sliders);
                    visibleBiomeCounts[biome] = (visibleBiomeCounts[biome] || 0) + 1;
                }
            }

            // small on-canvas label
            ctx.fillStyle = 'rgba(0,0,0,0.65)';
            ctx.fillRect(8, 8, 230, 48);
            ctx.fillStyle = '#fff';
            ctx.font = '12px sans-serif';
            ctx.fillText(`DEBUG: spawns  üå≥ ${visibleTrees}   üêü ${visibleFish}`, 18, 26);
            ctx.fillText(`Press P to return`, 18, 44);

            // keep player centered
            playerDiv.style.left = `${vw / 2}px`;
            playerDiv.style.top = `${vh / 2}px`;

            return { visibleTrees, visibleFish, visibleBiomeCounts };
        }


        function drawMinimap() {
            const roundedPlayerX = Math.round(player.x), roundedPlayerY = Math.round(player.y);
            if (lastMinimapPlayerPos.x === roundedPlayerX && lastMinimapPlayerPos.y === roundedPlayerY) return;
            lastMinimapPlayerPos.x = roundedPlayerX; lastMinimapPlayerPos.y = roundedPlayerY;

            minimapCtx.clearRect(0, 0, 100, 100);
            minimapCtx.imageSmoothingEnabled = false;

            const MINIMAP_ZOOM = 4;
            const startX = roundedPlayerX - (minimapCanvas.width / 2) * MINIMAP_ZOOM;
            const startY = roundedPlayerY - (minimapCanvas.height / 2) * MINIMAP_ZOOM;

            for (let y = 0; y < 100; y++) {
                for (let x = 0; x < 100; x++) {
                    const wx = startX + x * MINIMAP_ZOOM;
                    const wy = startY + y * MINIMAP_ZOOM;

                    const idx = getBiomeIndexFromCache(wx, wy);
                    const color = (idx >= 0 ? BIOME_COLOR_ARRAY[idx] : [0, 0, 0]);
                    minimapCtx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                    minimapCtx.fillRect(x, y, 1, 1);
                }
            }
        }


        // =================================================================================
        // GAME STATE, HUD, AND LOOP
        // =================================================================================
        function showMessage(msg) { messages.push(msg); if (messages.length === 1) displayNextMessage(); }
        function displayNextMessage() {
            if (messages.length === 0) return;
            const msg = messages[0];
            DOMElements.messageText.textContent = msg;
            DOMElements.messageText.classList.remove('hidden');
            DOMElements.messageText.classList.add('bubble-effect');
            setTimeout(() => {
                DOMElements.messageText.classList.remove('bubble-effect');
                setTimeout(() => {
                    DOMElements.messageText.classList.add('hidden');
                    messages.shift();
                    displayNextMessage();
                }, 2000);
            }, 500);
        }

        function updateHUD(currentBiome, visibleTrees = 0, visibleFish = 0, visibleBiomeCounts = {}) {
            const speedMod = getMovementSpeedModifier(currentBiome);
            DOMElements.speedModifierText.textContent = `${speedMod}x`;
            DOMElements.posText.textContent = `${Math.round(player.x)}, ${Math.round(player.y)}`;
            DOMElements.biomeText.textContent = currentBiome;
            DOMElements.timeText.textContent = formatTime(timeOfDay);
            DOMElements.treeCountText.textContent = visibleTrees;
            DOMElements.fishCountText.textContent = visibleFish;

            DOMElements.fishLog.innerHTML = '';
            const fishEntries = Object.keys(player.fishLog);
            if (fishEntries.length === 0) {
                DOMElements.fishLog.innerHTML = `<p class="text-gray-500 text-xs italic">No fish discovered</p>`;
            } else {
                for (const fishName of fishEntries) {
                    const fishInfo = FISH_TYPES[fishName];
                    DOMElements.fishLog.innerHTML += `<div class="flex justify-between items-center text-sm font-semibold"><span>${fishInfo.emoji} ${fishName.charAt(0).toUpperCase() + fishName.slice(1)}</span><span class="text-green-400">‚úì</span></div>`;
                }
            }

            const legendEntries = DOMElements.legendEntries;
            legendEntries.innerHTML = '';
            const sortedBiomes = Object.keys(visibleBiomeCounts).sort((a, b) => visibleBiomeCounts[b] - visibleBiomeCounts[a]);

            if (sortedBiomes.length === 0) {
                legendEntries.innerHTML = `<p class="text-gray-500 text-xs italic">No biomes in view</p>`;
            } else {
                for (const biomeName of sortedBiomes) {
                    const count = visibleBiomeCounts[biomeName];
                    const color = BIOME_COLORS[biomeName];
                    const colorHex = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;

                    const entryHTML = `
                        <div class="flex justify-between items-center">
                            <div class="flex items-center gap-2">
                                <div class="w-4 h-4 rounded-sm border border-gray-600" style="background-color: ${colorHex};"></div>
                                <span>${biomeName.charAt(0).toUpperCase() + biomeName.slice(1)}</span>
                            </div>
                            <span class="font-mono text-gray-400">${count}</span>
                        </div>
                    `;
                    legendEntries.innerHTML += entryHTML;
                }
            }


            DOMElements.keysText.textContent = Object.keys(keys).filter(k => keys[k]).map(k => k.toUpperCase()).join(', ') || '...';
            DOMElements.contourStatus.textContent = isContourOverlayActive ? 'On' : 'Off';
            DOMElements.contourStatus.classList.toggle('text-green-400', isContourOverlayActive);
            DOMElements.contourStatus.classList.toggle('text-red-400', !isContourOverlayActive);
        }

        class Particle {
            constructor(x, y) { this.x = x; this.y = y; this.life = 1; this.size = Math.random() * 2 + 1; this.vx = (Math.random() - 0.5) * 0.5; this.vy = -Math.random() * 0.5; }
            update() { this.x += this.vx; this.y += this.vy; this.life -= 0.05; }
        }

        // =================================================================================
        // GAME LOOP AND INPUT HANDLING
        // =================================================================================
        function gameLoop(timestamp) {
            requestAnimationFrame(gameLoop);
            if (isGamePaused) return;
            const deltaTime = (timestamp - lastFrameTime) / 1000 || 0;
            // advance a cheap integer frame counter for bitwise patterns
            frameTick = (frameTick + 1) | 0;
            lastFrameTime = timestamp;

            updateWind(deltaTime);

            if (timestamp - lastFpsUpdateTime > 100) {
                const fps = 1 / deltaTime;
                fpsHistory.push(fps); if (fpsHistory.length > 60) fpsHistory.shift();
                minFps = Math.min(minFps, fps); maxFps = Math.max(maxFps, fps);
                // Auto-throttle water FX to protect FPS
                if (fps < 28 && waterFxQuality > 0) {
                    waterFxQuality = 0;
                } else if (fps < 40 && waterFxQuality > 1) {
                    waterFxQuality = 1;
                } else if (fps > 55 && waterFxQuality < 2) {
                    waterFxQuality = 2;
                }
                DOMElements.currentFps.textContent = Math.round(fps); DOMElements.minFps.textContent = Math.round(minFps); DOMElements.maxFps.textContent = Math.round(maxFps);
            }
            // --- Weather director: picks a weather regime for a short duration ---
            {
                const t = performance.now();
                if (t > Weather.until) {
                    const r = Math.random();
                    let next = 'clear';
                    let dur = 30000 + Math.random() * 30000; // 30‚Äì60s
                    if (season < 0.25) {          // winter bias
                        next = r < 0.40 ? '‚ùÑÔ∏è' : (r < 0.65 ? '‚òÄÔ∏è' : 'üåßÔ∏è');
                    } else if (season < 0.5) {    // spring
                        next = r < 0.45 ? 'üåßÔ∏è' : '‚òÄÔ∏è';
                    } else if (season < 0.75) {   // summer
                        next = r < 0.15 ? 'üåßÔ∏è' : '‚òÄÔ∏è';
                    } else {                      // autumn
                        next = r < 0.35 ? 'üåßÔ∏è' : '‚òÄÔ∏è';
                    }
                    Weather.type = next;
                    Weather.until = t + dur;
                }
            }

            const sliders = getSliderValues();
            let moveX = 0, moveY = 0;
            if (keys['w'] || keys['arrowup']) moveY -= 1; if (keys['s'] || keys['arrowdown']) moveY += 1;
            if (keys['a'] || keys['arrowleft']) moveX -= 1; if (keys['d'] || keys['arrowright']) moveX += 1;

            const mag = Math.hypot(moveX, moveY);
            if (mag > 0) { moveX /= mag; moveY /= mag; }

            const currentBiome = getBiomeAtWorldCoords(Math.round(player.x), Math.round(player.y), perlin, sliders);
            // after: const currentBiome = getBiomeAtWorldCoords(...);
            let speedModifier = getMovementSpeedModifier(currentBiome);
            // --- Weather speed nudge (mild global effect) ---
            let weatherSpeedMul = 1.0;
            if (Weather.type === 'üåßÔ∏è') weatherSpeedMul = 0.95;
            else if (Weather.type === '‚ùÑÔ∏è') weatherSpeedMul = 0.90;

            speedModifier *= weatherSpeedMul;
            // Apply river current drift to player
            if (/river/i.test(currentBiome)) {
                const cx = Math.floor(player.x / CHUNK_SIZE), cy = Math.floor(player.y / CHUNK_SIZE);
                const chunk = chunkCache.get(`${cx},${cy}`);
                if (chunk && chunk.riverHints && chunk.riverHints.length) {
                    const lx = Math.round(player.x - cx * CHUNK_SIZE);
                    const ly = Math.round(player.y - cy * CHUNK_SIZE);
                    let best = null, bestD = 2;
                    for (const h of chunk.riverHints) {
                        const d = Math.abs(h.x - lx) + Math.abs(h.y - ly);
                        if (d < bestD) { bestD = d; best = h; if (d === 0) break; }
                    }
                    if (best && best.flow) {
                        // deltaTime available here; gentle push that respects your playerSpeed
                        player.x += best.flow.x * 6 * deltaTime;
                        player.y += best.flow.y * 6 * deltaTime;
                    }
                }
            }

            player.x += moveX * sliders.playerSpeed * deltaTime * 10 * speedModifier;
            player.y += moveY * sliders.playerSpeed * deltaTime * 10 * speedModifier;

            const isSwimming = (currentBiome.includes('Water') || /river/i.test(currentBiome));
            playerEmojiSpan.textContent = isSwimming ? 'üèä' : 'üö∂';

            if (moveX > 0) playerEmojiSpan.style.transform = 'scaleX(-1)';
            else if (moveX < 0) playerEmojiSpan.style.transform = 'scaleX(1)';

            const { visibleTrees, visibleFish, visibleBiomeCounts } = drawWorld(deltaTime);
            drawMinimap();
            updateHUD(currentBiome, visibleTrees, visibleFish, visibleBiomeCounts || {});
        }

        function performInteraction(worldX, worldY) {
            if (isGenerating || isGamePaused || !perlin) return;
            const chunkX = Math.floor(worldX / CHUNK_SIZE), chunkY = Math.floor(worldY / CHUNK_SIZE);
            const chunk = chunkCache.get(`${chunkX},${chunkY}`);

            if (chunk) {
                const objIndex = chunk.objects.findIndex(obj => obj.x === worldX && obj.y === worldY);
                if (objIndex !== -1) {
                    const object = chunk.objects[objIndex];
                    if (object.type === 'fish') {
                        if (!player.fishLog[object.name]) {
                            player.fishLog[object.name] = true;
                            showMessage(`Discovered a ${object.name}! ${object.emoji}`);
                        } else {
                            showMessage(`You've already discovered the ${object.name}.`);
                        }
                        invAdd('üêü', 1);
                        chunk.objects.splice(objIndex, 1);
                        for (let i = 0; i < 5; i++) particles.push(new Particle(worldX, worldY));
                    }
                }
            }
        }

        // =================================================================================
        // EVENT HANDLERS
        // =================================================================================
        function handleGenerate(isSeedChange = false) {
            if (isGenerating) return;
            DOMElements.loading.classList.remove('hidden');
            isGenerating = true;

            lastMinimapPlayerPos = { x: null, y: null }; // Force minimap redraw
            PoissonDisk.clearCache();
            rawNoiseCache.clear();
            chunkCache.clear();

            if (isSeedChange) {
                generatePerlinMaps();
            }

            drawWorld();
            drawMinimap();
            DOMElements.loading.classList.add('hidden');
            isGenerating = false;
            minFps = Infinity; maxFps = 0; fpsHistory.length = 0;
        }

        function handleLoadAndResize() {
            canvas.width = viewport.clientWidth; canvas.height = viewport.clientHeight;
            if (!isGenerating && perlin) { drawWorld(); drawMinimap(); }
        }

        function handleTimeSliderInteraction(event) {
            event.preventDefault();
            const rect = DOMElements.timeSliderContainer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2, centerY = rect.top + rect.height / 2;

            let wasPaused = isGamePaused;
            isGamePaused = true;

            function onMove(moveEvent) {
                const clientX = moveEvent.touches ? moveEvent.touches[0].clientX : moveEvent.clientX;
                const clientY = moveEvent.touches ? moveEvent.touches[0].clientY : moveEvent.clientY;
                const angleRad = Math.atan2(clientY - centerY, clientX - centerX) + Math.PI / 2;
                let angleDeg = angleRad * 180 / Math.PI;
                if (angleDeg < 0) angleDeg += 360;
                timeOfDay = angleDeg / 360;
                updateCircularSliderUI(timeOfDay);
                chunkCache.clear();
                drawWorld();
            }
            function onEnd() {
                window.removeEventListener('mousemove', onMove); window.removeEventListener('mouseup', onEnd);
                window.removeEventListener('touchmove', onMove); window.removeEventListener('touchend', onEnd);
                isGamePaused = wasPaused;
            }
            window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onEnd);
            window.addEventListener('touchmove', onMove); window.addEventListener('touchend', onEnd);
            onMove(event);
        }

        function updateCircularSliderUI(time) {
            const angle = time * 360;
            const r = 40, cx = 50, cy = 50;
            const handlePos = { x: cx + (r * Math.cos((angle - 90) * Math.PI / 180)), y: cy + (r * Math.sin((angle - 90) * Math.PI / 180)) };
            DOMElements.timeSliderHandle.setAttribute('cx', handlePos.x); DOMElements.timeSliderHandle.setAttribute('cy', handlePos.y);
            const endAngle = angle >= 359.99 ? 359.99 : angle;
            const start = { x: cx + (r * Math.cos((endAngle - 90) * Math.PI / 180)), y: cy + (r * Math.sin((endAngle - 90) * Math.PI / 180)) };
            const end = { x: cx + (r * Math.cos((-90) * Math.PI / 180)), y: cy + (r * Math.sin((-90) * Math.PI / 180)) };
            const largeArcFlag = endAngle <= 180 ? "0" : "1";
            DOMElements.timeSliderProgress.setAttribute('d', `M ${end.x} ${end.y} A ${r} ${r} 0 ${largeArcFlag} 1 ${start.x} ${start.y}`);
        }

        function setupMobileControls() {
            if (!('ontouchstart' in window)) return;
            DOMElements.mobileControls.classList.remove('hidden');
            let joystickTouchId = null;
            DOMElements.joystick.addEventListener('touchstart', (e) => { if (joystickTouchId === null) joystickTouchId = e.changedTouches[0].identifier; }, { passive: true });
            window.addEventListener('touchmove', (e) => {
                for (let touch of e.changedTouches) {
                    if (touch.identifier === joystickTouchId) {
                        const rect = DOMElements.joystick.getBoundingClientRect(), size = rect.width, handleSize = DOMElements.joystickHandle.clientWidth, maxDist = (size - handleSize) / 2;
                        let dx = touch.clientX - (rect.left + size / 2), dy = touch.clientY - (rect.top + size / 2);
                        const dist = Math.hypot(dx, dy);
                        if (dist > maxDist) { dx = (dx / dist) * maxDist; dy = (dy / dist) * maxDist; }
                        DOMElements.joystickHandle.style.transform = `translate(-50%, -50%) translate(${dx}px, ${dy}px)`;
                        keys['w'] = dy / maxDist < -0.2; keys['s'] = dy / maxDist > 0.2; keys['a'] = dx / maxDist < -0.2; keys['d'] = dx / maxDist > 0.2;
                        break;
                    }
                }
            }, { passive: true });
            window.addEventListener('touchend', (e) => {
                for (let touch of e.changedTouches) {
                    if (touch.identifier === joystickTouchId) {
                        joystickTouchId = null; DOMElements.joystickHandle.style.transform = `translate(-50%, -50%)`;
                        keys['w'] = keys['s'] = keys['a'] = keys['d'] = false; break;
                    }
                }
            });
        }

        window.onload = () => {
            DOMElements = {
                canvas: document.getElementById('canvas'),
                viewport: document.getElementById('viewport'),
                loading: document.getElementById('loading'),
                player: document.getElementById('player'),
                playerEmoji: document.getElementById('player-emoji'),
                speedModifierText: document.getElementById('speedModifierText'),
                posText: document.getElementById('posText'),
                biomeText: document.getElementById('biomeText'),
                timeText: document.getElementById('timeText'),
                treeCountText: document.getElementById('treeCountText'),
                fishCountText: document.getElementById('fishCountText'),
                keysText: document.getElementById('keysText'),
                fishLog: document.getElementById('fishLog'),
                currentFps: document.getElementById('currentFps'),
                minFps: document.getElementById('minFps'),
                maxFps: document.getElementById('maxFps'),
                messageBox: document.getElementById('messageBox'),
                messageText: document.getElementById('messageText'),
                contourStatus: document.getElementById('contourStatus'),
                settingsHud: document.getElementById('settingsHud'),
                toggleSettings: document.getElementById('toggleSettings'),
                legendHud: document.getElementById('legendHud'),
                toggleLegend: document.getElementById('toggleLegend'),
                legendEntries: document.getElementById('legendEntries'),
                seedInput: document.getElementById('seedInput'),
                heightScaleSlider: document.getElementById('heightScaleSlider'),
                heightScaleValue: document.getElementById('heightScaleValue'),
                moistureScaleSlider: document.getElementById('moistureScaleSlider'),
                moistureScaleValue: document.getElementById('moistureScaleValue'),
                climateContrastSlider: document.getElementById('climateContrastSlider'),
                climateContrastValue: document.getElementById('climateContrastValue'),
                pixelScaleSlider: document.getElementById('pixelScaleSlider'),
                pixelScaleValue: document.getElementById('pixelScaleValue'),
                persistenceSlider: document.getElementById('persistenceSlider'),
                persistenceValue: document.getElementById('persistenceValue'),
                playerSpeedSlider: document.getElementById('playerSpeedSlider'),
                playerSpeedValue: document.getElementById('playerSpeedValue'),
                waterLevelSlider: document.getElementById('waterLevelSlider'),
                waterLevelValue: document.getElementById('waterLevelValue'),
                treeDensitySlider: document.getElementById('treeDensitySlider'),
                treeDensityValue: document.getElementById('treeDensityValue'),
                fishDensitySlider: document.getElementById('fishDensitySlider'),
                fishDensityValue: document.getElementById('fishDensityValue'),
                mapScaleSlider: document.getElementById('mapScaleSlider'),
                mapScaleValue: document.getElementById('mapScaleValue'),
                timeSliderContainer: document.getElementById('timeSliderContainer'),
                timeSliderProgress: document.getElementById('timeSliderProgress'),
                timeSliderHandle: document.getElementById('timeSliderHandle'),
                mobileControls: document.getElementById('mobileControls'),
                joystick: document.getElementById('joystick'),
                joystickHandle: document.getElementById('joystickHandle'),
                lightingToggle: document.getElementById('lightingToggle'),
                inventoryText: document.getElementById('invText'),
            };

            DOMElements.seedInput.value = Math.floor(Math.random() * 90000) + 10000; // Set a random starting seed

            ({ canvas, viewport, player: playerDiv, playerEmoji: playerEmojiSpan, seedInput } = DOMElements);
            ctx = canvas.getContext('2d');
            sliders = {
                heightScale: { slider: DOMElements.heightScaleSlider, span: DOMElements.heightScaleValue },
                moistureScale: { slider: DOMElements.moistureScaleSlider, span: DOMElements.moistureScaleValue },
                climateContrast: { slider: DOMElements.climateContrastSlider, span: DOMElements.climateContrastValue, fixed: 1 },
                persistence: { slider: DOMElements.persistenceSlider, span: DOMElements.persistenceValue },
                waterLevel: { slider: DOMElements.waterLevelSlider, span: DOMElements.waterLevelValue, fixed: 3 },
                treeDensity: { slider: DOMElements.treeDensitySlider, span: DOMElements.treeDensityValue, suffix: 'x', fixed: 1 },
                fishDensity: { slider: DOMElements.fishDensitySlider, span: DOMElements.fishDensityValue, suffix: 'x', fixed: 1 },
                mapScale: { slider: DOMElements.mapScaleSlider, span: DOMElements.mapScaleValue, fixed: 2 },
                pixelScale: { slider: DOMElements.pixelScaleSlider, span: DOMElements.pixelScaleValue, regen: false },
                playerSpeed: { slider: DOMElements.playerSpeedSlider, span: DOMElements.playerSpeedValue, regen: false },
            };

            DOMElements.toggleSettings.addEventListener('click', () => {
                DOMElements.settingsHud.classList.toggle('collapsed');
            });
            DOMElements.toggleLegend.addEventListener('click', () => {
                DOMElements.legendHud.classList.toggle('collapsed');
            });
            DOMElements.lightingToggle.addEventListener('change', () => {
                isLightingEnabled = DOMElements.lightingToggle.checked;
                showMessage(`Lighting: ${isLightingEnabled ? 'On' : 'Off'}`);
                // Rebuild chunks so per-pixel shading matches the new mode
                handleGenerate(false);
            });


            window.addEventListener('resize', handleLoadAndResize);
            seedInput.addEventListener('change', () => handleGenerate(true));
            for (const key in sliders) {
                const { slider, span, regen = true, suffix = '', fixed = 0 } = sliders[key];
                slider.addEventListener('input', () => {
                    span.textContent = `${parseFloat(slider.value).toFixed(fixed)}${suffix}`;
                    if (regen) handleGenerate(false);
                    else if (key === 'pixelScale' && !isGenerating) drawWorld();
                });
            }
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const slider = sliders.pixelScale.slider;
                let newPixelScale = parseInt(slider.value) - Math.sign(e.deltaY);
                slider.value = Math.max(1, Math.min(24, newPixelScale));
                sliders.pixelScale.span.textContent = slider.value;
                if (!isGenerating) drawWorld();
            });
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT') return;
                const key = e.key.toLowerCase();

                if (key === 'p') {
                    if (e.shiftKey) { isDebugViewActive = !isDebugViewActive; chunkCache.clear(); }
                    else { showSpawnOverlay = !showSpawnOverlay; }
                    return; // <--
                } else if (key === 'h') {
                    isContourOverlayActive = !isContourOverlayActive;
                    return; // <--
                } else if (key === 'o') {
                    waterFxQuality = (waterFxQuality + 1) % 3;
                    showMessage(`Water FX: ${['Off', 'Low', 'Med'][waterFxQuality]}`);
                    return; // <--
                } else if (key === 'l') {
                    isLightingEnabled = !isLightingEnabled;
                    if (DOMElements.lightingToggle) DOMElements.lightingToggle.checked = isLightingEnabled;
                    showMessage(`Lighting: ${isLightingEnabled ? 'On' : 'Off'}`);
                    handleGenerate(false);
                    return;
                }
                else if (key === 'e') {
                    if (nearbyTradeNpc && nearbyTradeNpc.npc && nearbyTradeNpc.npc.offer && typeof invHasAll === 'function') {
                        const o = nearbyTradeNpc.npc.offer;
                        if (invHasAll(o.give)) {
                            invConsume(o.give);
                            invGrant(o.get);
                            showMessage(`Trade: ${typeof formatOffer === 'function' ? formatOffer(o) : 'Done'}`);
                        } else {
                            showMessage('You are missing items to trade.');
                        }
                    }
                    return;
                }

                keys[e.key.toLowerCase()] = true;
            });


            document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
            canvas.addEventListener('click', (e) => {
                const pixelScale = parseInt(sliders.pixelScale.slider.value);
                const rect = canvas.getBoundingClientRect();
                const worldX = Math.floor((player.x - (viewport.clientWidth / pixelScale) / 2) + (e.clientX - rect.left) / pixelScale);
                const worldY = Math.floor((player.y - (viewport.clientHeight / pixelScale) / 2) + (e.clientY - rect.top) / pixelScale);
                performInteraction(worldX, worldY);
            });

            DOMElements.timeSliderContainer.addEventListener('mousedown', handleTimeSliderInteraction);
            DOMElements.timeSliderContainer.addEventListener('touchstart', handleTimeSliderInteraction);

            generatePerlinMaps();
            handleLoadAndResize();
            setupMobileControls();
            updateCircularSliderUI(timeOfDay);
            gameLoop(0);
        };
    </script>
</body>

</html>