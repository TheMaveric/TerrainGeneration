<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Procedural Crafting Explorer v2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='40' height='48' viewport='0 0 100 100' style='font-size:24px;'><text y='50%'>🖐️</text></svg>") 16 24, auto;
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #1a202c;
        }

        #viewport {
            position: relative;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #canvas {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        #player {
            position: absolute;
            width: 8px;
            height: 8px;
            transform: translate(-50%, -50%);
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: transform 0.1s linear;
        }

        .pixelated {
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .bubble-effect {
            animation: bubble 0.5s ease-out;
        }

        @keyframes bubble {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        #mobileControls {
            pointer-events: none; /* Let clicks pass through the container */
        }
        #joystick, #actionButton {
            pointer-events: auto; /* But not the controls themselves */
        }
        
        #timeSliderContainer {
            cursor: pointer;
        }
        #timeSliderContainer svg * {
            pointer-events: none; /* Allow events to be captured by the container */
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">
    
    <div id="viewport">
        <canvas id="canvas" class="pixelated"></canvas>
        <div id="player">
            <span id="player-emoji" class="text-lg">🚶</span>
        </div>
        <div id="loading" class="absolute inset-0 flex items-center justify-center bg-gray-800 bg-opacity-75 z-50 transition-opacity duration-300 hidden">
            <svg class="animate-spin h-8 w-8 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
        </div>
        <!-- In-game HUD -->
        <div class="absolute top-4 left-4 p-3 bg-gray-800 bg-opacity-75 rounded-lg shadow-md z-20 max-w-xs">
            <div class="flex flex-col gap-2 text-sm font-semibold">
                <div class="flex justify-between items-center">
                    <span>💧 Thirst:</span>
                    <span id="thirstText">100%</span>
                </div>
                <div class="w-full h-2 bg-gray-900 rounded-full overflow-hidden">
                    <div id="thirstFill" class="h-full bg-blue-500 transition-all duration-200" style="width: 100%;"></div>
                </div>
                <div class="flex justify-between items-center text-sm font-semibold">
                    <span>⚡ Speed:</span>
                    <span id="speedModifierText">1x</span>
                </div>
                 <div class="flex justify-between items-center text-sm font-semibold pt-1 border-t border-gray-700 mt-1">
                    <span>🛠️ Tool:</span>
                    <span id="toolText">Hand 🖐️</span>
                </div>
                <div class="flex flex-col mt-2">
                    <div class="flex justify-between items-center">
                        <span>🗺️ Pos:</span>
                        <span id="posText">0, 0</span>
                    </div>
                    <div class="flex justify-between items-center">
                        <span>🌲 Biome:</span>
                        <span id="biomeText">...</span>
                    </div>
                     <div class="flex justify-between items-center">
                        <span>🛖 Shelter:</span>
                        <span id="shelterStatus" class="text-red-400">No</span>
                    </div>
                     <div class="flex justify-between items-center mt-1">
                        <span>☀️ Time:</span>
                        <span id="timeText">...</span>
                    </div>
                    <div class="flex justify-between items-center text-xs text-gray-400 pt-1 border-t border-gray-700 mt-1">
                        <span>Visible Trees:</span>
                        <span id="treeCountText">0</span>
                    </div>
                    <div class="flex justify-between items-center text-xs text-gray-400">
                        <span>Visible Fish:</span>
                        <span id="fishCountText">0</span>
                    </div>
                    <div class="flex justify-between items-center mt-1">
                        <span>⌨️ Keys:</span>
                        <span id="keysText">...</span>
                    </div>
                    <div class="flex justify-between items-center text-xs text-gray-400 pt-1 border-t border-gray-700 mt-1">
                        <span>FPS:</span>
                        <span id="currentFps" class="font-mono">--</span>
                    </div>
                    <div class="flex justify-between items-center text-xs text-gray-400">
                         <span>Min/Max:</span>
                         <span class="font-mono"><span id="minFps">--</span>/<span id="maxFps">--</span></span>
                    </div>
                </div>
            </div>
        </div>
        <div class="absolute top-4 right-4 p-3 bg-gray-800 bg-opacity-75 rounded-lg shadow-md z-20 max-w-xs">
            <div class="flex flex-col gap-2 text-sm font-semibold">
                <div class="flex justify-between items-center">
                    <span>🪵 Wood:</span>
                    <span id="woodCount">0</span>
                </div>
                <div class="flex justify-between items-center text-sm font-semibold">
                    <span>🪨 Stone:</span>
                    <span id="stoneCount">0</span>
                </div>
                <div class="flex justify-between items-center text-sm font-semibold">
                    <span>💧 Water:</span>
                    <span id="waterCount">0</span>
                </div>
                <div id="fishCounts" class="flex flex-col gap-1 mt-2 border-t border-gray-700 pt-2">
                    <!-- Fish counts will be dynamically inserted here -->
                </div>
            </div>
        </div>
        <div id="messageBox" class="absolute top-24 right-4 flex justify-center z-40">
            <div id="messageText" class="p-3 bg-gray-700 text-white rounded-lg shadow-md hidden text-center w-auto"></div>
        </div>
        
        <!-- Minimap -->
        <div class="absolute bottom-4 left-4 z-40">
            <div class="w-48 h-48 bg-gray-800 border-2 border-gray-600 rounded-lg overflow-hidden relative">
                <canvas id="minimapCanvas" class="w-full h-full pixelated"></canvas>
                <div id="minimapPlayer" class="absolute w-2 h-2 bg-red-500 rounded-full" style="left: 50%; top: 50%; transform: translate(-50%, -50%);"></div>
            </div>
        </div>

        <!-- Circular Time Slider -->
        <div id="timeSliderContainer" class="absolute bottom-4 right-4 z-40 w-32 h-32">
            <svg viewBox="0 0 100 100">
                <circle cx="50" cy="50" r="40" class="stroke-gray-700" stroke-width="8" fill="rgba(31, 41, 55, 0.7)"></circle>
                <path id="timeSliderProgress" class="stroke-yellow-400" stroke-width="8" fill="none" stroke-linecap="round"></path>
                <text x="50" y="15" text-anchor="middle" font-size="14">🕛</text> <!-- Midnight -->
                <text x="88" y="55" text-anchor="middle" font-size="14">☀️</text> <!-- Sunrise (approx) -->
                <text x="50" y="95" text-anchor="middle" font-size="14">🕕</text> <!-- Noon -->
                <text x="12" y="55" text-anchor="middle" font-size="14">🌙</text> <!-- Sunset (approx) -->
                <circle id="timeSliderHandle" cx="50" cy="10" r="6" class="fill-white"></circle>
            </svg>
        </div>


        <!-- Mobile Controls -->
        <div id="mobileControls" class="fixed bottom-0 left-0 right-0 p-8 flex justify-between items-end z-40 hidden">
            <div id="joystick" class="w-32 h-32 bg-gray-500 bg-opacity-30 rounded-full relative">
                <div id="joystickHandle" class="w-16 h-16 bg-gray-400 bg-opacity-50 rounded-full absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2"></div>
            </div>
            <button id="actionButton" class="w-20 h-20 bg-blue-500 bg-opacity-50 rounded-full flex items-center justify-center text-4xl active:bg-blue-400">
                🖐️
            </button>
        </div>
    </div>

    <!-- New Settings Menu -->
    <div id="settingsMenu" class="absolute top-1/2 right-4 -translate-y-1/2 bg-gray-800 bg-opacity-90 p-4 rounded-lg shadow-lg z-30 hidden w-64">
        <h3 class="text-lg font-bold text-center mb-4 text-white">World Settings</h3>
        <div class="controls w-full grid grid-cols-1 gap-4">
            <div class="flex flex-col items-center">
                <label for="seedInput" class="text-sm font-semibold mb-2 text-gray-300">Seed</label>
                <input type="text" id="seedInput" placeholder="Enter a number" value="12345" class="w-full text-center bg-gray-700 rounded-lg py-2 px-3 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500 text-white">
            </div>
            <div class="flex flex-col items-center">
                <label for="heightScaleSlider" class="text-sm font-semibold mb-2 text-gray-300">Height Scale: <span id="heightScaleValue">50</span></label>
                <input type="range" id="heightScaleSlider" min="20" max="150" value="50" class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
            </div>
            <div class="flex flex-col items-center">
                <label for="moistureScaleSlider" class="text-sm font-semibold mb-2 text-gray-300">Moisture Scale: <span id="moistureScaleValue">80</span></label>
                <input type="range" id="moistureScaleSlider" min="20" max="150" value="80" class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
            </div>
            <div class="flex flex-col items-center">
                <label for="pixelScaleSlider" class="text-sm font-semibold mb-2 text-gray-300">Pixel Scale: <span id="pixelScaleValue">12</span></label>
                <input type="range" id="pixelScaleSlider" min="1" max="24" value="12" class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
            </div>
            <div class="flex flex-col items-center">
                <label for="persistenceSlider" class="text-sm font-semibold mb-2 text-gray-300">Persistence: <span id="persistenceValue">0.5</span></label>
                <input type="range" id="persistenceSlider" min="0.1" max="1" step="0.05" value="0.5" class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
            </div>
            <div class="flex flex-col items-center">
                <label for="playerSpeedSlider" class="text-sm font-semibold mb-2 text-gray-300">Player Speed: <span id="playerSpeedValue">2</span></label>
                <input type="range" id="playerSpeedSlider" min="0.5" max="5" step="0.5" value="2" class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
            </div>
            <div class="flex flex-col items-center">
                <label for="waterLevelSlider" class="text-sm font-semibold mb-2 text-gray-300">Water Level: <span id="waterLevelValue">0.45</span></label>
                <input type="range" id="waterLevelSlider" min="0.0" max="1.0" step="0.05" value="0.45" class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
            </div>
            <div class="flex flex-col items-center">
                <label for="treeDensitySlider" class="text-sm font-semibold mb-2 text-gray-300">Tree Density: <span id="treeDensityValue">1.0</span>x</label>
                <input type="range" id="treeDensitySlider" min="0.2" max="2.0" step="0.1" value="1.0" class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
            </div>
            <div class="flex flex-col items-center">
                <label for="fishDensitySlider" class="text-sm font-semibold mb-2 text-gray-300">Fish Density: <span id="fishDensityValue">1.0</span>x</label>
                <input type="range" id="fishDensitySlider" min="0.0" max="3.0" step="0.1" value="1.0" class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
            </div>
        </div>
        <p class="text-xs text-center text-gray-400 mt-4">Press <kbd class="px-1 bg-gray-700 rounded-md">Esc</kbd> to close.</p>
    </div>
    
    <!-- Crafting Menu -->
    <div id="craftingMenu" class="fixed inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center z-50 hidden p-4">
        <div class="bg-gray-800 p-6 sm:p-8 rounded-xl shadow-lg w-full max-w-2xl flex flex-col items-center gap-6">
            <h2 class="text-2xl sm:text-3xl font-bold text-white text-center">Crafting</h2>
            <p class="text-sm text-gray-400">Press <kbd class="px-2 py-1 text-xs font-semibold bg-gray-700 rounded-md border border-gray-600">C</kbd> to close.</p>
            <div id="craftingRecipes" class="w-full space-y-4 max-h-96 overflow-y-auto">
                <!-- Recipes will be dynamically inserted here -->
            </div>
        </div>
    </div>

    <script>
        // =================================================================================
        // CORE NOISE AND MATH FUNCTIONS
        // =================================================================================
        const FISH_TYPES = {
            'cod': { emoji: '🐟', biomes: ['deepWater', 'shallowWater', 'river'], rarity: 0.08 },
            'salmon': { emoji: '🐠', biomes: ['river', 'shallowWater'], rarity: 0.05 },
            'pufferfish': { emoji: '🐡', biomes: ['jungle', 'swamp', 'shallowWater'], rarity: 0.03 },
            'arctic char': { emoji: '🐟', biomes: ['frozenDeepWater', 'frozenShallowWater'], rarity: 0.07 }
        };

        function seededRandom(seed) {
            let state = Math.sin(seed) * 10000;
            return function() {
                state = (state * 9301 + 49297) % 233280;
                return state / 233280;
            };
        }

        class PerlinNoise {
            constructor(seed) {
                const random = seededRandom(seed);
                this.p = new Array(512);
                const permutation = new Array(256);
                for (let i = 0; i < 256; i++) { permutation[i] = i; }
                for (let i = 0; i < 255; i++) {
                    const j = Math.floor(random() * (256 - i)) + i;
                    [permutation[i], permutation[j]] = [permutation[j], permutation[i]];
                }
                for (let i = 0; i < 256; i++) { this.p[i] = this.p[i + 256] = permutation[i]; }
            }
            noise(x, y) {
                const X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
                x -= Math.floor(x); y -= Math.floor(y);
                const u = this.fade(x), v = this.fade(y);
                const A = this.p[X] + Y, AA = this.p[A], AB = this.p[A + 1];
                const B = this.p[X + 1] + Y, BA = this.p[B], BB = this.p[B + 1];
                const res = this.lerp(v, this.lerp(u, this.grad(this.p[AA], x, y), this.grad(this.p[BA], x - 1, y)),
                                         this.lerp(u, this.grad(this.p[AB], x, y - 1), this.grad(this.p[BB], x - 1, y - 1)));
                return (res + 1.0) / 2.0;
            }
            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(t, a, b) { return a + t * (b - a); }
            grad(hash, x, y) {
                const h = hash & 3;
                const u = h < 2 ? x : y, v = h < 2 ? y : x;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }
        }
        
        // =================================================================================
        // BIOME AND WORLD GENERATION
        // =================================================================================
        const BIOME_COLORS = {
            'deepWater': [20, 91, 134], 'shallowWater': [38, 166, 245], 'frozenDeepWater': [20, 123, 174],
            'frozenShallowWater': [37, 174, 255], 'beach': [255, 216, 122], 'snowyBeach': [250, 240, 191],
            'desert': [250, 148, 24], 'desertHills': [210, 95, 17], 'badlands': [217, 69, 21],
            'badlandsPlateau': [202, 140, 101], 'badlandsHills': [120, 25, 25], 'taiga': [10, 102, 89],
            'taigaHills': [22, 57, 51], 'taigaMountains': [51, 142, 129], 'snowyTaiga': [49, 85, 74],
            'snowyTaigaHills': [36, 63, 54], 'snowyTaigaMountains': [89, 125, 114], 'savanna': [189, 178, 95],
            'savannaPlateau': [167, 157, 100], 'jungle': [83, 123, 9], 'jungleHills': [44, 66, 4],
            'swamp': [48, 53, 40], 'swampHills': [31, 36, 24], 'plain': [141, 179, 96],
            'forest': [5, 102, 33], 'forestHills': [0, 66, 44], 'forestMountains': [0, 48, 31],
            'mountain': [96, 96, 96], 'snowyTundra': [255, 255, 255], 'snowyMountains': [160, 160, 160],
            'iceSpikes': [180, 220, 220], 'river': [37, 174, 255]
        };

        function getOctaveNoise(x, y, perlin, scale, persistence, initialAmplitude = 1) {
            let total = 0, amplitude = initialAmplitude, frequency = 1, maxAmplitude = 0;
            for (let i = 0; i < 16; i++) { // Using 16 octaves to match Java code
                total += perlin.noise(x / scale * frequency, y / scale * frequency) * amplitude;
                maxAmplitude += amplitude;
                amplitude *= persistence;
                frequency *= 2;
            }
            return total / maxAmplitude;
        }

        function getHeightValueAtWorldCoords(worldX, worldY, perlinHeight, heightScale, persistence) {
            return getOctaveNoise(worldX, worldY, perlinHeight, heightScale, persistence, 10);
        }
        
        function getBiomeFromValues(heightValue, moistureValue, temperatureValue, riverValue, sliders){
            const { waterLevel } = sliders;
            const landHeight = (heightValue - waterLevel) / (1 - waterLevel);
            const h = heightValue < waterLevel ? (1 - (waterLevel - heightValue) / waterLevel) * 128 : 128 + landHeight * 127;
            const m = moistureValue * 255, t = temperatureValue * 255;
            
            if (h >= 128 && riverValue > 0.97) return 'river';
            if (h < 110) return 'deepWater';
            if (h < 128) return t <= 25 ? 'frozenShallowWater' : 'shallowWater';
            if (h < 132) return t <= 25 ? 'snowyBeach' : 'beach';
            if (t <= 25 && m > 75) return 'iceSpikes';
            if (t <= 25 && m <= 50) return 'snowyTundra';
            if ((t > 25 && t <= 50 && m > 25 && m <= 75) || (t <= 25 && m > 50 && m <= 75)) {
                if (t < 25) {
                     if (h > 200) return 'snowyTaigaMountains';
                     if (h > 180) return 'snowyTaigaHills';
                     return 'snowyTaiga';
                } else {
                     if (h > 200) return 'taigaMountains';
                     if (h > 180) return 'taigaHills';
                     return 'taiga';
                }
            }
            if (t > 66 && m <= 25) return h > 180 ? 'desertHills' : 'desert';
            if (t > 25 && t <= 66 && m <= 25) return h > 180 ? 'badlandsHills' : 'badlands';
            if ((t > 66 && m > 75) || (m > 50 && t > 50 && t <= 66)) return h > 180 ? 'jungleHills' : 'jungle';
            if (t > 66 && m <= 75 && m > 50) {
                 if (h > 220) return 'forestMountains';
                 if (h > 180) return 'forestHills';
                 return 'forest';
            }
            if (t > 75 && m <= 50 && m > 25) return h > 180 ? 'savannaPlateau' : 'savanna';
            if (t > 50 && t <= 75 && m > 25 && m <= 50) return h > 200 ? 'mountain' : 'plain';
            return 'swamp';
        }

        function getBiomeAtWorldCoords(worldX, worldY, perlin, sliders) {
            const heightValue = getHeightValueAtWorldCoords(worldX, worldY, perlin.height, sliders.heightScale, sliders.persistence);
            const moistureValue = getOctaveNoise(worldX, worldY, perlin.moisture, sliders.moistureScale, sliders.persistence, 10);
            const temperatureValue = getOctaveNoise(worldX, worldY, perlin.temperature, 150, sliders.persistence, 10);
            const rawRiverNoise = getOctaveNoise(worldX, worldY, perlin.river, 40, sliders.persistence, 10);
            const riverValue = 1 - Math.abs(rawRiverNoise * 2 - 1);
            return getBiomeFromValues(heightValue, moistureValue, temperatureValue, riverValue, sliders);
        }

        function getMovementSpeedModifier(biome, equippedTool) {
            if (equippedTool === 'boat' && (biome.includes('Water') || biome === 'river')) return 2.5;
            switch (biome) {
                case 'deepWater': case 'frozenDeepWater': case 'river': return 0.4;
                case 'shallowWater': case 'frozenShallowWater': return 0.6;
                case 'jungle': case 'jungleHills': case 'swamp': case 'swampHills': return 0.7;
                case 'snowyMountains': case 'taigaMountains': case 'snowyTaigaMountains': case 'mountain': case 'forestMountains': return 0.5;
                default: return 1.0;
            }
        }
        
        function getPixelLightness(x, y, heightValue, perlinHeight, sliders, sunVector) {
            const { heightScale, persistence } = sliders;
            const h_x1 = getHeightValueAtWorldCoords(x + 1, y, perlinHeight, heightScale, persistence);
            const h_y1 = getHeightValueAtWorldCoords(x, y + 1, perlinHeight, heightScale, persistence);
            const normalX = (heightValue - h_x1) * 20, normalY = (heightValue - h_y1) * 20;
            const dotProduct = normalX * sunVector[0] + normalY * sunVector[1];
            const lighting = 1.0 + dotProduct * 0.5;
            return Math.max(0.6, Math.min(1.4, lighting));
        }

        function getTreePlacementRadius(biome, sliders) {
              const multiplier = sliders.treeDensityMultiplier || 1;
              let baseRadius = 0;
              switch (biome) {
                  case 'forest': case 'jungle': case 'taiga': baseRadius = 3; break;
                  case 'forestHills': case 'jungleHills': case 'taigaHills': baseRadius = 4; break;
                  case 'swamp': case 'plain': baseRadius = 5; break;
                  case 'savanna': baseRadius = 7; break;
                  default: return 0;
              }
              return Math.max(1, baseRadius / multiplier);
        }

        function getTimeOfDayInfo() {
            const nightTint = [0.45, 0.5, 0.75], sunriseTint = [1.0, 0.75, 0.6], dayTint = [1.0, 1.0, 1.0];
            let tint;
            if (timeOfDay < 0.25) tint = lerpColor(nightTint, sunriseTint, timeOfDay / 0.25);
            else if (timeOfDay < 0.5) tint = lerpColor(sunriseTint, dayTint, (timeOfDay - 0.25) / 0.25);
            else if (timeOfDay < 0.75) tint = lerpColor(dayTint, sunriseTint, (timeOfDay - 0.5) / 0.25);
            else tint = lerpColor(sunriseTint, nightTint, (timeOfDay - 0.75) / 0.25);
            const lightLevel = 0.2 + (Math.max(0, Math.sin(timeOfDay * Math.PI * 2)) * 0.8);
            return { lightLevel, tint };
        }
        function lerpColor(c1, c2, t) { return [c1[0] + (c2[0] - c1[0]) * t, c1[1] + (c2[1] - c1[1]) * t, c1[2] + (c2[2] - c1[2]) * t]; }
        function formatTime(time) {
            const hours = Math.floor(time * 24), minutes = Math.floor(((time * 24) - hours) * 60);
            const ampm = hours >= 12 ? 'PM' : 'AM';
            const displayHours = hours % 12 === 0 ? 12 : hours % 12;
            return `${displayHours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')} ${ampm}`;
        }

        // =================================================================================
        // CHUNKS AND DRAWING
        // =================================================================================
        let perlin, isGenerating = false, isGamePaused = false, isDebugViewActive = false;
        let keys = {}, timeOfDay = 0.25, lastFrameTime = 0, lastFpsUpdateTime = 0;
        const fpsHistory = [], messages = [], particles = [];
        let minFps = Infinity, maxFps = 0;
        
        let player = {
            x: 0, y: 0, thirst: 100, hasShelter: false, equippedTool: null,
            inventory: { boat: 0 },
            resources: { wood: 0, stone: 0, water: 0, fish: {} }
        };

        const RECIPES = {
            shelter: { name: "Shelter", emoji: "🛖", description: "Stops thirst from decreasing.", cost: { wood: 10, stone: 5 }, craft: p => { if (p.hasShelter) return false; p.hasShelter = true; return true; } },
            axe: { name: "Axe", emoji: "🪓", description: "Gathers 2 wood from trees.", cost: { wood: 5, stone: 2 }, craft: p => { if (p.equippedTool === 'axe') return false; p.equippedTool = 'axe'; return true; } },
            pickaxe: { name: "Pickaxe", emoji: "⛏️", description: "Gathers 2 stone from mountains.", cost: { wood: 2, stone: 5 }, craft: p => { if (p.equippedTool === 'pickaxe') return false; p.equippedTool = 'pickaxe'; return true; } },
            boat: { name: "Boat", emoji: "⛵", description: "Move much faster on water.", cost: { wood: 20 }, craft: p => { p.inventory.boat = (p.inventory.boat || 0) + 1; return true; } },
        };

        let DOMElements, canvas, viewport, playerDiv, playerEmojiSpan, seedInput, ctx, fpsGraphCtx, sliders;
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        minimapCanvas.width = minimapCanvas.height = 100;

        const CHUNK_SIZE = 32, MAX_CACHE_SIZE = 250;
        const chunkCache = new Map();
        const rawNoiseCache = new Map();
        let lastMinimapPlayerPos = { x: null, y: null };

        function getSliderValues() {
            return {
                heightScale: parseFloat(sliders.heightScale.slider.value),
                moistureScale: parseFloat(sliders.moistureScale.slider.value),
                pixelScale: parseFloat(sliders.pixelScale.slider.value),
                persistence: parseFloat(sliders.persistence.slider.value),
                playerSpeed: parseFloat(sliders.playerSpeed.slider.value),
                waterLevel: parseFloat(sliders.waterLevel.slider.value),
                treeDensityMultiplier: parseFloat(sliders.treeDensity.slider.value),
                fishDensityMultiplier: parseFloat(sliders.fishDensity.slider.value),
            };
        }

        function manageCache() {
            if (chunkCache.size <= MAX_CACHE_SIZE) return;
            const playerChunkX = Math.floor(player.x / CHUNK_SIZE), playerChunkY = Math.floor(player.y / CHUNK_SIZE);
            let farthestKey = null, maxDistSq = -1;
            for (const key of chunkCache.keys()) {
                const [cx, cy] = key.split(',').map(Number);
                const distSq = (cx - playerChunkX) ** 2 + (cy - playerChunkY) ** 2;
                if (distSq > maxDistSq) { maxDistSq = distSq; farthestKey = key; }
            }
            if (farthestKey) { chunkCache.delete(farthestKey); }
        }

        function generatePerlinMaps() {
            const seed = parseInt(seedInput.value) || 0;
            perlin = {
                height: new PerlinNoise(seed), moisture: new PerlinNoise(seed + 1),
                object: new PerlinNoise(seed + 2), temperature: new PerlinNoise(seed + 3),
                river: new PerlinNoise(seed + 4), treePlacement: new PerlinNoise(seed + 5)
            };
        }

        function generateChunkData(chunkX, chunkY, sliders, sunVector) {
            const key = `${chunkX},${chunkY}`;
            const TREE_NOISE_FREQUENCY = 25;

            if (!rawNoiseCache.has(key)) {
                const rawData = { height: [], moisture: [], temperature: [], river: [], tree: [] };
                for (let y = 0; y < CHUNK_SIZE; y++) {
                    for (let x = 0; x < CHUNK_SIZE; x++) {
                        const worldX = chunkX * CHUNK_SIZE + x, worldY = chunkY * CHUNK_SIZE + y;
                        rawData.height.push(getHeightValueAtWorldCoords(worldX, worldY, perlin.height, sliders.heightScale, sliders.persistence));
                        rawData.moisture.push(getOctaveNoise(worldX, worldY, perlin.moisture, sliders.moistureScale, sliders.persistence, 10));
                        rawData.temperature.push(getOctaveNoise(worldX, worldY, perlin.temperature, 150, sliders.persistence, 10));
                        rawData.river.push(getOctaveNoise(worldX, worldY, perlin.river, 40, sliders.persistence, 10));
                    }
                }
                const treeNoiseValues = {};
                const requiredRadius = 8; 
                for (let y = -requiredRadius; y < CHUNK_SIZE + requiredRadius; y++) {
                    for (let x = -requiredRadius; x < CHUNK_SIZE + requiredRadius; x++) {
                        const worldX = chunkX * CHUNK_SIZE + x, worldY = chunkY * CHUNK_SIZE + y;
                        treeNoiseValues[`${worldX},${worldY}`] = perlin.treePlacement.noise(worldX / TREE_NOISE_FREQUENCY, worldY / TREE_NOISE_FREQUENCY);
                    }
                }
                rawData.tree = treeNoiseValues;
                rawNoiseCache.set(key, rawData);
            }
            
            const rawData = rawNoiseCache.get(key);
            const chunkCanvas = document.createElement('canvas');
            chunkCanvas.width = chunkCanvas.height = CHUNK_SIZE;
            const chunkCtx = chunkCanvas.getContext('2d'), chunkImageData = chunkCtx.createImageData(CHUNK_SIZE, CHUNK_SIZE);
            const data = chunkImageData.data, objects = [];

            for (let y = 0; y < CHUNK_SIZE; y++) {
                for (let x = 0; x < CHUNK_SIZE; x++) {
                    const idxInRaw = y * CHUNK_SIZE + x;
                    const worldX = chunkX * CHUNK_SIZE + x, worldY = chunkY * CHUNK_SIZE + y;
                    
                    const heightValue = rawData.height[idxInRaw];
                    const moistureValue = rawData.moisture[idxInRaw];
                    const temperatureValue = rawData.temperature[idxInRaw];
                    const rawRiverNoise = rawData.river[idxInRaw];
                    const riverValue = 1 - Math.abs(rawRiverNoise * 2 - 1);

                    const biome = getBiomeFromValues(heightValue, moistureValue, temperatureValue, riverValue, sliders);
                    const baseColor = BIOME_COLORS[biome] || [0,0,0];
                    const lightness = getPixelLightness(worldX, worldY, heightValue, perlin.height, sliders, sunVector);
                    
                    const [r,g,b] = baseColor.map(c => Math.min(255, Math.max(0, c * lightness)));
                    const idx = (y * CHUNK_SIZE + x) * 4;
                    [data[idx], data[idx + 1], data[idx + 2], data[idx + 3]] = [r, g, b, 255];
                    
                    const R = getTreePlacementRadius(biome, sliders);
                    if (R > 0 && !biome.includes('Water') && biome !== 'river') {
                        const centerNoise = rawData.tree[`${worldX},${worldY}`];
                        let isMax = true;
                        for (let dy = -R; dy <= R && isMax; dy++) {
                            for (let dx = -R; dx <= R; dx++) {
                                if ((dx === 0 && dy === 0) || (dx*dx + dy*dy > R*R)) continue;
                                if (rawData.tree[`${worldX + dx},${worldY + dy}`] > centerNoise) {
                                    isMax = false; break;
                                }
                            }
                        }
                        if (isMax) objects.push({ x: worldX, y: worldY, type: 'tree', emoji: '🌳' });
                    } else {
                        for (const fishName in FISH_TYPES) {
                            const fish = FISH_TYPES[fishName];
                            if (fish.biomes.includes(biome)) {
                                const fishNoise = perlin.object.noise(worldX + 1000, worldY + 1000);
                                if (fishNoise < (fish.rarity * sliders.fishDensityMultiplier)) {
                                    objects.push({ x: worldX, y: worldY, type: 'fish', name: fishName, emoji: fish.emoji });
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            chunkCtx.putImageData(chunkImageData, 0, 0);
            chunkCache.set(key, { canvas: chunkCanvas, objects: objects });
            manageCache();
        }

        function drawWorld() {
            if (isGenerating || !perlin) return { visibleTrees: 0, visibleFish: 0 };
            if (isDebugViewActive) { drawDebugNoiseView(); return { visibleTrees: 0, visibleFish: 0 }; }

            const sliders = getSliderValues();
            const { pixelScale } = sliders;
            const viewportWidth = viewport.clientWidth, viewportHeight = viewport.clientHeight;
            
            canvas.width = viewportWidth; canvas.height = viewportHeight;
            ctx.clearRect(0, 0, viewportWidth, viewportHeight);
            ctx.imageSmoothingEnabled = false;

            const viewTilesX = viewportWidth / pixelScale, viewTilesY = viewportHeight / pixelScale;
            const startTileX = player.x - viewTilesX / 2, endTileX = player.x + viewTilesX / 2;
            const startTileY = player.y - viewTilesY / 2, endTileY = player.y + viewTilesY / 2;
            const startChunkX = Math.floor(startTileX / CHUNK_SIZE), endChunkX = Math.ceil(endTileX / CHUNK_SIZE);
            const startChunkY = Math.floor(startTileY / CHUNK_SIZE), endChunkY = Math.ceil(endTileY / CHUNK_SIZE);
            
            let visibleTrees = 0, visibleFish = 0;
            
            const angle = (timeOfDay - 0.25) * 2 * Math.PI;
            const sunVector = [-Math.cos(angle), -Math.sin(angle)];

            for (let cy = startChunkY; cy < endChunkY; cy++) {
                for (let cx = startChunkX; cx < endChunkX; cx++) {
                    const key = `${cx},${cy}`;
                    if (!chunkCache.has(key)) { generateChunkData(cx, cy, sliders, sunVector); }
                    const chunk = chunkCache.get(key);
                    if(!chunk) continue;

                    const screenX = Math.round((cx * CHUNK_SIZE - startTileX) * pixelScale);
                    const screenY = Math.round((cy * CHUNK_SIZE - startTileY) * pixelScale);
                    
                    ctx.drawImage(chunk.canvas, screenX, screenY, CHUNK_SIZE * pixelScale, CHUNK_SIZE * pixelScale);
                    
                    ctx.font = `${pixelScale}px sans-serif`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    for (const obj of chunk.objects) {
                          const objScreenX = (obj.x - startTileX) * pixelScale, objScreenY = (obj.y - startTileY) * pixelScale;
                          if (objScreenX >= -pixelScale && objScreenX <= viewportWidth && objScreenY >= -pixelScale && objScreenY <= viewportHeight) {
                              if (obj.type === 'tree') visibleTrees++;
                              else if (obj.type === 'fish') visibleFish++;
                              ctx.fillText(obj.emoji, objScreenX + pixelScale / 2, objScreenY + pixelScale / 2);
                          }
                    }
                }
            }

            const timeInfo = getTimeOfDayInfo();
            const centerX = canvas.width / 2, horizonY = canvas.height / 2 + 50, skyPathRadius = Math.min(canvas.width, canvas.height) * 0.7;
            const sunX = centerX - Math.cos(angle) * skyPathRadius, sunY = horizonY - Math.sin(angle) * skyPathRadius;
            const moonX = centerX + Math.cos(angle) * skyPathRadius, moonY = horizonY + Math.sin(angle) * skyPathRadius;

            if (sunY < horizonY + 20) {
                ctx.fillStyle = 'rgba(255, 255, 150, 0.9)'; ctx.beginPath(); ctx.arc(sunX, sunY, 30, 0, 2 * Math.PI); ctx.fill();
            }
            if (moonY < horizonY + 20) {
                ctx.fillStyle = 'rgba(230, 230, 240, 0.8)'; ctx.beginPath(); ctx.arc(moonX, moonY, 25, 0, 2 * Math.PI); ctx.fill();
            }

            const overlayAlpha = (1 - timeInfo.lightLevel) * 0.75, tint = timeInfo.tint;
            ctx.fillStyle = `rgba(${tint[0]*30}, ${tint[1]*40}, ${tint[2]*80}, ${overlayAlpha})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update();
                const pScreenX = (p.x - startTileX) * pixelScale, pScreenY = (p.y - startTileY) * pixelScale;
                ctx.fillRect(pScreenX, pScreenY, p.size, p.size);
                if (p.life <= 0) particles.splice(i, 1);
            }

            playerDiv.style.left = `${viewportWidth / 2}px`;
            playerDiv.style.top = `${viewportHeight / 2}px`;

            return { visibleTrees, visibleFish };
        }
        
        function drawDebugNoiseView() {
            const sliders = getSliderValues();
            const { pixelScale } = sliders;
            const viewportWidth = viewport.clientWidth, viewportHeight = viewport.clientHeight;
            
            canvas.width = viewportWidth; canvas.height = viewportHeight;
            ctx.clearRect(0, 0, viewportWidth, viewportHeight);
            ctx.imageSmoothingEnabled = false;

            const viewTilesX = viewportWidth / pixelScale, viewTilesY = viewportHeight / pixelScale;
            const startTileX = player.x - viewTilesX / 2, endTileX = player.x + viewTilesX / 2;
            const startTileY = player.y - viewTilesY / 2, endTileY = player.y + viewTilesY / 2;

            for (let y = Math.floor(startTileY); y < Math.ceil(endTileY); y++) {
                for (let x = Math.floor(startTileX); x < Math.ceil(endTileX); x++) {
                    const noise = getOctaveNoise(x,y, perlin.river, 40, sliders.persistence, 10);
                    const r = noise * 255, b = (1 - noise) * 255;
                    ctx.fillStyle = `rgb(${r}, 0, ${b})`;
                    ctx.fillRect((x - startTileX) * pixelScale, (y - startTileY) * pixelScale, pixelScale, pixelScale);
                }
            }
            playerDiv.style.left = `${viewportWidth / 2}px`;
            playerDiv.style.top = `${viewportHeight / 2}px`;
        }

        function drawMinimap() {
            const roundedPlayerX = Math.round(player.x), roundedPlayerY = Math.round(player.y);
            if (lastMinimapPlayerPos.x === roundedPlayerX && lastMinimapPlayerPos.y === roundedPlayerY) return;
            lastMinimapPlayerPos.x = roundedPlayerX; lastMinimapPlayerPos.y = roundedPlayerY;

            minimapCtx.clearRect(0, 0, 100, 100);
            minimapCtx.imageSmoothingEnabled = false;
            const minimapScale = 2;
            const startX = roundedPlayerX - Math.floor((100 / minimapScale) / 2), startY = roundedPlayerY - Math.floor((100 / minimapScale) / 2);
            const sliders = getSliderValues();

            for (let y = 0; y < 100; y++) {
                for (let x = 0; x < 100; x++) {
                    const worldX = startX + x / minimapScale, worldY = startY + y / minimapScale;
                    const biome = getBiomeAtWorldCoords(worldX, worldY, perlin, sliders);
                    const color = BIOME_COLORS[biome] || [0,0,0];
                    minimapCtx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                    minimapCtx.fillRect(x, y, 1, 1);
                }
            }
        }

        // =================================================================================
        // GAME STATE, HUD, AND LOOP
        // =================================================================================
        function showMessage(msg) { messages.push(msg); if (messages.length === 1) displayNextMessage(); }
        function displayNextMessage() {
            if (messages.length === 0) return;
            const msg = messages[0];
            DOMElements.messageText.textContent = msg;
            DOMElements.messageText.classList.remove('hidden');
            DOMElements.messageText.classList.add('bubble-effect');
            setTimeout(() => {
                DOMElements.messageText.classList.remove('bubble-effect');
                setTimeout(() => {
                    DOMElements.messageText.classList.add('hidden');
                    messages.shift();
                    displayNextMessage();
                }, 2000); 
            }, 500);
        }

        function updateHUD(currentBiome, visibleTrees = 0, visibleFish = 0) {
            DOMElements.thirstFill.style.width = `${player.thirst}%`;
            DOMElements.thirstText.textContent = `${Math.floor(player.thirst)}%`;
            DOMElements.woodCount.textContent = player.resources.wood;
            DOMElements.stoneCount.textContent = player.resources.stone;
            DOMElements.waterCount.textContent = player.resources.water;
            
            const speedMod = getMovementSpeedModifier(currentBiome, player.equippedTool);
            DOMElements.speedModifierText.textContent = `${speedMod}x`;
            DOMElements.toolText.innerHTML = player.equippedTool ? `${RECIPES[player.equippedTool].name} ${RECIPES[player.equippedTool].emoji}` : 'Hand 🖐️';
            DOMElements.posText.textContent = `${Math.round(player.x)}, ${Math.round(player.y)}`;
            DOMElements.biomeText.textContent = currentBiome;
            DOMElements.timeText.textContent = formatTime(timeOfDay);
            DOMElements.treeCountText.textContent = visibleTrees;
            DOMElements.fishCountText.textContent = visibleFish;

            DOMElements.shelterStatus.textContent = player.hasShelter ? 'Yes' : 'No';
            DOMElements.shelterStatus.classList.toggle('text-green-400', player.hasShelter);
            DOMElements.shelterStatus.classList.toggle('text-red-400', !player.hasShelter);
            
            DOMElements.fishCounts.innerHTML = '';
            const fishEntries = Object.entries(player.resources.fish);
            if (fishEntries.length === 0) {
                DOMElements.fishCounts.innerHTML = `<p class="text-gray-500 text-xs italic">No fish caught</p>`;
            } else {
                for (const [fishName, count] of fishEntries) {
                    if (count > 0) {
                        const fishInfo = FISH_TYPES[fishName];
                        DOMElements.fishCounts.innerHTML += `<div class="flex justify-between items-center text-sm font-semibold"><span>${fishInfo.emoji} ${fishName.charAt(0).toUpperCase() + fishName.slice(1)}:</span><span>${count}</span></div>`;
                    }
                }
            }
            DOMElements.keysText.textContent = Object.keys(keys).filter(k => keys[k]).map(k => k.toUpperCase()).join(', ') || '...';
        }

        function updateCraftingMenu() {
            DOMElements.craftingRecipes.innerHTML = '';
            for (const [id, recipe] of Object.entries(RECIPES)) {
                const canCraft = Object.entries(recipe.cost).every(([res, cost]) => player.resources[res] >= cost);
                const costString = Object.entries(recipe.cost).map(([res, cost]) => `<span class="${player.resources[res] >= cost ? 'text-green-400' : 'text-red-400'} font-mono">${cost} ${res === 'wood' ? '🪵' : '🪨'}</span>`).join(', ');
                let buttonState = '';
                if (id === 'shelter' && player.hasShelter) buttonState = 'Built';
                else if (id === 'axe' && player.equippedTool === 'axe') buttonState = 'Equipped';
                else if (id === 'pickaxe' && player.equippedTool === 'pickaxe') buttonState = 'Equipped';
                
                DOMElements.craftingRecipes.innerHTML += `
                    <div class="w-full bg-gray-700 rounded-lg p-4">
                        <div class="flex justify-between items-center">
                            <div>
                                <h3 class="text-lg font-bold">${recipe.name} ${recipe.emoji}</h3>
                                <p class="text-sm text-gray-400">${recipe.description}</p>
                                <div class="mt-2 text-sm"><span>Cost: </span>${costString}</div>
                            </div>
                            <button id="craft-${id}" class="px-4 py-2 bg-blue-600 rounded-lg font-semibold hover:bg-blue-700 disabled:bg-gray-600 disabled:cursor-not-allowed transition-colors" ${!canCraft || buttonState ? 'disabled' : ''}>
                                ${buttonState || 'Craft'}
                            </button>
                        </div>
                    </div>`;
            }
            for (const id in RECIPES) {
                const btn = document.getElementById(`craft-${id}`);
                if (btn) btn.addEventListener('click', () => {
                    const recipe = RECIPES[id];
                    if (Object.entries(recipe.cost).every(([res, cost]) => player.resources[res] >= cost)) {
                        if (recipe.craft(player)) {
                            Object.entries(recipe.cost).forEach(([res, cost]) => player.resources[res] -= cost);
                            showMessage(`${recipe.name} crafted!`);
                            updateCraftingMenu();
                        } else {
                            showMessage(`Already have a ${recipe.name}.`);
                        }
                    }
                });
            }
        }
        
        class Particle {
            constructor(x, y) { this.x = x; this.y = y; this.life = 1; this.size = Math.random() * 2 + 1; this.vx = (Math.random() - 0.5) * 0.5; this.vy = -Math.random() * 0.5; }
            update() { this.x += this.vx; this.y += this.vy; this.life -= 0.05; }
        }

        // =================================================================================
        // GAME LOOP AND INPUT HANDLING
        // =================================================================================
        function gameLoop(timestamp) {
            requestAnimationFrame(gameLoop);
            if (isGamePaused) return;
            const deltaTime = (timestamp - lastFrameTime) / 1000 || 0;
            lastFrameTime = timestamp;

            if (!isGamePaused) {
                const oldTimeOfDay = timeOfDay;
                timeOfDay += deltaTime * 0.01;
                if (timeOfDay >= 1) timeOfDay = 0;
                if (Math.floor(oldTimeOfDay * 100) !== Math.floor(timeOfDay * 100)) {
                    chunkCache.clear();
                }
                updateCircularSliderUI(timeOfDay);
            }

            if (timestamp - lastFpsUpdateTime > 100) {
                const fps = 1 / deltaTime;
                fpsHistory.push(fps); if (fpsHistory.length > 60) fpsHistory.shift();
                minFps = Math.min(minFps, fps); maxFps = Math.max(maxFps, fps);
                DOMElements.currentFps.textContent = Math.round(fps); DOMElements.minFps.textContent = Math.round(minFps); DOMElements.maxFps.textContent = Math.round(maxFps);
            }
            
            if (!player.hasShelter) player.thirst -= 0.5 * deltaTime;
            if (player.thirst <= 0) { player.thirst = 0; showMessage("You died of thirst. Refresh to restart."); isGamePaused = true; }
            
            const sliders = getSliderValues();
            let moveX = 0, moveY = 0;
            if (keys['w'] || keys['arrowup']) moveY -= 1; if (keys['s'] || keys['arrowdown']) moveY += 1;
            if (keys['a'] || keys['arrowleft']) moveX -= 1; if (keys['d'] || keys['arrowright']) moveX += 1;
            
            const mag = Math.hypot(moveX, moveY);
            if (mag > 0) { moveX /= mag; moveY /= mag; }
            
            const currentBiome = getBiomeAtWorldCoords(Math.round(player.x), Math.round(player.y), perlin, sliders);
            const speedModifier = getMovementSpeedModifier(currentBiome, player.equippedTool);
            
            player.x += moveX * sliders.playerSpeed * deltaTime * 10 * speedModifier;
            player.y += moveY * sliders.playerSpeed * deltaTime * 10 * speedModifier;

            if (player.inventory.boat > 0 && (currentBiome.includes('Water') || currentBiome === 'river') && player.equippedTool !== 'boat') player.equippedTool = 'boat';
            else if (player.equippedTool === 'boat' && !currentBiome.includes('Water') && currentBiome !== 'river') player.equippedTool = null;

            if (player.equippedTool === 'boat') playerEmojiSpan.textContent = '⛵';
            else if (player.equippedTool) playerEmojiSpan.textContent = `🚶${RECIPES[player.equippedTool].emoji}`;
            else playerEmojiSpan.textContent = '🚶';

            if (moveX > 0) playerEmojiSpan.style.transform = 'scaleX(-1)';
            else if (moveX < 0) playerEmojiSpan.style.transform = 'scaleX(1)';

            const { visibleTrees, visibleFish } = drawWorld();
            drawMinimap();
            updateHUD(currentBiome, visibleTrees, visibleFish);
        }
        
        function performInteraction(worldX, worldY) {
            if (isGenerating || isGamePaused || player.thirst <= 0 || !perlin) return;
            const chunkX = Math.floor(worldX / CHUNK_SIZE), chunkY = Math.floor(worldY / CHUNK_SIZE);
            const chunk = chunkCache.get(`${chunkX},${chunkY}`);
            
            if (chunk) {
                const objIndex = chunk.objects.findIndex(obj => obj.x === worldX && obj.y === worldY);
                if (objIndex !== -1) {
                    const object = chunk.objects.splice(objIndex, 1)[0];
                    if (object.type === 'fish') {
                        player.resources.fish[object.name] = (player.resources.fish[object.name] || 0) + 1;
                        showMessage(`Caught a ${object.name}! ${object.emoji}`);
                    } else if (object.type === 'tree') {
                        const amount = player.equippedTool === 'axe' ? 2 : 1;
                        player.resources.wood += amount;
                        showMessage(`Gathered ${amount} wood! 🪵`);
                    }
                    for(let i=0; i<5; i++) particles.push(new Particle(worldX, worldY));
                    return;
                }
            }
            
            const sliders = getSliderValues();
            const biome = getBiomeAtWorldCoords(worldX, worldY, perlin, sliders);
            if (biome.includes('Water') || biome === 'river') {
                 player.resources.water += 1; player.thirst = Math.min(100, player.thirst + 10);
                 showMessage("Collected water & drank! 💧");
            } else if (['mountain', 'desertHills', 'badlandsHills', 'snowyMountains'].includes(biome)) {
                 const amount = player.equippedTool === 'pickaxe' ? 2 : 1;
                 player.resources.stone += amount;
                 showMessage(`Gathered ${amount} stone! 🪨`);
            } else {
                showMessage("Nothing to gather here.");
            }
            for(let i=0; i<5; i++) particles.push(new Particle(worldX, worldY));
        }

        // =================================================================================
        // EVENT HANDLERS
        // =================================================================================
        function handleGenerate(isSeedChange = false) {
            if (isGenerating) return;
            DOMElements.loading.classList.remove('hidden'); isGenerating = true;
            setTimeout(() => {
                if(isSeedChange) {
                    rawNoiseCache.clear();
                    generatePerlinMaps();
                }
                chunkCache.clear();
                drawWorld(); drawMinimap();
                DOMElements.loading.classList.add('hidden'); isGenerating = false;
                minFps = Infinity; maxFps = 0; fpsHistory.length = 0;
            }, 10);
        }
        
        function handleLoadAndResize() {
            canvas.width = viewport.clientWidth; canvas.height = viewport.clientHeight;
            if (DOMElements.fpsGraph) {
                DOMElements.fpsGraph.width = DOMElements.fpsGraph.clientWidth; DOMElements.fpsGraph.height = DOMElements.fpsGraph.clientHeight;
            }
            if (!isGenerating && perlin) { drawWorld(); drawMinimap(); }
        }

        function handleTimeSliderInteraction(event) {
            event.preventDefault();
            const rect = DOMElements.timeSliderContainer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2, centerY = rect.top + rect.height / 2;
            
            let wasPaused = isGamePaused;
            isGamePaused = true;

            function onMove(moveEvent) {
                const clientX = moveEvent.touches ? moveEvent.touches[0].clientX : moveEvent.clientX;
                const clientY = moveEvent.touches ? moveEvent.touches[0].clientY : moveEvent.clientY;
                const angleRad = Math.atan2(clientY - centerY, clientX - centerX) + Math.PI / 2;
                let angleDeg = angleRad * 180 / Math.PI;
                if (angleDeg < 0) angleDeg += 360;
                timeOfDay = angleDeg / 360;
                updateCircularSliderUI(timeOfDay);
                chunkCache.clear();
                drawWorld();
            }
            function onEnd() { 
                window.removeEventListener('mousemove', onMove); window.removeEventListener('mouseup', onEnd);
                window.removeEventListener('touchmove', onMove); window.removeEventListener('touchend', onEnd);
                isGamePaused = wasPaused;
            }
            window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onEnd);
            window.addEventListener('touchmove', onMove); window.addEventListener('touchend', onEnd);
            onMove(event);
        }

        function updateCircularSliderUI(time) {
            const angle = time * 360;
            const r = 40, cx = 50, cy = 50;
            const handlePos = { x: cx + (r * Math.cos((angle - 90) * Math.PI / 180)), y: cy + (r * Math.sin((angle - 90) * Math.PI / 180)) };
            DOMElements.timeSliderHandle.setAttribute('cx', handlePos.x); DOMElements.timeSliderHandle.setAttribute('cy', handlePos.y);
            const endAngle = angle >= 359.99 ? 359.99 : angle;
            const start = { x: cx + (r * Math.cos((endAngle - 90) * Math.PI / 180)), y: cy + (r * Math.sin((endAngle - 90) * Math.PI / 180)) };
            const end = { x: cx + (r * Math.cos((-90) * Math.PI / 180)), y: cy + (r * Math.sin((-90) * Math.PI / 180)) };
            const largeArcFlag = endAngle <= 180 ? "0" : "1";
            DOMElements.timeSliderProgress.setAttribute('d', `M ${end.x} ${end.y} A ${r} ${r} 0 ${largeArcFlag} 1 ${start.x} ${start.y}`);
        }

        function setupMobileControls() {
            if (!('ontouchstart' in window)) return;
            DOMElements.mobileControls.classList.remove('hidden');
            let joystickTouchId = null;
            DOMElements.joystick.addEventListener('touchstart', (e) => { if (joystickTouchId === null) joystickTouchId = e.changedTouches[0].identifier; }, { passive: true });
            window.addEventListener('touchmove', (e) => {
                for (let touch of e.changedTouches) {
                    if (touch.identifier === joystickTouchId) {
                        const rect = DOMElements.joystick.getBoundingClientRect(), size = rect.width, handleSize = DOMElements.joystickHandle.clientWidth, maxDist = (size - handleSize) / 2;
                        let dx = touch.clientX - (rect.left + size / 2), dy = touch.clientY - (rect.top + size / 2);
                        const dist = Math.hypot(dx, dy);
                        if (dist > maxDist) { dx = (dx / dist) * maxDist; dy = (dy / dist) * maxDist; }
                        DOMElements.joystickHandle.style.transform = `translate(-50%, -50%) translate(${dx}px, ${dy}px)`;
                        keys['w'] = dy / maxDist < -0.2; keys['s'] = dy / maxDist > 0.2; keys['a'] = dx / maxDist < -0.2; keys['d'] = dx / maxDist > 0.2;
                        break;
                    }
                }
            }, { passive: true });
            window.addEventListener('touchend', (e) => {
                 for (let touch of e.changedTouches) {
                     if (touch.identifier === joystickTouchId) {
                         joystickTouchId = null; DOMElements.joystickHandle.style.transform = `translate(-50%, -50%)`;
                         keys['w'] = keys['s'] = keys['a'] = keys['d'] = false; break;
                     }
                 }
            });
            DOMElements.actionButton.addEventListener('touchstart', (e) => { e.preventDefault(); performInteraction(Math.round(player.x), Math.round(player.y)); });
        }

        window.onload = () => {
            DOMElements = {
                canvas: document.getElementById('canvas'),
                viewport: document.getElementById('viewport'),
                loading: document.getElementById('loading'),
                player: document.getElementById('player'),
                playerEmoji: document.getElementById('player-emoji'),
                thirstText: document.getElementById('thirstText'),
                thirstFill: document.getElementById('thirstFill'),
                speedModifierText: document.getElementById('speedModifierText'),
                toolText: document.getElementById('toolText'),
                posText: document.getElementById('posText'),
                biomeText: document.getElementById('biomeText'),
                shelterStatus: document.getElementById('shelterStatus'),
                timeText: document.getElementById('timeText'),
                treeCountText: document.getElementById('treeCountText'),
                fishCountText: document.getElementById('fishCountText'),
                keysText: document.getElementById('keysText'),
                woodCount: document.getElementById('woodCount'),
                stoneCount: document.getElementById('stoneCount'),
                waterCount: document.getElementById('waterCount'),
                fishCounts: document.getElementById('fishCounts'),
                currentFps: document.getElementById('currentFps'),
                minFps: document.getElementById('minFps'),
                maxFps: document.getElementById('maxFps'),
                messageBox: document.getElementById('messageBox'),
                messageText: document.getElementById('messageText'),
                settingsMenu: document.getElementById('settingsMenu'),
                seedInput: document.getElementById('seedInput'),
                heightScaleSlider: document.getElementById('heightScaleSlider'),
                heightScaleValue: document.getElementById('heightScaleValue'),
                moistureScaleSlider: document.getElementById('moistureScaleSlider'),
                moistureScaleValue: document.getElementById('moistureScaleValue'),
                pixelScaleSlider: document.getElementById('pixelScaleSlider'),
                pixelScaleValue: document.getElementById('pixelScaleValue'),
                persistenceSlider: document.getElementById('persistenceSlider'),
                persistenceValue: document.getElementById('persistenceValue'),
                playerSpeedSlider: document.getElementById('playerSpeedSlider'),
                playerSpeedValue: document.getElementById('playerSpeedValue'),
                waterLevelSlider: document.getElementById('waterLevelSlider'),
                waterLevelValue: document.getElementById('waterLevelValue'),
                treeDensitySlider: document.getElementById('treeDensitySlider'),
                treeDensityValue: document.getElementById('treeDensityValue'),
                fishDensitySlider: document.getElementById('fishDensitySlider'),
                fishDensityValue: document.getElementById('fishDensityValue'),
                craftingMenu: document.getElementById('craftingMenu'),
                craftingRecipes: document.getElementById('craftingRecipes'),
                timeSliderContainer: document.getElementById('timeSliderContainer'),
                timeSliderProgress: document.getElementById('timeSliderProgress'),
                timeSliderHandle: document.getElementById('timeSliderHandle'),
                mobileControls: document.getElementById('mobileControls'),
                joystick: document.getElementById('joystick'),
                joystickHandle: document.getElementById('joystickHandle'),
                actionButton: document.getElementById('actionButton'),
            };

            ({ canvas, viewport, player: playerDiv, playerEmoji: playerEmojiSpan, seedInput } = DOMElements);
            ctx = canvas.getContext('2d');
            sliders = {
                heightScale: { slider: DOMElements.heightScaleSlider, span: DOMElements.heightScaleValue },
                moistureScale: { slider: DOMElements.moistureScaleSlider, span: DOMElements.moistureScaleValue },
                persistence: { slider: DOMElements.persistenceSlider, span: DOMElements.persistenceValue },
                waterLevel: { slider: DOMElements.waterLevelSlider, span: DOMElements.waterLevelValue },
                treeDensity: { slider: DOMElements.treeDensitySlider, span: DOMElements.treeDensityValue, suffix: 'x', fixed: 1 },
                fishDensity: { slider: DOMElements.fishDensitySlider, span: DOMElements.fishDensityValue, suffix: 'x', fixed: 1 },
                pixelScale: { slider: DOMElements.pixelScaleSlider, span: DOMElements.pixelScaleValue, regen: false },
                playerSpeed: { slider: DOMElements.playerSpeedSlider, span: DOMElements.playerSpeedValue, regen: false },
            };

            window.addEventListener('resize', handleLoadAndResize);
            seedInput.addEventListener('change', () => handleGenerate(true));
            for (const key in sliders) {
                const { slider, span, regen = true, suffix = '', fixed = 0 } = sliders[key];
                slider.addEventListener('input', () => {
                    span.textContent = `${parseFloat(slider.value).toFixed(fixed)}${suffix}`;
                    if (regen) handleGenerate(false);
                    else if (key === 'pixelScale' && !isGenerating) drawWorld();
                });
            }
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const slider = sliders.pixelScale.slider;
                let newPixelScale = parseInt(slider.value) - Math.sign(e.deltaY);
                slider.value = Math.max(1, Math.min(24, newPixelScale));
                sliders.pixelScale.span.textContent = slider.value;
                if (!isGenerating) drawWorld();
            });
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT') return;
                const menuMap = { 'c': DOMElements.craftingMenu, 'Escape': DOMElements.settingsMenu };
                const key = e.key.toLowerCase() === 'escape' ? 'Escape' : e.key.toLowerCase();
                if (menuMap[key]) {
                    Object.values(menuMap).forEach(m => { if (m !== menuMap[key]) m.classList.add('hidden'); });
                    menuMap[key].classList.toggle('hidden');
                    if (key === 'c' && !menuMap.c.classList.contains('hidden')) updateCraftingMenu();
                } else if (key === 'p') { isDebugViewActive = !isDebugViewActive; chunkCache.clear(); }
                isGamePaused = Object.values(menuMap).some(m => !m.classList.contains('hidden'));
                document.body.style.cursor = isGamePaused ? 'default' : `url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='40' height='48' viewport='0 0 100 100' style='font-size:24px;'><text y='50%'>🖐️</text></svg>") 16 24, auto`;
                keys[e.key.toLowerCase()] = true;
            });
            document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
            canvas.addEventListener('click', (e) => {
                const pixelScale = parseInt(sliders.pixelScale.slider.value);
                const rect = canvas.getBoundingClientRect();
                const worldX = Math.floor((player.x - (viewport.clientWidth / pixelScale) / 2) + (e.clientX - rect.left) / pixelScale);
                const worldY = Math.floor((player.y - (viewport.clientHeight / pixelScale) / 2) + (e.clientY - rect.top) / pixelScale);
                performInteraction(worldX, worldY);
            });

            DOMElements.timeSliderContainer.addEventListener('mousedown', handleTimeSliderInteraction);
            DOMElements.timeSliderContainer.addEventListener('touchstart', handleTimeSliderInteraction);
            
            generatePerlinMaps();
            handleLoadAndResize();
            setupMobileControls();
            updateCircularSliderUI(timeOfDay);
            gameLoop(0); 
        };
    </script>
</body>
</html>

