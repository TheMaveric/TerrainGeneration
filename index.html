<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Procedural World Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            cursor: crosshair;
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #1a202c;
        }

        #viewport {
            position: relative;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #canvas {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        #player {
            position: absolute;
            width: 8px;
            height: 8px;
            transform: translate(-50%, -50%);
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: transform 0.1s linear;
        }

        .pixelated {
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .bubble-effect {
            animation: bubble 0.5s ease-out;
        }

        @keyframes bubble {
            0% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.2);
                opacity: 0.8;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        #mobileControls {
            pointer-events: none;
            /* Let clicks pass through the container */
        }

        #joystick {
            pointer-events: auto;
            /* But not the controls themselves */
        }

        #timeSliderContainer {
            cursor: pointer;
        }

        #timeSliderContainer svg * {
            pointer-events: none;
            /* Allow events to be captured by the container */
        }

        /* For Webkit-based browsers (Chrome, Safari) */
        .controls::-webkit-scrollbar {
            width: 8px;
        }

        .controls::-webkit-scrollbar-track {
            background: #2d3748;
            /* bg-gray-700 */
        }

        .controls::-webkit-scrollbar-thumb {
            background: #4a5568;
            /* bg-gray-600 */
            border-radius: 4px;
        }

        /* Collapsible Panels */
        .collapsible-hud.collapsed {
            width: 48px;
            padding-top: 1rem;
            padding-bottom: 1rem;
        }

        .collapsible-hud.collapsed .controls,
        .collapsible-hud.collapsed .controls-footer {
            display: none;
        }

        .collapsible-hud.collapsed .title-bar {
            flex-direction: column-reverse;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0;
        }

        .collapsible-hud.collapsed h3 {
            writing-mode: vertical-rl;
            transform: rotate(180deg);
            margin: 0;
            padding: 0;
            line-height: 1;
        }

        .collapsible-hud.collapsed .toggle-icon {
            transform: rotate(180deg);
        }
    </style>
</head>

<body class="bg-gray-900 text-gray-200">

    <div id="viewport">
        <canvas id="canvas" class="pixelated"></canvas>
        <div id="player">
            <span id="player-emoji" class="text-lg">üö∂</span>
        </div>
        <div id="loading"
            class="absolute inset-0 flex items-center justify-center bg-gray-800 bg-opacity-75 z-50 transition-opacity duration-300 hidden">
            <svg class="animate-spin h-8 w-8 text-white" xmlns="http://www.w3.org/2000/svg" fill="none"
                viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor"
                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                </path>
            </svg>
        </div>
        <div class="absolute top-4 left-4 p-3 bg-gray-800 bg-opacity-75 rounded-lg shadow-md z-20 max-w-xs">
            <div class="flex flex-col gap-2 text-sm font-semibold">
                <div class="flex justify-between items-center text-sm font-semibold">
                    <span>‚ö° Speed:</span>
                    <span id="speedModifierText">1x</span>
                </div>
                <div class="flex flex-col mt-2">
                    <div class="flex justify-between items-center">
                        <span>üó∫Ô∏è Pos:</span>
                        <span id="posText">0, 0</span>
                    </div>
                    <div class="flex justify-between items-center">
                        <span>üå≤ Biome:</span>
                        <span id="biomeText">...</span>
                    </div>
                    <div class="flex justify-between items-center mt-1">
                        <span>‚òÄÔ∏è Time:</span>
                        <span id="timeText">...</span>
                    </div>
                    <div
                        class="flex justify-between items-center text-xs text-gray-400 pt-1 border-t border-gray-700 mt-1">
                        <span>Visible Trees:</span>
                        <span id="treeCountText">0</span>
                    </div>
                    <div class="flex justify-between items-center text-xs text-gray-400">
                        <span>Visible Fish:</span>
                        <span id="fishCountText">0</span>
                    </div>
                    <div class="flex justify-between items-center mt-1">
                        <span>‚å®Ô∏è Keys:</span>
                        <span id="keysText">...</span>
                    </div>
                    <div
                        class="flex justify-between items-center text-xs text-gray-400 pt-1 border-t border-gray-700 mt-1">
                        <span>FPS:</span>
                        <span id="currentFps" class="font-mono">--</span>
                    </div>
                    <div class="flex justify-between items-center text-xs text-gray-400">
                        <span>Min/Max:</span>
                        <span class="font-mono"><span id="minFps">--</span>/<span id="maxFps">--</span></span>
                    </div>
                    <div
                        class="flex justify-between items-center text-xs text-gray-400 pt-1 border-t border-gray-700 mt-1">
                        <span>'H' - Contours:</span>
                        <span id="contourStatus" class="font-semibold text-red-400">Off</span>
                    </div>
                </div>
            </div>
        </div>
        <div class="absolute top-4 right-4 p-3 bg-gray-800 bg-opacity-75 rounded-lg shadow-md z-20 max-w-xs">
            <h3 class="text-lg font-bold text-center mb-2 text-white">Fish
                Log</h3>
            <div id="fishLog" class="flex flex-col gap-1 mt-2 border-t border-gray-700 pt-2">
            </div>
        </div>
        <div id="messageBox" class="absolute top-24 right-4 flex justify-center z-40">
            <div id="messageText" class="p-3 bg-gray-700 text-white rounded-lg shadow-md hidden text-center w-auto">
            </div>
        </div>

        <div class="absolute bottom-4 left-4 z-40">
            <div class="w-48 h-48 bg-gray-800 border-2 border-gray-600 rounded-lg overflow-hidden relative">
                <canvas id="minimapCanvas" class="w-full h-full pixelated"></canvas>
                <div id="minimapPlayer" class="absolute w-2 h-2 bg-red-500 rounded-full"
                    style="left: 50%; top: 50%; transform: translate(-50%, -50%);"></div>
            </div>
        </div>

        <div id="timeSliderContainer" class="absolute bottom-4 right-4 z-40 w-32 h-32">
            <svg viewBox="0 0 100 100">
                <circle cx="50" cy="50" r="40" class="stroke-gray-700" stroke-width="8" fill="rgba(31, 41, 55, 0.7)">
                </circle>
                <path id="timeSliderProgress" class="stroke-yellow-400" stroke-width="8" fill="none"
                    stroke-linecap="round"></path>
                <text x="50" y="15" text-anchor="middle" font-size="14">üïõ</text> <text x="88" y="55"
                    text-anchor="middle" font-size="14">‚òÄÔ∏è</text> <text x="50" y="95" text-anchor="middle"
                    font-size="14">üïï</text> <text x="12" y="55" text-anchor="middle" font-size="14">üåô</text>
                <circle id="timeSliderHandle" cx="50" cy="10" r="6" class="fill-white"></circle>
            </svg>
        </div>

        <div id="settingsHud"
            class="absolute top-1/2 right-4 -translate-y-1/2 bg-gray-800 bg-opacity-90 p-4 rounded-lg shadow-lg z-40 w-64 max-h-[80vh] overflow-y-auto transition-all duration-300 collapsed collapsible-hud">
            <div class="flex justify-between items-center mb-4 title-bar">
                <h3 class="text-lg font-bold text-white transition-all duration-300">World
                    Settings</h3>
                <button id="toggleSettings" class="text-white p-1 rounded-full hover:bg-gray-700">
                    <svg class="w-6 h-6 transition-transform duration-300 toggle-icon" fill="none" stroke="currentColor"
                        viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7">
                        </path>
                    </svg>
                </button>
            </div>
            <div class="controls w-full grid grid-cols-1 gap-4 pr-2">
                <div class="flex flex-col items-center">
                    <label for="seedInput" class="text-sm font-semibold mb-2 text-gray-300">Seed</label>
                    <input type="text" id="seedInput" placeholder="Enter a number"
                        class="w-full text-center bg-gray-700 rounded-lg py-2 px-3 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500 text-white">
                </div>
                <div class="flex flex-col items-center">
                    <label for="heightScaleSlider" class="text-sm font-semibold mb-2 text-gray-300">Height
                        Scale: <span id="heightScaleValue">50</span></label>
                    <input type="range" id="heightScaleSlider" min="20" max="150" value="50"
                        class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
                </div>
                <div class="flex flex-col items-center">
                    <label for="moistureScaleSlider" class="text-sm font-semibold mb-2 text-gray-300">Moisture
                        Scale: <span id="moistureScaleValue">80</span></label>
                    <input type="range" id="moistureScaleSlider" min="20" max="150" value="80"
                        class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
                </div>
                <div class="flex flex-col items-center">
                    <label for="climateContrastSlider" class="text-sm font-semibold mb-2 text-gray-300">Climate
                        Contrast: <span id="climateContrastValue">1.5</span></label>
                    <input type="range" id="climateContrastSlider" min="1.0" max="3.0" step="0.1" value="1.5"
                        class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
                </div>
                <div class="flex flex-col items-center">
                    <label for="pixelScaleSlider" class="text-sm font-semibold mb-2 text-gray-300">Pixel
                        Scale: <span id="pixelScaleValue">12</span></label>
                    <input type="range" id="pixelScaleSlider" min="1" max="24" value="12"
                        class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
                </div>
                <div class="flex flex-col items-center">
                    <label for="persistenceSlider" class="text-sm font-semibold mb-2 text-gray-300">Persistence:
                        <span id="persistenceValue">0.5</span></label>
                    <input type="range" id="persistenceSlider" min="0.1" max="1" step="0.05" value="0.5"
                        class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
                </div>
                <div class="flex flex-col items-center">
                    <label for="playerSpeedSlider" class="text-sm font-semibold mb-2 text-gray-300">Player
                        Speed: <span id="playerSpeedValue">2</span></label>
                    <input type="range" id="playerSpeedSlider" min="0.5" max="5" step="0.5" value="2"
                        class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
                </div>
                <div class="flex flex-col items-center">
                    <label for="waterLevelSlider" class="text-sm font-semibold mb-2 text-gray-300">Water
                        Level: <span id="waterLevelValue">0.45</span></label>
                    <input type="range" id="waterLevelSlider" min="0.0" max="1.0" step="0.05" value="0.45"
                        class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
                </div>
                <div class="flex flex-col items-center">
                    <label for="treeDensitySlider" class="text-sm font-semibold mb-2 text-gray-300">Tree
                        Density: <span id="treeDensityValue">1.0</span>x</label>
                    <input type="range" id="treeDensitySlider" min="0.2" max="2.0" step="0.1" value="1.0"
                        class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
                </div>
                <div class="flex flex-col items-center">
                    <label for="fishDensitySlider" class="text-sm font-semibold mb-2 text-gray-300">Fish
                        Density: <span id="fishDensityValue">1.0</span>x</label>
                    <input type="range" id="fishDensitySlider" min="0.0" max="3.0" step="0.1" value="1.0"
                        class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
                </div>
                <div class="flex flex-col items-center">
                    <label for="mapScaleSlider" class="text-sm font-semibold mb-2 text-gray-300">Map
                        Scale: <span id="mapScaleValue">0.10</span></label>
                    <input type="range" id="mapScaleSlider" min="0.1" max="2.0" step="0.05" value="0.1"
                        class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
                </div>
            </div>
            <p class="text-xs text-center text-gray-400 mt-4 controls-footer">Changes
                are applied live.</p>
        </div>

        <div id="legendHud"
            class="absolute bottom-56 left-4 bg-gray-800 bg-opacity-90 p-4 rounded-lg shadow-lg z-30 w-64 max-h-[40vh] overflow-y-auto transition-all duration-300 collapsed collapsible-hud">
            <div class="flex justify-between items-center mb-4 title-bar">
                <h3 class="text-lg font-bold text-white transition-all duration-300">Biome
                    Legend</h3>
                <button id="toggleLegend" class="text-white p-1 rounded-full hover:bg-gray-700">
                    <svg class="w-6 h-6 transition-transform duration-300 toggle-icon" fill="none" stroke="currentColor"
                        viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7">
                        </path>
                    </svg>
                </button>
            </div>
            <div id="legendEntries" class="controls w-full flex flex-col gap-2 pr-2 text-sm">
                <!-- Entries will be generated by JS -->
            </div>
        </div>

        <div id="mobileControls" class="fixed bottom-0 left-0 right-0 p-8 flex justify-between items-end z-40 hidden">
            <div id="joystick" class="w-32 h-32 bg-gray-500 bg-opacity-30 rounded-full relative">
                <div id="joystickHandle"
                    class="w-16 h-16 bg-gray-400 bg-opacity-50 rounded-full absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2">
                </div>
            </div>
        </div>
    </div>

    <script>
        // =================================================================================
        // CORE NOISE AND MATH FUNCTIONS
        // =================================================================================
        const TREE_TYPES = {
            'oak': { emoji: 'üå≥', biomes: ['forest', 'forestHills', 'plain'], minHeight: 1, maxHeight: 4 },
            'pine': { emoji: 'üå≤', biomes: ['taiga', 'taigaHills', 'taigaMountains', 'snowyTaiga', 'snowyTaigaHills', 'snowyTaigaMountains', 'mountain'], minHeight: 2, maxHeight: 6 },
            'jungle': { emoji: 'üå¥', biomes: ['jungle', 'jungleHills', 'beach'], minHeight: 3, maxHeight: 7 },
            'acacia': { emoji: 'üå≥', biomes: ['savanna', 'savannaPlateau'], minHeight: 2, maxHeight: 5 }, // Using oak emoji as a stand-in
            'swamp': { emoji: 'üå≥', biomes: ['swamp', 'swampHills'], minHeight: 1, maxHeight: 3 } // Using oak emoji as a stand-in
        };

        const FISH_TYPES = {
            // Common
            'cod': { emoji: 'üêü', biomes: ['deepWater', 'shallowWater'], rarity: 0.5 },
            'salmon': { emoji: 'üê†', biomes: ['river', 'lowlandRiver', 'mountainRiver', 'deltaRiver', 'shallowWater'], rarity: 0.4 },
            // Temperate
            'trout': { emoji: 'üêü', biomes: ['river', 'mountainRiver'], rarity: 0.3 },
            'mackerel': { emoji: 'üé£', biomes: ['shallowWater'], rarity: 0.2 },
            // Tropical
            'clownfish': { emoji: 'üê†', biomes: ['shallowWater', 'jungle'], rarity: 0.2 },
            'pufferfish': { emoji: 'üê°', biomes: ['jungle', 'swamp', 'shallowWater'], rarity: 0.15 },
            'piranha': { emoji: 'üêü', biomes: ['river', 'marshRiver', 'swamp'], rarity: 0.1 },
            // Cold
            'arctic char': { emoji: 'üêü', biomes: ['frozenDeepWater', 'frozenShallowWater', 'frozenRiver'], rarity: 0.4 },
            'icefish': { emoji: 'üßä', biomes: ['frozenDeepWater', 'frozenRiver'], rarity: 0.2 },
            // Swamp/Murky
            'catfish': { emoji: 'üé£', biomes: ['swamp', 'river', 'marshRiver', 'lowlandRiver', 'deltaRiver'], rarity: 0.3 },
            // Deep Ocean
            'tuna': { emoji: 'üêü', biomes: ['deepWater'], rarity: 0.2 },
            'swordfish': { emoji: 'üó°Ô∏è', biomes: ['deepWater'], rarity: 0.1 },
            'anglerfish': { emoji: 'üí°', biomes: ['deepWater'], rarity: 0.05 },
        };

        function seededRandom(seed) {
            let state = Math.sin(seed) * 10000;
            return function () {
                state = (state * 9301 + 49297) % 233280;
                return state / 233280;
            };
        }

        class PerlinNoise {
            constructor(seed) {
                const random = seededRandom(seed);
                this.p = new Array(512);
                const permutation = new Array(256);
                for (let i = 0; i < 256; i++) { permutation[i] = i; }
                for (let i = 0; i < 255; i++) {
                    const j = Math.floor(random() * (256 - i)) + i;
                    [permutation[i], permutation[j]] = [permutation[j], permutation[i]];
                }
                for (let i = 0; i < 256; i++) { this.p[i] = this.p[i + 256] = permutation[i]; }
            }
            noise(x, y) {
                const X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
                x -= Math.floor(x); y -= Math.floor(y);
                const u = this.fade(x), v = this.fade(y);
                const A = this.p[X] + Y, AA = this.p[A], AB = this.p[A + 1];
                const B = this.p[X + 1] + Y, BA = this.p[B], BB = this.p[B + 1];
                const res = this.lerp(v, this.lerp(u, this.grad(this.p[AA], x, y), this.grad(this.p[BA], x - 1, y)),
                    this.lerp(u, this.grad(this.p[AB], x, y - 1), this.grad(this.p[BB], x - 1, y - 1)));
                return (res + 1.0) / 2.0;
            }
            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(t, a, b) { return a + t * (b - a); }
            grad(hash, x, y) {
                const h = hash & 3;
                const u = h < 2 ? x : y, v = h < 2 ? y : x;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }
        }

        // =================================================================================
        // POISSON DISK SAMPLING FOR OBJECT PLACEMENT
        // =================================================================================
        const PoissonDisk = (() => {
            const GRID_CELL_SIZE = 4;
            const INV_CELL_SIZE = 1 / GRID_CELL_SIZE;
            const candidateCache = new Map();

            function getCandidate(cx, cy, perlin, sliders, seed, getRadiusFn) {
                const key = `${cx},${cy},${seed},${getRadiusFn.name},${sliders.treeDensityMultiplier},${sliders.fishDensityMultiplier}`;
                if (candidateCache.has(key)) return candidateCache.get(key);

                const cellRandom = seededRandom(cx * 9301 + cy * 49297 + seed);
                const pointX = (cx + cellRandom()) * GRID_CELL_SIZE;
                const pointY = (cy + cellRandom()) * GRID_CELL_SIZE;
                const biome = getBiomeAtWorldCoords(Math.round(pointX), Math.round(pointY), perlin, sliders);
                const radius = getRadiusFn(biome, sliders);

                const candidate = { x: pointX, y: pointY, r: radius, biome: biome };
                candidateCache.set(key, candidate);
                return candidate;
            }

            function generatePointsForChunk(chunkX, chunkY, perlin, sliders, seed, getRadiusFn, isValidBiomeFn, createObjectFn) {
                const points = [];
                const startX = chunkX * CHUNK_SIZE, startY = chunkY * CHUNK_SIZE;
                const endX = startX + CHUNK_SIZE, endY = startY + CHUNK_SIZE;

                const startCellX = Math.floor(startX * INV_CELL_SIZE), endCellX = Math.ceil(endX * INV_CELL_SIZE);
                const startCellY = Math.floor(startY * INV_CELL_SIZE), endCellY = Math.ceil(endY * INV_CELL_SIZE);

                for (let cy = startCellY; cy < endCellY; cy++) {
                    for (let cx = startCellX; cx < endCellX; cx++) {
                        const candidate = getCandidate(cx, cy, perlin, sliders, seed, getRadiusFn);

                        if (candidate.r === 0 || !isValidBiomeFn(candidate.biome) || candidate.x < startX || candidate.x >= endX || candidate.y < startY || candidate.y >= endY) continue;

                        let isValid = true;
                        const checkCellRadius = Math.ceil(candidate.r * INV_CELL_SIZE);

                        for (let j = -checkCellRadius; j <= checkCellRadius; j++) {
                            for (let i = -checkCellRadius; i <= checkCellRadius; i++) {
                                if (i === 0 && j === 0) continue;
                                const neighbor = getCandidate(cx + i, cy + j, perlin, sliders, seed, getRadiusFn);
                                if (neighbor.r === 0 || !isValidBiomeFn(neighbor.biome)) continue;

                                const distSq = (candidate.x - neighbor.x) ** 2 + (candidate.y - neighbor.y) ** 2;
                                if (distSq < neighbor.r * neighbor.r) {
                                    if (candidate.r < neighbor.r || (candidate.r === neighbor.r && (candidate.x > neighbor.x || (candidate.x === neighbor.x && candidate.y > neighbor.y)))) {
                                        isValid = false; break;
                                    }
                                }
                            }
                            if (!isValid) break;
                        }

                        if (isValid) {
                            points.push(createObjectFn(candidate));
                        }
                    }
                }
                return points;
            }

            function clearCache() { candidateCache.clear(); }

            return { generatePointsForChunk, clearCache };
        })();


        // =================================================================================
        // BIOME AND WORLD GENERATION
        // =================================================================================
        const BIOME_COLORS = {
            'deepWater': [20, 91, 134], 'shallowWater': [38, 166, 245], 'frozenDeepWater': [20, 123, 174],
            'frozenShallowWater': [37, 174, 255], 'beach': [255, 216, 122], 'snowyBeach': [250, 240, 191],
            'desert': [250, 148, 24], 'desertHills': [210, 95, 17], 'badlands': [217, 69, 21],
            'badlandsPlateau': [202, 140, 101], 'badlandsHills': [120, 25, 25], 'taiga': [10, 102, 89],
            'taigaHills': [22, 57, 51], 'taigaMountains': [51, 142, 129], 'snowyTaiga': [49, 85, 74],
            'snowyTaigaHills': [36, 63, 54], 'snowyTaigaMountains': [89, 125, 114], 'savanna': [189, 178, 95],
            'savannaPlateau': [167, 157, 100], 'jungle': [83, 123, 9], 'jungleHills': [44, 66, 4],
            'swamp': [48, 53, 40], 'swampHills': [31, 36, 24], 'plain': [141, 179, 96],
            'forest': [5, 102, 33], 'forestHills': [0, 66, 44], 'forestMountains': [0, 48, 31],
            'mountain': [96, 96, 96], 'snowyTundra': [255, 255, 255], 'snowyMountains': [160, 160, 160],
            'iceSpikes': [180, 220, 220], 'river': [37, 174, 255], 'frozenRiver': [180, 220, 255], 'marshRiver': [34, 120, 90],       // greenish, swampy
            'mountainRiver': [30, 140, 210],   // cooler blue
            'lowlandRiver': [37, 174, 255],    // keep bright
            'deltaRiver': [60, 170, 200],      // murky blue
        };

        function remapNoise(value, exponent) {
            return Math.pow(value, exponent);
        }

        function getOctaveNoise(x, y, perlin, scale, persistence, initialAmplitude = 1, mapScale = 1) {
            let total = 0, amplitude = initialAmplitude, frequency = 1, maxAmplitude = 0;
            for (let i = 0; i < 16; i++) { // Using 16 octaves to match Java code
                total += perlin.noise((x * mapScale) / scale * frequency, (y * mapScale) / scale * frequency) * amplitude;
                maxAmplitude += amplitude;
                amplitude *= persistence;
                frequency *= 2;
            }
            return total / maxAmplitude;
        }

        function getHeightValueAtWorldCoords(worldX, worldY, perlinHeight, heightScale, persistence, mapScale) {
            return getOctaveNoise(worldX, worldY, perlinHeight, heightScale, persistence, 10, mapScale);
        }

        function getBiomeFromValues(heightValue, moistureValue, temperatureValue, riverValue, sliders) {
            const { waterLevel } = sliders;
            const landHeight = (heightValue - waterLevel) / (1 - waterLevel);
            const h = heightValue < waterLevel ? (1 - (waterLevel - heightValue) / waterLevel) * 128 : 128 + landHeight * 127;
            const m = moistureValue * 255, t = temperatureValue * 255;

            // REPLACE your current river check with this block:
            if (h >= 132) {
                // dynamic river threshold
                let riverThreshold = 0.97;
                const nearSea = h < 140;                  // just inland of beaches
                const isMarshy = (m > 75 && t > 50);      // warm & wet
                const isArid = (t > 66 && m <= 25) || (t > 25 && t <= 66 && m <= 25);
                if (nearSea) riverThreshold -= 0.015;     // widen at mouths ‚Üí deltas
                if (isMarshy) riverThreshold -= 0.005;    // a bit more frequent in swamps/jungle
                if (isArid) riverThreshold += 0.015;     // harder in deserts/badlands
                if (riverValue > riverThreshold) {
                    if (t <= 25) return 'frozenRiver';    // cold beats other subtypes first
                    if (nearSea) return 'deltaRiver';
                    if (isMarshy) return 'marshRiver';
                    if (h > 200) return 'mountainRiver';
                    if (h < 150) return 'lowlandRiver';
                    return 'river';
                }
            }

            if (h < 110) return t <= 25 ? 'frozenDeepWater' : 'deepWater';
            if (h < 128) return t <= 25 ? 'frozenShallowWater' : 'shallowWater';
            if (h < 132) return t <= 25 ? 'snowyBeach' : 'beach';
            if (t <= 25 && m > 75) return 'iceSpikes';
            if (t <= 25 && m <= 50) return 'snowyTundra';
            if ((t > 25 && t <= 50 && m > 25 && m <= 75) || (t <= 25 && m > 50 && m <= 75)) {
                if (t < 25) {
                    if (h > 200) return 'snowyTaigaMountains';
                    if (h > 180) return 'snowyTaigaHills';
                    return 'snowyTaiga';
                } else {
                    if (h > 200) return 'taigaMountains';
                    if (h > 180) return 'taigaHills';
                    return 'taiga';
                }
            }
            if (t > 66 && m <= 25) return h > 180 ? 'desertHills' : 'desert';
            if (t > 25 && t <= 66 && m <= 25) return h > 180 ? 'badlandsHills' : 'badlands';
            if ((t > 66 && m > 75) || (m > 50 && t > 50 && t <= 66)) return h > 180 ? 'jungleHills' : 'jungle';
            if (t > 66 && m <= 75 && m > 50) {
                if (h > 220) return 'forestMountains';
                if (h > 180) return 'forestHills';
                return 'forest';
            }
            if (t > 75 && m <= 50 && m > 25) return h > 180 ? 'savannaPlateau' : 'savanna';
            if (t > 50 && t <= 75 && m > 25 && m <= 50) return h > 200 ? 'mountain' : 'plain';
            return 'swamp';
        }

        function getBiomeAtWorldCoords(worldX, worldY, perlin, sliders) {
            const heightValue = getHeightValueAtWorldCoords(worldX, worldY, perlin.height, sliders.heightScale, sliders.persistence, sliders.mapScale);
            let moistureValue = getOctaveNoise(worldX, worldY, perlin.moisture, sliders.moistureScale, sliders.persistence, 10, sliders.mapScale);
            let temperatureValue = getOctaveNoise(worldX, worldY, perlin.temperature, 150, sliders.persistence, 10, sliders.mapScale);

            moistureValue = remapNoise(moistureValue, sliders.climateContrast);
            temperatureValue = remapNoise(temperatureValue, sliders.climateContrast);

            const rawRiverNoise = getOctaveNoise(worldX, worldY, perlin.river, 40, sliders.persistence, 10, sliders.mapScale);
            const riverValue = 1 - Math.abs(rawRiverNoise * 2 - 1);
            return getBiomeFromValues(heightValue, moistureValue, temperatureValue, riverValue, sliders);
        }

        function getAbsoluteHeight(worldX, worldY, perlin, sliders, cache) {
            const key = `${worldX},${worldY}`;
            if (cache && cache.has(key)) return cache.get(key);

            const { waterLevel } = sliders;
            const heightValue = getHeightValueAtWorldCoords(worldX, worldY, perlin.height, sliders.heightScale, sliders.persistence, sliders.mapScale);
            const landHeight = (heightValue - waterLevel) / (1 - waterLevel);
            const h = heightValue < waterLevel ? (1 - (waterLevel - heightValue) / waterLevel) * 128 : 128 + landHeight * 127;

            if (cache) cache.set(key, h);
            return h;
        }

        function getMovementSpeedModifier(biome) {
            switch (biome) {
                case 'deepWater': case 'frozenDeepWater': return 0.4;
                case 'shallowWater': case 'frozenShallowWater': return 0.6;
                case 'jungle': case 'jungleHills': case 'swamp': case 'swampHills': return 0.7;
                case 'snowyMountains': case 'taigaMountains': case 'snowyTaigaMountains': case 'mountain': case 'forestMountains': return 0.5;
                // rivers now set per-pixel in draw using a dynamic override; keep a safe default:
                case 'frozenRiver': return 0.3;
                case 'marshRiver': return 0.35;
                case 'mountainRiver': return 0.45;
                case 'lowlandRiver': return 0.4;
                case 'deltaRiver': return 0.4;
                default: return 1.0;
            }
        }


        function getPixelLightness(x, y, heightValue, perlinHeight, sliders, sunVector) {
            const { heightScale, persistence, mapScale } = sliders;
            const h_x1 = getHeightValueAtWorldCoords(x + 1, y, perlinHeight, heightScale, persistence, mapScale);
            const h_y1 = getHeightValueAtWorldCoords(x, y + 1, perlinHeight, heightScale, persistence, mapScale);
            const normalX = ((heightValue - h_x1) * 20) / mapScale;
            const normalY = ((heightValue - h_y1) * 20) / mapScale;
            const dotProduct = normalX * sunVector[0] + normalY * sunVector[1];
            const lighting = 1.0 + dotProduct * 0.5;
            return Math.max(0.6, Math.min(1.4, lighting));
        }

        function getTreePlacementRadius(biome, sliders) {
            const multiplier = sliders.treeDensityMultiplier || 1;
            let baseRadius = 0;
            switch (biome) {
                case 'forest': case 'jungle': case 'taiga': baseRadius = 4; break;
                case 'forestHills': case 'jungleHills': case 'taigaHills': baseRadius = 5; break;
                case 'swamp': baseRadius = 7; break;
                case 'plain': baseRadius = 9; break;
                case 'savanna': baseRadius = 12; break;
                default: return 0; // No trees in other biomes
            }
            return Math.max(1, baseRadius / multiplier);
        }

        function getFishPlacementRadius(biome, sliders) {
            const multiplier = sliders.fishDensityMultiplier || 1;
            if (multiplier === 0) return 0;
            if (biome.includes('Water') || /river/i.test(biome)) {
                let base = Math.max(2, 10 / multiplier);
                if (/deltaRiver|marshRiver/i.test(biome)) base = Math.max(2, 8 / multiplier); // a bit denser
                return base;
            }
            return 0;
        }

        function getTimeOfDayInfo() {
            const nightTint = [0.45, 0.5, 0.75], sunriseTint = [1.0, 0.75, 0.6], dayTint = [1.0, 1.0, 1.0];
            let tint;
            if (timeOfDay < 0.25) tint = lerpColor(nightTint, sunriseTint, timeOfDay / 0.25);
            else if (timeOfDay < 0.5) tint = lerpColor(sunriseTint, dayTint, (timeOfDay - 0.25) / 0.25);
            else if (timeOfDay < 0.75) tint = lerpColor(dayTint, sunriseTint, (timeOfDay - 0.5) / 0.25);
            else tint = lerpColor(sunriseTint, nightTint, (timeOfDay - 0.75) / 0.25);
            const lightLevel = 0.2 + (Math.max(0, Math.sin(timeOfDay * Math.PI * 2)) * 0.8);
            return { lightLevel, tint };
        }
        function lerpColor(c1, c2, t) { return [c1[0] + (c2[0] - c1[0]) * t, c1[1] + (c2[1] - c1[1]) * t, c1[2] + (c2[2] - c1[2]) * t]; }
        function formatTime(time) {
            const hours = Math.floor(time * 24), minutes = Math.floor(((time * 24) - hours) * 60);
            const ampm = hours >= 12 ? 'PM' : 'AM';
            const displayHours = hours % 12 === 0 ? 12 : hours % 12;
            return `${displayHours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')} ${ampm}`;
        }

        // =================================================================================
        // CHUNKS AND DRAWING
        // =================================================================================
        let perlin, isGenerating = false, isGamePaused = false, isDebugViewActive = false, isContourOverlayActive = false;
        // --- Weather & Season (globals) ---
        const Weather = { type: '‚òÄÔ∏è', until: 0 }; // ‚òÄÔ∏è (clear) | üåßÔ∏è (rain) | ‚ùÑÔ∏è (snow)
        let season = 0.25; // 0..1 (winter‚Üíspring‚Üísummer‚Üíautumn bias)

        let keys = {}, timeOfDay = 0.25, lastFrameTime = 0, lastFpsUpdateTime = 0;
        const fpsHistory = [], messages = [], particles = [];
        let minFps = Infinity, maxFps = 0;

        let player = {
            x: 0, y: 0,
            fishLog: {}
        };

        let DOMElements, canvas, viewport, playerDiv, playerEmojiSpan, seedInput, ctx, sliders;
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        minimapCanvas.width = minimapCanvas.height = 100;

        const CHUNK_SIZE = 32, MAX_CACHE_SIZE = 250;
        const chunkCache = new Map();
        const rawNoiseCache = new Map();
        let lastMinimapPlayerPos = { x: null, y: null };

        function getSliderValues() {
            return {
                heightScale: parseFloat(sliders.heightScale.slider.value),
                moistureScale: parseFloat(sliders.moistureScale.slider.value),
                climateContrast: parseFloat(sliders.climateContrast.slider.value),
                pixelScale: parseFloat(sliders.pixelScale.slider.value),
                persistence: parseFloat(sliders.persistence.slider.value),
                playerSpeed: parseFloat(sliders.playerSpeed.slider.value),
                waterLevel: parseFloat(sliders.waterLevel.slider.value),
                treeDensityMultiplier: parseFloat(sliders.treeDensity.slider.value),
                fishDensityMultiplier: parseFloat(sliders.fishDensity.slider.value),
                mapScale: parseFloat(sliders.mapScale.slider.value),
            };
        }

        function manageCache() {
            if (chunkCache.size <= MAX_CACHE_SIZE) return;
            const playerChunkX = Math.floor(player.x / CHUNK_SIZE), playerChunkY = Math.floor(player.y / CHUNK_SIZE);
            let farthestKey = null, maxDistSq = -1;
            for (const key of chunkCache.keys()) {
                const [cx, cy] = key.split(',').map(Number);
                const distSq = (cx - playerChunkX) ** 2 + (cy - playerChunkY) ** 2;
                if (distSq > maxDistSq) { maxDistSq = distSq; farthestKey = key; }
            }
            if (farthestKey) { chunkCache.delete(farthestKey); }
        }

        function generatePerlinMaps() {
            const seed = parseInt(seedInput.value) || 0;
            perlin = {
                height: new PerlinNoise(seed), moisture: new PerlinNoise(seed + 1),
                object: new PerlinNoise(seed + 2), temperature: new PerlinNoise(seed + 3),
                river: new PerlinNoise(seed + 4)
            };
        }

        // --- Helpers for biome-aware rivers ----------------------------------------
        function rgbMix([r1, g1, b1], [r2, g2, b2], a) {
            return [Math.round(r1 * (1 - a) + r2 * a), Math.round(g1 * (1 - a) + g2 * a), Math.round(b1 * (1 - a) + b2 * a)];
        }

        // Sample 8-neighborhood to find dominant *land* biome around (local grid coords)
        function getDominantNeighborLandBiome(biomeGrid, x, y) {
            const w = CHUNK_SIZE, h = CHUNK_SIZE;
            const counts = {};
            const isLand = b => b && !(b.includes('Water') || /river/i.test(b)) && b !== 'beach' && b !== 'snowyBeach';
            for (let j = -1; j <= 1; j++) {
                for (let i = -1; i <= 1; i++) {
                    if (i === 0 && j === 0) continue;
                    const xx = x + i, yy = y + j;
                    if (xx < 0 || yy < 0 || xx >= w || yy >= h) continue;
                    const b = biomeGrid[yy * w + xx];
                    if (isLand(b)) counts[b] = (counts[b] || 0) + 1;
                }
            }
            // return most frequent land biome (or null)
            let best = null, c = -1;
            for (const k in counts) if (counts[k] > c) { c = counts[k]; best = k; }
            return best;
        }

        // Map surrounding land biome -> river style (color tint, extra width, speed tweak)
        function getRiverStyle(surroundBiome, nearSea) {
            // default classic blue
            let tint = [37, 174, 255], // base shallow-water blue
                extraWidth = 0,      // extra halo pixels
                alpha = 0.16,        // halo opacity
                speedMul = 0.4,      // baseline matches your lowlandRiver default
                fishBoost = 0;       // small density bias

            if (nearSea) { // delta behavior
                tint = [60, 170, 200];   // murkier
                extraWidth += 1; alpha = 0.22; fishBoost += 0.2; // denser fish in deltas
            }

            if (!surroundBiome) return { tint, extraWidth, alpha, speedMul, fishBoost };

            if (/mountain|snowy|ice/i.test(surroundBiome)) {
                tint = [30, 140, 210];        // cooler / glacial hint
                speedMul = 0.45;            // slightly faster
                alpha = Math.max(alpha, 0.18);
            } else if (/forest|plain|taiga/i.test(surroundBiome)) {
                tint = [37, 174, 255];        // classic
                speedMul = 0.4;
            } else if (/jungle|swamp/i.test(surroundBiome)) {
                tint = [85, 70, 40];        // tea/blackwater
                extraWidth += 1;            // marshy fringing
                alpha = 0.22;
                speedMul = 0.35;            // slower
                fishBoost += 0.15;          // catfish/piranha thrive
            } else if (/desert|badlands/i.test(surroundBiome)) {
                tint = [185, 150, 70];      // silty/yellow-brown
                extraWidth += 1; alpha = 0.2;
                speedMul = 0.4;
            } else if (/savanna/i.test(surroundBiome)) {
                tint = rgbMix([37, 174, 255], [185, 150, 70], 0.25); // slightly siltier than forest
                speedMul = 0.4;
            }
            return { tint, extraWidth, alpha, speedMul, fishBoost };
        }

        // --- River current: derive flow from height gradient ------------------------
        function getHeightGrad(wx, wy, perlin, sliders) {
            // finite difference on your continuous height field
            const hC = getHeightValueAtWorldCoords(wx, wy, perlin.height, sliders.heightScale, sliders.persistence, sliders.mapScale);
            const hX = getHeightValueAtWorldCoords(wx + 1, wy, perlin.height, sliders.heightScale, sliders.persistence, sliders.mapScale);
            const hY = getHeightValueAtWorldCoords(wx, wy + 1, perlin.height, sliders.heightScale, sliders.persistence, sliders.mapScale);
            // gradient points "uphill"; flow is opposite
            return { fx: hC - hX, fy: hC - hY }; // flow ~ downhill vector
        }

        // normalize with safe guard
        function normVec(x, y) {
            const m = Math.hypot(x, y) || 1e-6;
            return { x: x / m, y: y / m };
        }

        function generateChunkData(chunkX, chunkY, sliders, sunVector, seed) {
            const key = `${chunkX},${chunkY}`;
            // Store per-pixel biome; used by banks/branches/foam
            const biomeGrid = new Array(CHUNK_SIZE * CHUNK_SIZE);

            // Fast helpers
            const isRiverLike = (b) => b && /river/i.test(b);
            const isWaterLike = (b) => b && (b.includes('Water') || isRiverLike(b) || b === 'beach' || b === 'snowyBeach');

            const chunkCanvas = document.createElement('canvas');
            chunkCanvas.width = chunkCanvas.height = CHUNK_SIZE;
            const chunkCtx = chunkCanvas.getContext('2d'), chunkImageData = chunkCtx.createImageData(CHUNK_SIZE, CHUNK_SIZE);
            const data = chunkImageData.data, objects = [];

            for (let y = 0; y < CHUNK_SIZE; y++) {
                for (let x = 0; x < CHUNK_SIZE; x++) {
                    const worldX = chunkX * CHUNK_SIZE + x, worldY = chunkY * CHUNK_SIZE + y;

                    const biome = getBiomeAtWorldCoords(worldX, worldY, perlin, sliders);
                    biomeGrid[y * CHUNK_SIZE + x] = biome;
                    const heightValue = getHeightValueAtWorldCoords(worldX, worldY, perlin.height, sliders.heightScale, sliders.persistence, sliders.mapScale);
                    const baseColor = BIOME_COLORS[biome] || [0, 0, 0];
                    const lightness = getPixelLightness(worldX, worldY, heightValue, perlin.height, sliders, sunVector);

                    const [r, g, b] = baseColor.map(c => Math.min(255, Math.max(0, c * lightness)));
                    const idx = (y * CHUNK_SIZE + x) * 4;
                    [data[idx], data[idx + 1], data[idx + 2], data[idx + 3]] = [r, g, b, 255];
                }
            }
            chunkCtx.putImageData(chunkImageData, 0, 0);
            // --- Biome-aware river rendering & bank effects -----------------------------
            const riverHints = []; // per-pixel style hints (for speed/fish nudges at runtime)

            const nearSeaH = 148;
            const heightCacheLocal = new Map();

            function isNearSea(wx, wy) {
                const h = getAbsoluteHeight(wx, wy, perlin, sliders, heightCacheLocal);
                return h < 140 && h >= 132; // your near-beach buffer
            }

            // clear any prior shading and redraw banks/tints
            const riverOverlay = chunkCtx; // draw directly for speed
            for (let y = 0; y < CHUNK_SIZE; y++) {
                for (let x = 0; x < CHUNK_SIZE; x++) {
                    const i = y * CHUNK_SIZE + x;
                    const b = biomeGrid[i];
                    if (!isRiverLike(b)) continue;

                    const worldX = chunkX * CHUNK_SIZE + x;
                    const worldY = chunkY * CHUNK_SIZE + y;

                    const domLand = getDominantNeighborLandBiome(biomeGrid, x, y);
                    const style = getRiverStyle(domLand, isNearSea(worldX, worldY));

                    // Tint the river pixel toward style.tint (mix with what‚Äôs already drawn)
                    const img = chunkCtx.getImageData(x, y, 1, 1);
                    const pr = img.data[0], pg = img.data[1], pb = img.data[2];
                    const [nr, ng, nb] = rgbMix([pr, pg, pb], style.tint, 0.55); // strong tint
                    img.data[0] = nr; img.data[1] = ng; img.data[2] = nb; img.data[3] = 255;
                    chunkCtx.putImageData(img, x, y);

                    // Halo to fake width/braiding (1px ring; wider in deserts/delta/jungle)
                    if (style.extraWidth > 0) {
                        riverOverlay.fillStyle = `rgba(${style.tint[0]}, ${style.tint[1]}, ${style.tint[2]}, ${style.alpha})`;
                        // ring in 4-neighborhood
                        if (x > 0 && !isRiverLike(biomeGrid[i - 1])) riverOverlay.fillRect(x - 1, y, 1, 1);
                        if (x < CHUNK_SIZE - 1 && !isRiverLike(biomeGrid[i + 1])) riverOverlay.fillRect(x + 1, y, 1, 1);
                        if (y > 0 && !isRiverLike(biomeGrid[i - CHUNK_SIZE])) riverOverlay.fillRect(x, y - 1, 1, 1);
                        if (y < CHUNK_SIZE - 1 && !isRiverLike(biomeGrid[i + CHUNK_SIZE])) riverOverlay.fillRect(x, y + 1, 1, 1);
                    }

                    // flow vector (world space) for this river pixel
                    const g = getHeightGrad(worldX, worldY, perlin, sliders);
                    const nv = normVec(g.fx, g.fy);
                    // base speed from style; scale a bit with gradient magnitude
                    const gradMag = Math.min(1, Math.hypot(g.fx, g.fy) * 4.0);
                    const currentStrength = style.speedMul * (0.6 + 0.6 * gradMag); // 0..~0.9

                    riverHints.push({
                        x, y,
                        speedMul: style.speedMul,
                        fishBoost: style.fishBoost,
                        flow: { x: nv.x * currentStrength, y: nv.y * currentStrength }
                    });
                }
            }



            const trees = PoissonDisk.generatePointsForChunk(chunkX, chunkY, perlin, sliders, seed,
                getTreePlacementRadius,
                (biome) => getTreePlacementRadius(biome, sliders) > 0,
                (c) => {
                    const possibleTrees = Object.values(TREE_TYPES).filter(t => t.biomes.includes(c.biome));
                    if (possibleTrees.length === 0) return null;

                    const typeRand = seededRandom(c.x * c.y + seed + 1)();
                    const treeIndex = Math.floor(typeRand * possibleTrees.length);
                    const treeType = possibleTrees[treeIndex];
                    if (!treeType) return null;

                    const heightRand = seededRandom(c.x * 123 + c.y * 456 + seed + 4)();
                    const height = treeType.minHeight + Math.floor(heightRand * (treeType.maxHeight - treeType.minHeight + 1));

                    const offsetXRand = seededRandom(c.x * 987 + c.y * 654 + seed + 2)();
                    const offsetYRand = seededRandom(c.x * 321 + c.y * 123 + seed + 3)();

                    const offsetX = (offsetXRand - 0.5) * 0.8;
                    const offsetY = (offsetYRand - 0.5) * 0.8;

                    return {
                        x: Math.round(c.x),
                        y: Math.round(c.y),
                        type: 'tree',
                        emoji: treeType.emoji,
                        height: height,
                        offsetX,
                        offsetY
                    };
                }
            );

            const fish = PoissonDisk.generatePointsForChunk(chunkX, chunkY, perlin, sliders, seed,
                getFishPlacementRadius,
                (biome) => biome.includes('Water') || biome === 'river',
                (c) => {
                    const possibleFish = Object.entries(FISH_TYPES).filter(([_, f]) => f.biomes.includes(c.biome));
                    if (possibleFish.length === 0) return null;
                    const rand = seededRandom(c.x * c.y + seed)();
                    let totalRarity = possibleFish.reduce((sum, [_, f]) => sum + f.rarity, 0);
                    let choice = rand * totalRarity;
                    for (const [name, fishData] of possibleFish) {
                        if (choice < fishData.rarity) return { x: Math.round(c.x), y: Math.round(c.y), type: 'fish', name, emoji: fishData.emoji };
                        choice -= fishData.rarity;
                    }
                    const [name, fishData] = possibleFish[possibleFish.length - 1];
                    return { x: Math.round(c.x), y: Math.round(c.y), type: 'fish', name, emoji: fishData.emoji };
                }
            );

            objects.push(...trees.filter(t => t !== null), ...fish.filter(f => f !== null));
            chunkCache.set(key, { canvas: chunkCanvas, objects, riverHints }); // instead of earlier set
            manageCache();
        }

        function drawWorld() {
            if (isGenerating || !perlin) return { visibleTrees: 0, visibleFish: 0 };
            if (isDebugViewActive) { drawDebugNoiseView(); return { visibleTrees: 0, visibleFish: 0, visibleBiomeCounts: {} }; }

            const sliders = getSliderValues();
            const { pixelScale } = sliders;
            const viewportWidth = viewport.clientWidth, viewportHeight = viewport.clientHeight;

            canvas.width = viewportWidth; canvas.height = viewportHeight;
            ctx.clearRect(0, 0, viewportWidth, viewportHeight);
            ctx.imageSmoothingEnabled = false;

            const viewTilesX = viewportWidth / pixelScale, viewTilesY = viewportHeight / pixelScale;
            const startTileX = player.x - viewTilesX / 2, endTileX = player.x + viewTilesX / 2;
            const startTileY = player.y - viewTilesY / 2, endTileY = player.y + viewTilesY / 2;
            const startChunkX = Math.floor(startTileX / CHUNK_SIZE), endChunkX = Math.ceil(endTileX / CHUNK_SIZE);
            const startChunkY = Math.floor(startTileY / CHUNK_SIZE), endChunkY = Math.ceil(endTileY / CHUNK_SIZE);

            let visibleTrees = 0, visibleFish = 0;
            const visibleBiomeCounts = {};

            const angle = (timeOfDay - 0.25) * 2 * Math.PI;
            const sunVector = [-Math.cos(angle), -Math.sin(angle)];
            const seed = parseInt(seedInput.value) || 0;

            for (let cy = startChunkY; cy < endChunkY; cy++) {
                for (let cx = startChunkX; cx < endChunkX; cx++) {
                    const key = `${cx},${cy}`;
                    if (!chunkCache.has(key)) { generateChunkData(cx, cy, sliders, sunVector, seed); }
                    const chunk = chunkCache.get(key);
                    if (!chunk) continue;

                    const screenX = Math.round((cx * CHUNK_SIZE - startTileX) * pixelScale);
                    const screenY = Math.round((cy * CHUNK_SIZE - startTileY) * pixelScale);

                    ctx.drawImage(chunk.canvas, screenX, screenY, CHUNK_SIZE * pixelScale, CHUNK_SIZE * pixelScale);

                    const now = performance.now();
                    if (chunk.riverHints && pixelScale >= 8) {
                        ctx.globalAlpha = 0.18;
                        ctx.fillStyle = '#ffffff';
                        for (let k = 0; k < chunk.riverHints.length; k += 3) {
                            const h = chunk.riverHints[k];
                            const sx = Math.round((h.x + ((now / 700) % 1) * (h.flow?.x ? Math.sign(h.flow.x) : 0)) * pixelScale) + screenX;
                            const sy = Math.round((h.y + ((now / 700) % 1) * (h.flow?.y ? Math.sign(h.flow.y) : 0)) * pixelScale) + screenY;
                            ctx.fillRect(sx, sy, Math.max(1, pixelScale / 6), Math.max(1, pixelScale / 6));
                        }
                        ctx.globalAlpha = 1.0;
                    }

                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

                    for (const obj of chunk.objects) {
                        const objScreenX = (obj.x - startTileX) * pixelScale, objScreenY = (obj.y - startTileY) * pixelScale;
                        if (objScreenX >= -pixelScale && objScreenX <= viewportWidth && objScreenY >= -pixelScale && objScreenY <= viewportHeight) {
                            if (obj.type === 'tree') {
                                visibleTrees++;
                                const baseSize = pixelScale * 1.2;
                                const heightScale = obj.height * 0.5;
                                ctx.font = `${baseSize * heightScale}px sans-serif`;
                                const renderX = objScreenX + pixelScale / 2 + (obj.offsetX || 0) * pixelScale;
                                const renderY = objScreenY + pixelScale / 2 + (obj.offsetY || 0) * pixelScale;

                                ctx.textBaseline = 'bottom';
                                ctx.textAlign = 'center';
                                ctx.fillText(obj.emoji, renderX, renderY);
                            } else if (obj.type === 'fish') {
                                visibleFish++;
                                ctx.globalAlpha = 0.6 + Math.sin(Date.now() / 200 + obj.x) * 0.3;
                                ctx.font = `${pixelScale * 0.8}px sans-serif`;
                                ctx.fillText(obj.emoji, objScreenX + pixelScale / 2, objScreenY + pixelScale / 2);
                                ctx.globalAlpha = 1.0;
                            }
                        }
                    }
                }
            }

            for (let wy = Math.floor(startTileY); wy < Math.ceil(endTileY); wy++) {
                for (let wx = Math.floor(startTileX); wx < Math.ceil(endTileX); wx++) {
                    const biome = getBiomeAtWorldCoords(wx, wy, perlin, sliders);
                    visibleBiomeCounts[biome] = (visibleBiomeCounts[biome] || 0) + 1;
                }
            }

            if (isContourOverlayActive) {
                const contourInterval = 20; // Draw a line every 20 height units
                const majorContourInterval = 100; // Thicker line and label
                const contourColor = 'rgba(0, 0, 0, 0.4)';
                const majorContourColor = 'rgba(0, 0, 0, 0.7)';
                const labelColor = 'rgba(255, 255, 255, 0.9)';
                const heightCache = new Map();
                const labelInterval = Math.max(10, Math.round(120 / pixelScale));

                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'black';
                ctx.shadowBlur = 2;


                for (let y = Math.floor(startTileY); y < endTileY; y++) {
                    for (let x = Math.floor(startTileX); x < endTileX; x++) {
                        const h1 = getAbsoluteHeight(x, y, perlin, sliders, heightCache);

                        const h2 = getAbsoluteHeight(x + 1, y, perlin, sliders, heightCache);
                        let minH = Math.min(h1, h2), maxH = Math.max(h1, h2);
                        let contourLevel = Math.ceil(minH / contourInterval) * contourInterval;

                        while (contourLevel < maxH) {
                            const isMajor = contourLevel % majorContourInterval === 0;
                            ctx.strokeStyle = isMajor ? majorContourColor : contourColor;
                            ctx.lineWidth = isMajor ? 2 : 1.5;

                            const screenX = (x + 1 - startTileX) * pixelScale;
                            const screenY = (y - startTileY) * pixelScale;
                            ctx.beginPath();
                            ctx.moveTo(screenX, screenY);
                            ctx.lineTo(screenX, screenY + pixelScale);
                            ctx.stroke();

                            if (y % labelInterval === 0) {
                                ctx.font = `bold ${isMajor ? Math.max(9, pixelScale / 1.4) : Math.max(7, pixelScale / 1.6)}px sans-serif`;
                                ctx.fillStyle = labelColor;
                                ctx.fillText(contourLevel, screenX + 3, screenY + pixelScale / 2);
                            }
                            contourLevel += contourInterval;
                        }

                        const h3 = getAbsoluteHeight(x, y + 1, perlin, sliders, heightCache);
                        minH = Math.min(h1, h3); maxH = Math.max(h1, h3);
                        contourLevel = Math.ceil(minH / contourInterval) * contourInterval;

                        while (contourLevel < maxH) {
                            const isMajor = contourLevel % majorContourInterval === 0;
                            ctx.strokeStyle = isMajor ? majorContourColor : contourColor;
                            ctx.lineWidth = isMajor ? 2 : 1.5;

                            const screenX = (x - startTileX) * pixelScale;
                            const screenY = (y + 1 - startTileY) * pixelScale;
                            ctx.beginPath();
                            ctx.moveTo(screenX, screenY);
                            ctx.lineTo(screenX + pixelScale, screenY);
                            ctx.stroke();

                            if (x % labelInterval === 0) {
                                ctx.font = `bold ${isMajor ? Math.max(9, pixelScale / 1.4) : Math.max(7, pixelScale / 1.6)}px sans-serif`;
                                ctx.fillStyle = labelColor;
                                ctx.fillText(contourLevel, screenX + pixelScale / 2, screenY + 3);
                            }
                            contourLevel += contourInterval;
                        }
                    }
                }
                ctx.shadowBlur = 0; // Reset shadow
            }

            const timeInfo = getTimeOfDayInfo();
            const centerX = canvas.width / 2, horizonY = canvas.height / 2 + 50, skyPathRadius = Math.min(canvas.width, canvas.height) * 0.7;
            const sunX = centerX - Math.cos(angle) * skyPathRadius, sunY = horizonY - Math.sin(angle) * skyPathRadius;
            const moonX = centerX + Math.cos(angle) * skyPathRadius, moonY = horizonY + Math.sin(angle) * skyPathRadius;

            if (sunY < horizonY + 20) {
                ctx.fillStyle = 'rgba(255, 255, 150, 0.9)'; ctx.beginPath(); ctx.arc(sunX, sunY, 30, 0, 2 * Math.PI); ctx.fill();
            }
            if (moonY < horizonY + 20) {
                ctx.fillStyle = 'rgba(230, 230, 240, 0.8)'; ctx.beginPath(); ctx.arc(moonX, moonY, 25, 0, 2 * Math.PI); ctx.fill();
            }

            const overlayAlpha = (1 - timeInfo.lightLevel) * 0.75, tint = timeInfo.tint;
            ctx.fillStyle = `rgba(${tint[0] * 30}, ${tint[1] * 40}, ${tint[2] * 80}, ${overlayAlpha})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update();
                const pScreenX = (p.x - startTileX) * pixelScale, pScreenY = (p.y - startTileY) * pixelScale;
                ctx.fillRect(pScreenX, pScreenY, p.size, p.size);
                if (p.life <= 0) particles.splice(i, 1);
            }

            // --- Weather overlay & precipitation (drawn above particles) ---
            if (Weather.type === 'üåßÔ∏è') {
                // subtle cool tint
                ctx.fillStyle = 'rgba(60,80,120,0.08)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // rain streaks
                ctx.globalAlpha = 0.6;
                ctx.fillStyle = 'rgba(200, 200, 255, 0.9)';
                const n = Math.max(60, Math.min(140, Math.floor(canvas.width * canvas.height / 20000))); // scale with res
                const t = performance.now();
                for (let i = 0; i < n; i++) {
                    // pseudo-random but stable pattern
                    const rx = (i * 97 + t / 3) % canvas.width;
                    const ry = (i * 53 + t / 1.6) % canvas.height;
                    ctx.fillRect(rx, ry, 1, 8);
                }
                ctx.globalAlpha = 1.0;

            } else if (Weather.type === '‚ùÑÔ∏è') {
                // faint bright tint
                ctx.fillStyle = 'rgba(230,230,255,0.06)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // snowflakes
                ctx.globalAlpha = 0.9;
                ctx.fillStyle = 'rgba(255,255,255,0.95)';
                const n = Math.max(40, Math.min(110, Math.floor(canvas.width * canvas.height / 30000)));
                const t = performance.now();
                for (let i = 0; i < n; i++) {
                    const rx = (i * 137 + Math.sin(t / 900 + i) * 30 + canvas.width) % canvas.width;
                    const ry = (i * 71 + t / 5) % canvas.height;
                    ctx.fillRect(rx, ry, 2, 2);
                }
                ctx.globalAlpha = 1.0;
            }

            playerDiv.style.left = `${viewportWidth / 2}px`;
            playerDiv.style.top = `${viewportHeight / 2}px`;

            return { visibleTrees, visibleFish, visibleBiomeCounts };
        }

        function drawDebugNoiseView() {
            const sliders = getSliderValues();
            const { pixelScale } = sliders;
            const viewportWidth = viewport.clientWidth, viewportHeight = viewport.clientHeight;

            canvas.width = viewportWidth; canvas.height = viewportHeight;
            ctx.clearRect(0, 0, viewportWidth, viewportHeight);
            ctx.imageSmoothingEnabled = false;

            const viewTilesX = viewportWidth / pixelScale, viewTilesY = viewportHeight / pixelScale;
            const startTileX = player.x - viewTilesX / 2, endTileX = player.x + viewTilesX / 2;
            const startTileY = player.y - viewTilesY / 2, endTileY = player.y + viewTilesY / 2;

            for (let y = Math.floor(startTileY); y < Math.ceil(endTileY); y++) {
                for (let x = Math.floor(startTileX); x < Math.ceil(endTileX); x++) {
                    const noise = getOctaveNoise(x, y, perlin.river, 40, sliders.persistence, 10, sliders.mapScale);
                    const r = noise * 255, b = (1 - noise) * 255;
                    ctx.fillStyle = `rgb(${r}, 0, ${b})`;
                    ctx.fillRect((x - startTileX) * pixelScale, (y - startTileY) * pixelScale, pixelScale, pixelScale);
                }
            }
            playerDiv.style.left = `${viewportWidth / 2}px`;
            playerDiv.style.top = `${viewportHeight / 2}px`;
        }

        function drawMinimap() {
            const roundedPlayerX = Math.round(player.x), roundedPlayerY = Math.round(player.y);
            // No need to redraw minimap if player hasn't moved to a new tile
            if (lastMinimapPlayerPos.x === roundedPlayerX && lastMinimapPlayerPos.y === roundedPlayerY) return;
            lastMinimapPlayerPos.x = roundedPlayerX; lastMinimapPlayerPos.y = roundedPlayerY;

            minimapCtx.clearRect(0, 0, 100, 100);
            minimapCtx.imageSmoothingEnabled = false;

            const MINIMAP_ZOOM = 4; // Each pixel on minimap represents a 4x4 area of game tiles
            const startX = roundedPlayerX - (minimapCanvas.width / 2) * MINIMAP_ZOOM;
            const startY = roundedPlayerY - (minimapCanvas.height / 2) * MINIMAP_ZOOM;
            const sliders = getSliderValues();

            for (let y = 0; y < 100; y++) {
                for (let x = 0; x < 100; x++) {
                    const worldX = startX + x * MINIMAP_ZOOM;
                    const worldY = startY + y * MINIMAP_ZOOM;
                    const biome = getBiomeAtWorldCoords(worldX, worldY, perlin, sliders);
                    const color = BIOME_COLORS[biome] || [0, 0, 0];
                    minimapCtx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                    minimapCtx.fillRect(x, y, 1, 1);
                }
            }
        }

        // =================================================================================
        // GAME STATE, HUD, AND LOOP
        // =================================================================================
        function showMessage(msg) { messages.push(msg); if (messages.length === 1) displayNextMessage(); }
        function displayNextMessage() {
            if (messages.length === 0) return;
            const msg = messages[0];
            DOMElements.messageText.textContent = msg;
            DOMElements.messageText.classList.remove('hidden');
            DOMElements.messageText.classList.add('bubble-effect');
            setTimeout(() => {
                DOMElements.messageText.classList.remove('bubble-effect');
                setTimeout(() => {
                    DOMElements.messageText.classList.add('hidden');
                    messages.shift();
                    displayNextMessage();
                }, 2000);
            }, 500);
        }

        function updateHUD(currentBiome, visibleTrees = 0, visibleFish = 0, visibleBiomeCounts = {}) {
            const speedMod = getMovementSpeedModifier(currentBiome);
            DOMElements.speedModifierText.textContent = `${speedMod}x`;
            DOMElements.posText.textContent = `${Math.round(player.x)}, ${Math.round(player.y)}`;
            DOMElements.biomeText.textContent = currentBiome;
            DOMElements.timeText.textContent = formatTime(timeOfDay);
            DOMElements.treeCountText.textContent = visibleTrees;
            DOMElements.fishCountText.textContent = visibleFish;

            DOMElements.fishLog.innerHTML = '';
            const fishEntries = Object.keys(player.fishLog);
            if (fishEntries.length === 0) {
                DOMElements.fishLog.innerHTML = `<p class="text-gray-500 text-xs italic">No fish discovered</p>`;
            } else {
                for (const fishName of fishEntries) {
                    const fishInfo = FISH_TYPES[fishName];
                    DOMElements.fishLog.innerHTML += `<div class="flex justify-between items-center text-sm font-semibold"><span>${fishInfo.emoji} ${fishName.charAt(0).toUpperCase() + fishName.slice(1)}</span><span class="text-green-400">‚úì</span></div>`;
                }
            }

            const legendEntries = DOMElements.legendEntries;
            legendEntries.innerHTML = '';
            const sortedBiomes = Object.keys(visibleBiomeCounts).sort((a, b) => visibleBiomeCounts[b] - visibleBiomeCounts[a]);

            if (sortedBiomes.length === 0) {
                legendEntries.innerHTML = `<p class="text-gray-500 text-xs italic">No biomes in view</p>`;
            } else {
                for (const biomeName of sortedBiomes) {
                    const count = visibleBiomeCounts[biomeName];
                    const color = BIOME_COLORS[biomeName];
                    const colorHex = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;

                    const entryHTML = `
                        <div class="flex justify-between items-center">
                            <div class="flex items-center gap-2">
                                <div class="w-4 h-4 rounded-sm border border-gray-600" style="background-color: ${colorHex};"></div>
                                <span>${biomeName.charAt(0).toUpperCase() + biomeName.slice(1)}</span>
                            </div>
                            <span class="font-mono text-gray-400">${count}</span>
                        </div>
                    `;
                    legendEntries.innerHTML += entryHTML;
                }
            }


            DOMElements.keysText.textContent = Object.keys(keys).filter(k => keys[k]).map(k => k.toUpperCase()).join(', ') || '...';
            DOMElements.contourStatus.textContent = isContourOverlayActive ? 'On' : 'Off';
            DOMElements.contourStatus.classList.toggle('text-green-400', isContourOverlayActive);
            DOMElements.contourStatus.classList.toggle('text-red-400', !isContourOverlayActive);
        }

        class Particle {
            constructor(x, y) { this.x = x; this.y = y; this.life = 1; this.size = Math.random() * 2 + 1; this.vx = (Math.random() - 0.5) * 0.5; this.vy = -Math.random() * 0.5; }
            update() { this.x += this.vx; this.y += this.vy; this.life -= 0.05; }
        }

        // =================================================================================
        // GAME LOOP AND INPUT HANDLING
        // =================================================================================
        function gameLoop(timestamp) {
            requestAnimationFrame(gameLoop);
            if (isGamePaused) return;
            const deltaTime = (timestamp - lastFrameTime) / 1000 || 0;
            lastFrameTime = timestamp;

            if (timestamp - lastFpsUpdateTime > 100) {
                const fps = 1 / deltaTime;
                fpsHistory.push(fps); if (fpsHistory.length > 60) fpsHistory.shift();
                minFps = Math.min(minFps, fps); maxFps = Math.max(maxFps, fps);
                DOMElements.currentFps.textContent = Math.round(fps); DOMElements.minFps.textContent = Math.round(minFps); DOMElements.maxFps.textContent = Math.round(maxFps);
            }
            // --- Weather director: picks a weather regime for a short duration ---
            {
                const t = performance.now();
                if (t > Weather.until) {
                    const r = Math.random();
                    let next = 'clear';
                    let dur = 30000 + Math.random() * 30000; // 30‚Äì60s
                    if (season < 0.25) {          // winter bias
                        next = r < 0.40 ? '‚ùÑÔ∏è' : (r < 0.65 ? '‚òÄÔ∏è' : 'üåßÔ∏è');
                    } else if (season < 0.5) {    // spring
                        next = r < 0.45 ? 'üåßÔ∏è' : '‚òÄÔ∏è';
                    } else if (season < 0.75) {   // summer
                        next = r < 0.15 ? 'üåßÔ∏è' : '‚òÄÔ∏è';
                    } else {                      // autumn
                        next = r < 0.35 ? 'üåßÔ∏è' : '‚òÄÔ∏è';
                    }
                    Weather.type = next;
                    Weather.until = t + dur;
                }
            }

            const sliders = getSliderValues();
            let moveX = 0, moveY = 0;
            if (keys['w'] || keys['arrowup']) moveY -= 1; if (keys['s'] || keys['arrowdown']) moveY += 1;
            if (keys['a'] || keys['arrowleft']) moveX -= 1; if (keys['d'] || keys['arrowright']) moveX += 1;

            const mag = Math.hypot(moveX, moveY);
            if (mag > 0) { moveX /= mag; moveY /= mag; }

            const currentBiome = getBiomeAtWorldCoords(Math.round(player.x), Math.round(player.y), perlin, sliders);
            // after: const currentBiome = getBiomeAtWorldCoords(...);
            let speedModifier = getMovementSpeedModifier(currentBiome);
            // --- Weather speed nudge (mild global effect) ---
            let weatherSpeedMul = 1.0;
            if (Weather.type === 'üåßÔ∏è') weatherSpeedMul = 0.95;
            else if (Weather.type === '‚ùÑÔ∏è') weatherSpeedMul = 0.90;

            speedModifier *= weatherSpeedMul;
            // Apply river current drift to player
            if (/river/i.test(currentBiome)) {
                const cx = Math.floor(player.x / CHUNK_SIZE), cy = Math.floor(player.y / CHUNK_SIZE);
                const chunk = chunkCache.get(`${cx},${cy}`);
                if (chunk && chunk.riverHints && chunk.riverHints.length) {
                    const lx = Math.round(player.x - cx * CHUNK_SIZE);
                    const ly = Math.round(player.y - cy * CHUNK_SIZE);
                    let best = null, bestD = 2;
                    for (const h of chunk.riverHints) {
                        const d = Math.abs(h.x - lx) + Math.abs(h.y - ly);
                        if (d < bestD) { bestD = d; best = h; if (d === 0) break; }
                    }
                    if (best && best.flow) {
                        // deltaTime available here; gentle push that respects your playerSpeed
                        player.x += best.flow.x * 6 * deltaTime;
                        player.y += best.flow.y * 6 * deltaTime;
                    }
                }
            }



            player.x += moveX * sliders.playerSpeed * deltaTime * 10 * speedModifier;
            player.y += moveY * sliders.playerSpeed * deltaTime * 10 * speedModifier;

            // REPLACE this line:
            // const isSwimming = (currentBiome.includes('Water') || currentBiome === 'river');
            // WITH:
            const isSwimming = (currentBiome.includes('Water') || /river/i.test(currentBiome));
            playerEmojiSpan.textContent = isSwimming ? 'üèä' : 'üö∂';

            if (moveX > 0) playerEmojiSpan.style.transform = 'scaleX(-1)';
            else if (moveX < 0) playerEmojiSpan.style.transform = 'scaleX(1)';

            const { visibleTrees, visibleFish, visibleBiomeCounts } = drawWorld();
            drawMinimap();
            updateHUD(currentBiome, visibleTrees, visibleFish, visibleBiomeCounts || {});
        }

        function performInteraction(worldX, worldY) {
            if (isGenerating || isGamePaused || !perlin) return;
            const chunkX = Math.floor(worldX / CHUNK_SIZE), chunkY = Math.floor(worldY / CHUNK_SIZE);
            const chunk = chunkCache.get(`${chunkX},${chunkY}`);

            if (chunk) {
                const objIndex = chunk.objects.findIndex(obj => obj.x === worldX && obj.y === worldY);
                if (objIndex !== -1) {
                    const object = chunk.objects[objIndex];
                    if (object.type === 'fish') {
                        if (!player.fishLog[object.name]) {
                            player.fishLog[object.name] = true;
                            showMessage(`Discovered a ${object.name}! ${object.emoji}`);
                        } else {
                            showMessage(`You've already discovered the ${object.name}.`);
                        }
                        chunk.objects.splice(objIndex, 1);
                        for (let i = 0; i < 5; i++) particles.push(new Particle(worldX, worldY));
                    }
                }
            }
        }

        // =================================================================================
        // EVENT HANDLERS
        // =================================================================================
        function handleGenerate(isSeedChange = false) {
            if (isGenerating) return;
            DOMElements.loading.classList.remove('hidden');
            isGenerating = true;

            lastMinimapPlayerPos = { x: null, y: null }; // Force minimap redraw
            PoissonDisk.clearCache();
            rawNoiseCache.clear();
            chunkCache.clear();

            if (isSeedChange) {
                generatePerlinMaps();
            }

            drawWorld();
            drawMinimap();
            DOMElements.loading.classList.add('hidden');
            isGenerating = false;
            minFps = Infinity; maxFps = 0; fpsHistory.length = 0;
        }

        function handleLoadAndResize() {
            canvas.width = viewport.clientWidth; canvas.height = viewport.clientHeight;
            if (!isGenerating && perlin) { drawWorld(); drawMinimap(); }
        }

        function handleTimeSliderInteraction(event) {
            event.preventDefault();
            const rect = DOMElements.timeSliderContainer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2, centerY = rect.top + rect.height / 2;

            let wasPaused = isGamePaused;
            isGamePaused = true;

            function onMove(moveEvent) {
                const clientX = moveEvent.touches ? moveEvent.touches[0].clientX : moveEvent.clientX;
                const clientY = moveEvent.touches ? moveEvent.touches[0].clientY : moveEvent.clientY;
                const angleRad = Math.atan2(clientY - centerY, clientX - centerX) + Math.PI / 2;
                let angleDeg = angleRad * 180 / Math.PI;
                if (angleDeg < 0) angleDeg += 360;
                timeOfDay = angleDeg / 360;
                updateCircularSliderUI(timeOfDay);
                chunkCache.clear();
                drawWorld();
            }
            function onEnd() {
                window.removeEventListener('mousemove', onMove); window.removeEventListener('mouseup', onEnd);
                window.removeEventListener('touchmove', onMove); window.removeEventListener('touchend', onEnd);
                isGamePaused = wasPaused;
            }
            window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onEnd);
            window.addEventListener('touchmove', onMove); window.addEventListener('touchend', onEnd);
            onMove(event);
        }

        function updateCircularSliderUI(time) {
            const angle = time * 360;
            const r = 40, cx = 50, cy = 50;
            const handlePos = { x: cx + (r * Math.cos((angle - 90) * Math.PI / 180)), y: cy + (r * Math.sin((angle - 90) * Math.PI / 180)) };
            DOMElements.timeSliderHandle.setAttribute('cx', handlePos.x); DOMElements.timeSliderHandle.setAttribute('cy', handlePos.y);
            const endAngle = angle >= 359.99 ? 359.99 : angle;
            const start = { x: cx + (r * Math.cos((endAngle - 90) * Math.PI / 180)), y: cy + (r * Math.sin((endAngle - 90) * Math.PI / 180)) };
            const end = { x: cx + (r * Math.cos((-90) * Math.PI / 180)), y: cy + (r * Math.sin((-90) * Math.PI / 180)) };
            const largeArcFlag = endAngle <= 180 ? "0" : "1";
            DOMElements.timeSliderProgress.setAttribute('d', `M ${end.x} ${end.y} A ${r} ${r} 0 ${largeArcFlag} 1 ${start.x} ${start.y}`);
        }

        function setupMobileControls() {
            if (!('ontouchstart' in window)) return;
            DOMElements.mobileControls.classList.remove('hidden');
            let joystickTouchId = null;
            DOMElements.joystick.addEventListener('touchstart', (e) => { if (joystickTouchId === null) joystickTouchId = e.changedTouches[0].identifier; }, { passive: true });
            window.addEventListener('touchmove', (e) => {
                for (let touch of e.changedTouches) {
                    if (touch.identifier === joystickTouchId) {
                        const rect = DOMElements.joystick.getBoundingClientRect(), size = rect.width, handleSize = DOMElements.joystickHandle.clientWidth, maxDist = (size - handleSize) / 2;
                        let dx = touch.clientX - (rect.left + size / 2), dy = touch.clientY - (rect.top + size / 2);
                        const dist = Math.hypot(dx, dy);
                        if (dist > maxDist) { dx = (dx / dist) * maxDist; dy = (dy / dist) * maxDist; }
                        DOMElements.joystickHandle.style.transform = `translate(-50%, -50%) translate(${dx}px, ${dy}px)`;
                        keys['w'] = dy / maxDist < -0.2; keys['s'] = dy / maxDist > 0.2; keys['a'] = dx / maxDist < -0.2; keys['d'] = dx / maxDist > 0.2;
                        break;
                    }
                }
            }, { passive: true });
            window.addEventListener('touchend', (e) => {
                for (let touch of e.changedTouches) {
                    if (touch.identifier === joystickTouchId) {
                        joystickTouchId = null; DOMElements.joystickHandle.style.transform = `translate(-50%, -50%)`;
                        keys['w'] = keys['s'] = keys['a'] = keys['d'] = false; break;
                    }
                }
            });
        }

        window.onload = () => {
            DOMElements = {
                canvas: document.getElementById('canvas'),
                viewport: document.getElementById('viewport'),
                loading: document.getElementById('loading'),
                player: document.getElementById('player'),
                playerEmoji: document.getElementById('player-emoji'),
                speedModifierText: document.getElementById('speedModifierText'),
                posText: document.getElementById('posText'),
                biomeText: document.getElementById('biomeText'),
                timeText: document.getElementById('timeText'),
                treeCountText: document.getElementById('treeCountText'),
                fishCountText: document.getElementById('fishCountText'),
                keysText: document.getElementById('keysText'),
                fishLog: document.getElementById('fishLog'),
                currentFps: document.getElementById('currentFps'),
                minFps: document.getElementById('minFps'),
                maxFps: document.getElementById('maxFps'),
                messageBox: document.getElementById('messageBox'),
                messageText: document.getElementById('messageText'),
                contourStatus: document.getElementById('contourStatus'),
                settingsHud: document.getElementById('settingsHud'),
                toggleSettings: document.getElementById('toggleSettings'),
                legendHud: document.getElementById('legendHud'),
                toggleLegend: document.getElementById('toggleLegend'),
                legendEntries: document.getElementById('legendEntries'),
                seedInput: document.getElementById('seedInput'),
                heightScaleSlider: document.getElementById('heightScaleSlider'),
                heightScaleValue: document.getElementById('heightScaleValue'),
                moistureScaleSlider: document.getElementById('moistureScaleSlider'),
                moistureScaleValue: document.getElementById('moistureScaleValue'),
                climateContrastSlider: document.getElementById('climateContrastSlider'),
                climateContrastValue: document.getElementById('climateContrastValue'),
                pixelScaleSlider: document.getElementById('pixelScaleSlider'),
                pixelScaleValue: document.getElementById('pixelScaleValue'),
                persistenceSlider: document.getElementById('persistenceSlider'),
                persistenceValue: document.getElementById('persistenceValue'),
                playerSpeedSlider: document.getElementById('playerSpeedSlider'),
                playerSpeedValue: document.getElementById('playerSpeedValue'),
                waterLevelSlider: document.getElementById('waterLevelSlider'),
                waterLevelValue: document.getElementById('waterLevelValue'),
                treeDensitySlider: document.getElementById('treeDensitySlider'),
                treeDensityValue: document.getElementById('treeDensityValue'),
                fishDensitySlider: document.getElementById('fishDensitySlider'),
                fishDensityValue: document.getElementById('fishDensityValue'),
                mapScaleSlider: document.getElementById('mapScaleSlider'),
                mapScaleValue: document.getElementById('mapScaleValue'),
                timeSliderContainer: document.getElementById('timeSliderContainer'),
                timeSliderProgress: document.getElementById('timeSliderProgress'),
                timeSliderHandle: document.getElementById('timeSliderHandle'),
                mobileControls: document.getElementById('mobileControls'),
                joystick: document.getElementById('joystick'),
                joystickHandle: document.getElementById('joystickHandle'),
            };

            DOMElements.seedInput.value = Math.floor(Math.random() * 90000) + 10000; // Set a random starting seed

            ({ canvas, viewport, player: playerDiv, playerEmoji: playerEmojiSpan, seedInput } = DOMElements);
            ctx = canvas.getContext('2d');
            sliders = {
                heightScale: { slider: DOMElements.heightScaleSlider, span: DOMElements.heightScaleValue },
                moistureScale: { slider: DOMElements.moistureScaleSlider, span: DOMElements.moistureScaleValue },
                climateContrast: { slider: DOMElements.climateContrastSlider, span: DOMElements.climateContrastValue, fixed: 1 },
                persistence: { slider: DOMElements.persistenceSlider, span: DOMElements.persistenceValue },
                waterLevel: { slider: DOMElements.waterLevelSlider, span: DOMElements.waterLevelValue },
                treeDensity: { slider: DOMElements.treeDensitySlider, span: DOMElements.treeDensityValue, suffix: 'x', fixed: 1 },
                fishDensity: { slider: DOMElements.fishDensitySlider, span: DOMElements.fishDensityValue, suffix: 'x', fixed: 1 },
                mapScale: { slider: DOMElements.mapScaleSlider, span: DOMElements.mapScaleValue, fixed: 2 },
                pixelScale: { slider: DOMElements.pixelScaleSlider, span: DOMElements.pixelScaleValue, regen: false },
                playerSpeed: { slider: DOMElements.playerSpeedSlider, span: DOMElements.playerSpeedValue, regen: false },
            };

            DOMElements.toggleSettings.addEventListener('click', () => {
                DOMElements.settingsHud.classList.toggle('collapsed');
            });
            DOMElements.toggleLegend.addEventListener('click', () => {
                DOMElements.legendHud.classList.toggle('collapsed');
            });

            window.addEventListener('resize', handleLoadAndResize);
            seedInput.addEventListener('change', () => handleGenerate(true));
            for (const key in sliders) {
                const { slider, span, regen = true, suffix = '', fixed = 0 } = sliders[key];
                slider.addEventListener('input', () => {
                    span.textContent = `${parseFloat(slider.value).toFixed(fixed)}${suffix}`;
                    if (regen) handleGenerate(false);
                    else if (key === 'pixelScale' && !isGenerating) drawWorld();
                });
            }
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const slider = sliders.pixelScale.slider;
                let newPixelScale = parseInt(slider.value) - Math.sign(e.deltaY);
                slider.value = Math.max(1, Math.min(24, newPixelScale));
                sliders.pixelScale.span.textContent = slider.value;
                if (!isGenerating) drawWorld();
            });
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT') return;
                const key = e.key.toLowerCase();
                if (key === 'p') {
                    isDebugViewActive = !isDebugViewActive; chunkCache.clear();
                } else if (key === 'h') {
                    isContourOverlayActive = !isContourOverlayActive;
                }
                keys[e.key.toLowerCase()] = true;
            });
            document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
            canvas.addEventListener('click', (e) => {
                const pixelScale = parseInt(sliders.pixelScale.slider.value);
                const rect = canvas.getBoundingClientRect();
                const worldX = Math.floor((player.x - (viewport.clientWidth / pixelScale) / 2) + (e.clientX - rect.left) / pixelScale);
                const worldY = Math.floor((player.y - (viewport.clientHeight / pixelScale) / 2) + (e.clientY - rect.top) / pixelScale);
                performInteraction(worldX, worldY);
            });

            DOMElements.timeSliderContainer.addEventListener('mousedown', handleTimeSliderInteraction);
            DOMElements.timeSliderContainer.addEventListener('touchstart', handleTimeSliderInteraction);

            generatePerlinMaps();
            handleLoadAndResize();
            setupMobileControls();
            updateCircularSliderUI(timeOfDay);
            gameLoop(0);
        };
    </script>
</body>
</html>